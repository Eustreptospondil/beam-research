[
  {
    "objectID": "balka.html",
    "href": "balka.html",
    "title": "Разбор задачи о шарнирно опёртой балке с «неполным» набором граничных условий",
    "section": "",
    "text": "Одним прекрасным октябрьским днём раздался вопрос из зала от господина Ш.:\n\nКоллеги, столкнулся с совсем банальностью… Хотел посчитать прогиб свободной опёртой балки под вертикальным ускорением. Делал соответственно через beam elements. Накладываю на обоих концах ограничения через Remote displacements: ограничивая перемещения 0, повороты оставляю Free. Использовал прямой решатель с мягкими пружинами. В итоге решатель выдаёт ошибку – матрица жёсткости вырождена, бла-бла-бла, тра-ла-ла… Пробовал через simply supported – та же самая история… Причём на shell’ах, где тоже 6 степеней свободы в узле как бе, с такими же ограничениями как на бимах всё бодренько считает… В Solidworks Simulation без всяких танцев с бубном получаю результат\n\nЧто надо делать, мы оперативно обсудили, но вопрос «почему здесь вот так, а здесь не так» остался лежать до лучших времён. Вот эти времена и настали. Начнём с двух оценочных суждений:\n\nНа мой взгляд, Solidworks Simulation – это инструмент, предназначенный, в первую очередь, для подпирающего справочником Писаренко собственноручно спроектированный стол конструктора-недоучки, чтобы тот гордо размахивал цветными картинками (не имеющими никакого отношения к делу), верещал «Ну вот, я же посчитал!» (на расчётную схему без слёз не взглянешь) и доводил меня до белого каления. Так как других кейсов использования данного программного продукта мне встречать не доводилось, то на моей технике его не было, нет и не будет, а рассматривать его в дальнейшем будем (не будем) лишь в теоретическом плане.\nНа мой взгляд, «мягкие пружины» (weak springs) представляют собой «костыль» для тех, кто по тем или иным причинам должным образом не задаёт полный набор граничных условий, а их использование при проведении прочностных расчётов – плохая практика.\n\nА теперь перейдём к основной части и попробуем разобраться, что же считает нам вычислительная машина, каким образом получается тот или иной результат, как устроены «мягкие пружины», ну и, может быть, сделаем какой-нибудь вывод. Изначально предполагалось, что получение ответа на все вопросы займёт совсем немного времени, но обработка некоторых результатов затянулась, я то болел, то пил, то работал, а энтузиазм разбираться со всем этим периодически угасал.\nДля большей простоты и наглядности немного упростим задачку и будем рассматривать её в следующей постановке: линейно упругая стальная (модуль упругости \\(E=20000~{\\text{кгс/мм}}^2\\), коэффициент Пуассона \\(\\mu=0,3\\)) балка длиной \\(L=600~{\\text{мм}}\\), поперечное сечение которой – круг радиусом \\(R=5~{\\text{мм}}\\), шарнирно опёрта на торцах и нагружена в центре поперечной силой, равной \\(F=1~{\\text{кгс}}\\). При этом в узлах опирания ограничены только перемещения, а все углы поворота оставлены свободными. Конечноэлементная сетка будет включать в себя целых два балочных элемента."
  },
  {
    "objectID": "balka.html#введение",
    "href": "balka.html#введение",
    "title": "Разбор задачи о шарнирно опёртой балке с «неполным» набором граничных условий",
    "section": "",
    "text": "Одним прекрасным октябрьским днём раздался вопрос из зала от господина Ш.:\n\nКоллеги, столкнулся с совсем банальностью… Хотел посчитать прогиб свободной опёртой балки под вертикальным ускорением. Делал соответственно через beam elements. Накладываю на обоих концах ограничения через Remote displacements: ограничивая перемещения 0, повороты оставляю Free. Использовал прямой решатель с мягкими пружинами. В итоге решатель выдаёт ошибку – матрица жёсткости вырождена, бла-бла-бла, тра-ла-ла… Пробовал через simply supported – та же самая история… Причём на shell’ах, где тоже 6 степеней свободы в узле как бе, с такими же ограничениями как на бимах всё бодренько считает… В Solidworks Simulation без всяких танцев с бубном получаю результат\n\nЧто надо делать, мы оперативно обсудили, но вопрос «почему здесь вот так, а здесь не так» остался лежать до лучших времён. Вот эти времена и настали. Начнём с двух оценочных суждений:\n\nНа мой взгляд, Solidworks Simulation – это инструмент, предназначенный, в первую очередь, для подпирающего справочником Писаренко собственноручно спроектированный стол конструктора-недоучки, чтобы тот гордо размахивал цветными картинками (не имеющими никакого отношения к делу), верещал «Ну вот, я же посчитал!» (на расчётную схему без слёз не взглянешь) и доводил меня до белого каления. Так как других кейсов использования данного программного продукта мне встречать не доводилось, то на моей технике его не было, нет и не будет, а рассматривать его в дальнейшем будем (не будем) лишь в теоретическом плане.\nНа мой взгляд, «мягкие пружины» (weak springs) представляют собой «костыль» для тех, кто по тем или иным причинам должным образом не задаёт полный набор граничных условий, а их использование при проведении прочностных расчётов – плохая практика.\n\nА теперь перейдём к основной части и попробуем разобраться, что же считает нам вычислительная машина, каким образом получается тот или иной результат, как устроены «мягкие пружины», ну и, может быть, сделаем какой-нибудь вывод. Изначально предполагалось, что получение ответа на все вопросы займёт совсем немного времени, но обработка некоторых результатов затянулась, я то болел, то пил, то работал, а энтузиазм разбираться со всем этим периодически угасал.\nДля большей простоты и наглядности немного упростим задачку и будем рассматривать её в следующей постановке: линейно упругая стальная (модуль упругости \\(E=20000~{\\text{кгс/мм}}^2\\), коэффициент Пуассона \\(\\mu=0,3\\)) балка длиной \\(L=600~{\\text{мм}}\\), поперечное сечение которой – круг радиусом \\(R=5~{\\text{мм}}\\), шарнирно опёрта на торцах и нагружена в центре поперечной силой, равной \\(F=1~{\\text{кгс}}\\). При этом в узлах опирания ограничены только перемещения, а все углы поворота оставлены свободными. Конечноэлементная сетка будет включать в себя целых два балочных элемента."
  },
  {
    "objectID": "balka.html#результаты-решения-в-приличных-не-solidworks-программных-комплексах",
    "href": "balka.html#результаты-решения-в-приличных-не-solidworks-программных-комплексах",
    "title": "Разбор задачи о шарнирно опёртой балке с «неполным» набором граничных условий",
    "section": "1. Результаты решения в приличных (не SolidWorks) программных комплексах",
    "text": "1. Результаты решения в приличных (не SolidWorks) программных комплексах\n\n1.1 ANSYS\nРезультат решения задачи в указанной постановке представлены на рисунке 1. Такую задачу программа считать отказалась, любезно предоставив нам сообщение об ошибке с указанием на нехватку ограничений по углу поворота балки вокруг оси балки.\n\n\n\nРисунок 1 - Результат решения задачи о шарнирно опёртой балке без ограничений на углы поворота в Ansys (сообщение об ошибке с указанием на нехватку ограничений по углу поворота вокруг оси балки)\n\n\nСтоит отметить, что похожий отрицательный результат был ранее получен господином Ш. Почему похожий? Потому что в его постановке дополнительно использовались «мягкие пружины», которых у нас нет. А вот почему они не сработали, мы рассмотрим попозже. А сейчас не будем спорить с машиной, добавим требуемое ограничение на угол поворота \\(\\theta_x\\) вокруг оси балки и получим результат, представленный на рисунке 2: задачка посчиталась, максимальный прогиб в центре балки составил \\(0,45961~{\\text{мм}}\\).\n\n\n\nРисунок 2 - Результат решения задачи о шарнирно опёртой балке с ограничениями на углы поворота вокруг её оси в Ansys (никаких сообщений об ошибках, максимальный прогиб в центре 0,45961 мм)\n\n\n\n\n1.2 Simcenter Nastran\nРезультат решения задачи в исходной постановке представлены на рисунке 3. Тут мы опять видим сообщение о нехватке граничных условий, превращающее нашу балку в механизм. А так как никакие дополнительные параметры решателя типа BAILOUT мы не трогали – результат получился, на мой взгляд, вполне закономерным. Добавим требуемое ограничение на угол поворота \\(\\theta_x\\) вокруг оси балки и получим результат, представленный на рисунке 4: задачка посчиталась, максимальный прогиб в центре балки составил \\(0,4586~{\\text{мм}}\\), весьма похоже на решение, полученное в ANSYS.\n\n\n\nРисунок 3 - Результат решения задачи о шарнирно опёртой балке без ограничений на углы поворота в Simcenter Nastran (сообщение об ошибке указывает на недостаточное количество ограничений)\n\n\n\n\n\nРисунок 4 - Результат решения задачи о шарнирно опёртой балке с ограничениями на углы поворота вокруг её оси в Simcenter Nastran (никаких сообщений об ошибках, максимальный прогиб в центре 0,4586 мм)\n\n\n\n\n1.3 COMSOL\nРезультат решения задачи в исходной постановке представлен на рисунке 5. Этот программный комплекс «съел» кинематические граничные условия в виде одних лишь перемещений и спокойно выдал результат – \\(0,45837~{\\text{мм}}\\), что весьма близко к двум предыдущим решениям, требовавшим дополнительное ограничение на угол поворота. Если добавить это ограничение в COMSOL, то результат останется без изменений, поэтому отдельно его приводить не будем.\n\n\n\nРисунок 5 - Результат решения задачи о шарнирно опёртой балке без ограничений на углы поворота в COMSOL (никаких сообщений об ошибках, максимальный прогиб в центре – 0,45837 мм)\n\n\n\n\n1.4 ABAQUS\nРезультат решения задачи в исходной постановке представлен на рисунке 6. ABAQUS так же как и COMSOL съел кинематические граничные условия в виде одних лишь перемещений, однако максимальный прогиб в центре балки составил \\(0,4277~{\\text{мм}}\\), что сильно меньше решений, полученных ранее. При добавлении ограничения на угол поворота вокруг оси балки результат остался без изменений, поэтому отдельно приводить его тоже не будем.\n\n\n\nРисунок 6 - Результат решения задачи о шарнирно опёртой балке без ограничений на углы поворота в Abaqus\n\n\n\n\n1.5 OptiStruct (Altair Hyperworks)\nРезультат решения задачи в исходной постановке представлен на рисунке 7. Здесь мы опять получили результат с «неполным» набором кинематических граничных условий – максимальный прогиб в центре равен \\(0,4586~{\\text{мм}}\\).\n\n\n\nРисунок 7 - Результат решения задачи о шарнирно опёртой балке без ограничений на углы поворота в Altair Hyperworks (OptiStruct)\n\n\n\n\n1.6 ЛОГОС\nНу да, Логос, а почему бы и нет. Результат решения задачи в исходной постановке представлен на рисунке 8. Не будем описывать проблемы, возникшие при запуске даже такой незамысловатой задачи, перейдём сразу к числам – максимальный прогиб в центре балки с формально неполным набором кинематических граничных условий получился \\(0,458366~{\\text{мм}}\\).\n\n\n\nРисунок 8 - решения задачи о шарнирно опёртой балке без ограничений на углы поворота в ЛОГОС"
  },
  {
    "objectID": "balka.html#немножко-теории",
    "href": "balka.html#немножко-теории",
    "title": "Разбор задачи о шарнирно опёртой балке с «неполным» набором граничных условий",
    "section": "2. Немножко теории",
    "text": "2. Немножко теории\n\n2.1 А что там внутри?\n\nПопробуем покопаться в логах и документации и понять, почему был получен тот или иной результат (если это будет возможно, разумеется). В качестве отправной точки залезем в логи решения задачи в ANSYS, который потребовал ограничений на углы поворота, и увидим, что в нашем случае использовались конечные элементы типа BEAM188. Документация говорит нам, что эти элементы основаны на теории Тимошенко, с линейными функциями формы.\nА теперь залезем в документацию COMSOL, который обошёлся ограничениями только на перемещения, и увидим, что в нашем случае использовались конечные элементы, основанный на теории Эйлера-Бернулли (есть опция выбора, но по умолчанию стоит Эйлер), с функциями формы, описываемыми кубическими полиномами.\nВзглянем на то, как должны выглядеть матрицы жёсткости этих элементов (без их вывода, пушто мне лениво расписывать). В случае балки Эйлера матрица жёсткости примет следующий вид:\n\n\\[\nK =\\begin{bmatrix}\n  \\frac{E \\cdot A}{L} & 0 & 0 & 0 & 0 & 0 & -\\frac{E \\cdot A}{L} & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & \\frac{12 \\cdot E \\cdot I_y}{L^3} & 0 & 0 & 0 & \\frac{6 \\cdot E \\cdot I_y}{L^2} & 0 & -\\frac{12 \\cdot E \\cdot I_y}{L^3} & 0 & 0 & 0 & \\frac{6 \\cdot E \\cdot I_y}{L^2} \\\\\n  0 & 0 & \\frac{12 \\cdot E \\cdot I_z}{L^3} & 0 & -\\frac{6 \\cdot E \\cdot I_z}{L^2} & 0 & 0 & 0 & -\\frac{12 \\cdot E \\cdot I_z}{L^3} & 0 & -\\frac{6 \\cdot E \\cdot I_z}{L^2} & 0 \\\\\n  0 & 0 & 0 & \\frac{G \\cdot J}{L} & 0 & 0 & 0 & 0 & 0 & -\\frac{G \\cdot J}{L} & 0 & 0 \\\\\n  0 & 0 & -\\frac{6 \\cdot E \\cdot I_z}{L^2} & 0 & \\frac{4 \\cdot E \\cdot I_z}{L} & 0 & 0 & 0 & \\frac{6 \\cdot E \\cdot I_z}{L^2} & 0 & \\frac{2 \\cdot E \\cdot I_z}{L} & 0 \\\\\n  0 & \\frac{6 \\cdot E \\cdot I_y}{L^2} & 0 & 0 & 0 & \\frac{4 \\cdot E \\cdot I_y}{L} & 0 & -\\frac{6 \\cdot E \\cdot I_y}{L^2} & 0 & 0 & 0 & \\frac{2 \\cdot E \\cdot I_y}{L} \\\\\n  -\\frac{E \\cdot A}{L} & 0 & 0 & 0 & 0 & 0 & \\frac{E \\cdot A}{L} & 0 & 0 & 0 & 0 & 0 \\\\\n  0 & -\\frac{12 \\cdot E \\cdot I_y}{L^3} & 0 & 0 & 0 & -\\frac{6 \\cdot E \\cdot I_y}{L^2} & 0 & \\frac{12 \\cdot E \\cdot I_y}{L^3} & 0 & 0 & 0 & -\\frac{6 \\cdot E \\cdot I_y}{L^2} \\\\\n  0 & 0 & -\\frac{12 \\cdot E \\cdot I_z}{L^3} & 0 & \\frac{6 \\cdot E \\cdot I_z}{L^2} & 0 & 0 & 0 & \\frac{12 \\cdot E \\cdot I_z}{L^3} & 0 & \\frac{6 \\cdot E \\cdot I_z}{L^2} & 0 \\\\\n  0 & 0 & 0 & -\\frac{G \\cdot J}{L} & 0 & 0 & 0 & 0 & 0 & \\frac{G \\cdot J}{L} & 0 & 0 \\\\\n  0 & 0 & -\\frac{6 \\cdot E \\cdot I_z}{L^2} & 0 & \\frac{2 \\cdot E \\cdot I_z}{L} & 0 & 0 & 0 & \\frac{6 \\cdot E \\cdot I_z}{L^2} & 0 & \\frac{4 \\cdot E \\cdot I_z}{L} & 0 \\\\\n  0 & \\frac{6 \\cdot E \\cdot I_y}{L^2} & 0 & 0 & 0 & \\frac{2 \\cdot E \\cdot I_y}{L} & 0 & -\\frac{6 \\cdot E \\cdot I_y}{L^2} & 0 & 0 & 0 & \\frac{4 \\cdot E \\cdot I_y}{L}\n\\end{bmatrix}\n\\]\n\nгде \\(Е\\) – модуль упругости, \\(I_y\\) и \\(I_z\\) – моменты инерции поперечного сечения балочного элемента, \\(L\\) – длина балочного элемента, \\(G\\) – модуль сдвига, связанный с модулем упругости соотношением \\(G = \\frac{E}{2 \\cdot (1 + \\mu)}\\), \\(A\\) - площадь поперечного сечения балочного элемента, \\(J\\) – момент инерции при кручении.\nВ случае балки Тимошенко матрица жёсткости примет следующий вид:\n\n\\[\nK=\\begin{bmatrix}\n\\frac{E \\cdot A}{L} & 0 & 0 & 0 & 0 & 0 & -\\frac{E \\cdot A}{L} & 0 & 0 & 0 & 0 & 0 \\\\\n0 & \\frac{12 \\cdot E \\cdot I_z}{L^3 \\cdot (1 + \\Phi_z)} & 0 & 0 & 0 & \\frac{6 \\cdot E \\cdot I_z}{L^2 \\cdot (1 + \\Phi_z)} & 0 & -\\frac{12 \\cdot E \\cdot I_z}{L^3 \\cdot (1 + \\Phi_z)} & 0 & 0 & 0 & \\frac{6 \\cdot E \\cdot I_z}{L^2 \\cdot (1 + \\Phi_z)} \\\\\n0 & 0 & \\frac{12 \\cdot E \\cdot I_y}{L^3 \\cdot (1 + \\Phi_y)} & 0 & -\\frac{6 \\cdot E \\cdot I_y}{L^2 \\cdot (1 + \\Phi_y)} & 0 & 0 & 0 & -\\frac{12 \\cdot E \\cdot I_y}{L^3 \\cdot (1 + \\Phi_y)} & 0 & -\\frac{6 \\cdot E \\cdot I_y}{L^2 \\cdot (1 + \\Phi_y)} & 0 \\\\\n0 & 0 & 0 & \\frac{G \\cdot J}{L} & 0 & 0 & 0 & 0 & 0 & -\\frac{G \\cdot J}{L} & 0 & 0 \\\\\n0 & 0 & -\\frac{6 \\cdot E \\cdot I_y}{L^2 \\cdot (1 + \\Phi_y)} & 0 & \\frac{(4 + \\Phi_y) \\cdot E \\cdot I_y}{L \\cdot (1 + \\Phi_y)} & 0 & 0 & 0 & \\frac{6 \\cdot E \\cdot I_y}{L^2 \\cdot (1 + \\Phi_y)} & 0 & \\frac{(2 - \\Phi_y) \\cdot E \\cdot I_y}{L \\cdot (1 + \\Phi_y)} & 0 \\\\\n0 & \\frac{6 \\cdot E \\cdot I_z}{L^2 \\cdot (1 + \\Phi_z)} & 0 & 0 & 0 & \\frac{(4 + \\Phi_z) \\cdot E \\cdot I_z}{L \\cdot (1 + \\Phi_z)} & 0 & -\\frac{6 \\cdot E \\cdot I_z}{L^2 \\cdot (1 + \\Phi_z)} & 0 & 0 & 0 & \\frac{(2 - \\Phi_z) \\cdot E \\cdot I_z}{L \\cdot (1 + \\Phi_z)} \\\\\n-\\frac{E \\cdot A}{L} & 0 & 0 & 0 & 0 & 0 & \\frac{E \\cdot A}{L} & 0 & 0 & 0 & 0 & 0 \\\\\n0 & -\\frac{12 \\cdot E \\cdot I_z}{L^3 \\cdot (1 + \\Phi_z)} & 0 & 0 & 0 & -\\frac{6 \\cdot E \\cdot I_z}{L^2 \\cdot (1 + \\Phi_z)} & 0 & \\frac{12 \\cdot E \\cdot I_z}{L^3 \\cdot (1 + \\Phi_z)} & 0 & 0 & 0 & -\\frac{6 \\cdot E \\cdot I_z}{L^2 \\cdot (1 + \\Phi_z)} \\\\\n0 & 0 & -\\frac{12 \\cdot E \\cdot I_y}{L^3 \\cdot (1 + \\Phi_y)} & 0 & \\frac{6 \\cdot E \\cdot I_y}{L^2 \\cdot (1 + \\Phi_y)} & 0 & 0 & 0 & \\frac{12 \\cdot E \\cdot I_y}{L^3 \\cdot (1 + \\Phi_y)} & 0 & \\frac{6 \\cdot E \\cdot I_y}{L^2 \\cdot (1 + \\Phi_y)} & 0 \\\\\n0 & 0 & 0 & -\\frac{G \\cdot J}{L} & 0 & 0 & 0 & 0 & 0 & \\frac{G \\cdot J}{L} & 0 & 0 \\\\\n0 & 0 & -\\frac{6 \\cdot E \\cdot I_y}{L^2 \\cdot (1 + \\Phi_y)} & 0 & \\frac{(2 - \\Phi_y) \\cdot E \\cdot I_y}{L \\cdot (1 + \\Phi_y)} & 0 & 0 & 0 & \\frac{6 \\cdot E \\cdot I_y}{L^2 \\cdot (1 + \\Phi_y)} & 0 & \\frac{(4 + \\Phi_y) \\cdot E \\cdot I_y}{L \\cdot (1 + \\Phi_y)} & 0 \\\\\n0 & \\frac{6 \\cdot E \\cdot I_z}{L^2 \\cdot (1 + \\Phi_z)} & 0 & 0 & 0 & \\frac{(2 - \\Phi_z) \\cdot E \\cdot I_z}{L \\cdot (1 + \\Phi_z)} & 0 & -\\frac{6 \\cdot E \\cdot I_z}{L^2 \\cdot (1 + \\Phi_z)} & 0 & 0 & 0 & \\frac{(4 + \\Phi_z) \\cdot E \\cdot I_z}{L \\cdot (1 + \\Phi_z)}\n\\end{bmatrix}\n\\]\n\nгде \\(\\Phi_z = \\frac{12 \\cdot E \\cdot I_z}{G \\cdot A \\cdot k \\cdot L^2}\\label{eq:phi_z}\\), \\(\\Phi_y = \\frac{12 \\cdot E \\cdot I_y}{G \\cdot A \\cdot k \\cdot L^2}\\label{eq:phi_y}\\), а \\(k\\) - коэффициент, зависящий от формы поперечного сечения.\nКак несложно заметить, структура обеих матриц одинакова и, с точки зрения процедуры дальнейшего решения системы линейных алгебраических уравнений, их можно считать идентичными. Перепишем в общем виде матрицу жёсткости одного конечного элемента:\n\n\\[\n\\mathbf{K} =\n\\begin{bmatrix}\nK_{1,1} & 0        & 0        & 0        & 0        & 0        & K_{1,7} & 0        & 0        & 0         & 0         & 0 \\\\\n0       & K_{2,2}  & 0        & 0        & 0        & K_{2,6}  & 0       & K_{2,8}  & 0        & 0         & 0         & K_{2,12} \\\\\n0       & 0        & K_{3,3}  & 0        & K_{3,5}  & 0        & 0       & 0        & K_{3,9}  & 0         & K_{3,11}  & 0 \\\\\n0       & 0        & 0        & K_{4,4}  & 0        & 0        & 0       & 0        & 0        & K_{4,10}  & 0         & 0 \\\\\n0       & 0        & K_{5,3}  & 0        & K_{5,5}  & 0        & 0       & 0        & K_{5,9}  & 0         & K_{5,11}  & 0 \\\\\n0       & K_{6,2}  & 0        & 0        & 0        & K_{6,6}  & 0       & K_{6,8}  & 0        & 0         & 0         & K_{6,12} \\\\\nK_{7,1} & 0        & 0        & 0        & 0        & 0        & K_{7,7} & 0        & 0        & 0         & 0         & 0 \\\\\n0       & K_{8,2}  & 0        & 0        & 0        & K_{8,6}  & 0       & K_{8,8}  & 0        & 0         & 0         & K_{8,12} \\\\\n0       & 0        & K_{9,3}  & 0        & K_{9,5}  & 0        & 0       & 0        & K_{9,9}  & 0         & K_{9,11}  & 0 \\\\\n0       & 0        & 0        & K_{10,4} & 0        & 0        & 0       & 0        & 0        & K_{10,10} & 0         & 0 \\\\\n0       & 0        & K_{11,3} & 0        & K_{11,5} & 0        & 0       & 0        & K_{11,9} & 0         & K_{11,11} & 0 \\\\\n0       & K_{12,2} & 0        & 0        & 0        & K_{12,6} & 0       & K_{12,8} & 0        & 0         & 0         & K_{12,12}\n\\end{bmatrix}\n\\label{eq:stiffness_matrix}\n\\]\n\nА теперь соберём полную матрицу жёсткости и запишем разрешающее уравнение \\(K \\cdot u = P\\) для нашей модели:\n\n\\[\n\\begin{bmatrix}\nK1_{1,1} & 0         & 0         & 0         & 0         & 0         & K_{1,7}           & 0                  & 0                  & 0                   & 0                   & 0                   & 0        & 0         & 0 & 0 & 0 & 0 \\\\\n0        & K1_{2,2}  & 0         & 0         & 0         & K1_{2,6}  & 0                 & K1_{2,8}           & 0                  & 0                   & 0                   & K1_{2,12}           & 0        & 0         & 0 & 0 & 0 & 0 \\\\\n0        & 0         & K1_{3,3}  & 0         & K1_{3,5}  & 0         & 0                 & 0                  & K1_{3,9}           & 0                   & K1_{3,11}           & 0                   & 0        & 0         & 0 & 0 & 0 & 0 \\\\\n0        & 0         & 0         & K1_{4,4}  & 0         & 0         & 0                 & 0                  & 0                  & K1_{4,10}           & 0                   & 0                   & 0        & 0         & 0 & 0 & 0 & 0 \\\\\n0        & 0         & K1_{5,3}  & 0         & K1_{5,5}  & 0         & 0                 & 0                  & K1_{5,9}           & 0                   & K1_{5,11}           & 0                   & 0        & 0         & 0 & 0 & 0 & 0 \\\\\n0        & K1_{6,2}  & 0         & 0         & 0         & K1_{6,6}  & 0                 & K1_{6,8}           & 0                  & 0                   & 0                   & K1_{6,12}           & 0        & 0         & 0 & 0 & 0 & 0 \\\\\nK1_{7,1} & 0         & 0         & 0         & 0         & 0         & K1_{7,7}+K2_{1,1} & 0                  & 0                  & 0                   & 0                   & 0                   & K2_{1,7} & 0         & 0 & 0 & 0 & 0 \\\\\n0        & K1_{8,2}  & 0         & 0         & 0         & K1_{8,6}  & 0                 & K1_{8,8}+K_{2,2}   & 0                  & 0                   & 0                   & K1_{8,12}+K2_{2,6}  & 0        & K2_{2,8}  & 0         & 0          & 0          & K2_{2,12} \\\\\n0        & 0         & K1_{9,3}  & 0         & K1_{9,5}  & 0         & 0                 & 0                  & K1_{9,9}+K2_{3,3}  & 0                   & K1_{9,11}+K2_{3,5}  & 0                   & 0        & 0         & K2_{3,9}  & 0          & K2_{3,11}  & 0 \\\\\n0        & 0         & 0         & K1_{10,4} & 0         & 0         & 0                 & 0                  & 0                  & K1_{10,10}+K2_{4,4} & 0                   & 0                   & 0        & 0         & 0         & K2_{4,10}  & 0          & 0 \\\\\n0        & 0         & K1_{11,3} & 0         & K1_{11,5} & 0         & 0                 & 0                  & K1_{11,9}+K2_{5,3} & 0                   & K1_{11,11}+K2_{5,5} & 0                   & 0        & 0         & K2_{5,9}  & 0          & K2_{5,11}  & 0 \\\\\n0        & K1_{12,2} & 0         & 0         & 0         & K1_{12,6} & 0                 & K1_{12,8}+K2_{6,2} & 0                  & 0                   & 0                   & K1_{12,12}+K2_{6,6} & 0        & K2_{6,8}  & 0         & 0          & 0          & K2_{6,12} \\\\\n0        & 0         & 0         & 0         & 0         & 0         & K2_{7,1}          & 0                  & 0                  & 0                   & 0                   & 0                   & K2_{7,7} & 0         & 0         & 0          & 0          & 0 \\\\\n0        & 0         & 0         & 0         & 0         & 0         & 0                 & K2_{8,2}           & 0                  & 0                   & 0                   & K2_{8,6}            & 0        & K2_{8,8}  & 0         & 0          & 0          & K2_{8,12} \\\\\n0        & 0         & 0         & 0         & 0         & 0         & 0                 & 0                  & K2_{9,3}           & 0                   & K2_{9,5}            & 0                   & 0        & 0         & K2_{9,9}  & 0          & K2_{9,11}  & 0 \\\\\n0        & 0         & 0         & 0         & 0         & 0         & 0                 & 0                  & 0                  & K2_{10,4}           & 0                   & 0                   & 0        & 0         & 0         & K2_{10,10} & 0          & 0 \\\\\n0        & 0         & 0         & 0         & 0         & 0         & 0                 & 0                  & K2_{11,3}          & 0                   & K2_{11,5}           & 0                   & 0        & 0         & K2_{11,9} & 0          & K2_{11,11} & 0 \\\\\n0        & 0         & 0         & 0         & 0         & 0         & 0                 & K2_{12,2}          & 0                  & 0                   & 0                   & K2_{12,6}           & 0        & K2_{12,8} & 0         & 0          & 0          & K2_{12,12}\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\nu_1 \\\\ v_1 \\\\ w_1 \\\\ \\theta_{x1} \\\\ \\theta_{y1} \\\\ \\theta_{z1} \\\\\nu_2 \\\\ v_2 \\\\ w_2 \\\\ \\theta_{x2} \\\\ \\theta_{y2} \\\\ \\theta_{z2} \\\\\nu_3 \\\\ v_3 \\\\ w_3 \\\\ \\theta_{x3} \\\\ \\theta_{y3} \\\\ \\theta_{z3}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\\n0 \\\\ -1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\\n0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0\n\\end{bmatrix}\n\\]\n\nПрименим к получившейся «модели» граничные условия исходной задачи, т.е. ограничим только перемещения в первом и третьем узле, простым вычёркиванием соответствующих строк и столбцов:\n\nПолучаем в «остатке»:\n\n\\[\n\\begin{bmatrix}\nK1_{4,4}  & 0         & 0         & 0                 & 0                  & 0                  & K1_{4,10}           & 0                   & 0                   & 0          & 0          & 0 \\\\\n0         & K1_{5,5}  & 0         & 0                 & 0                  & K1_{5,9}           & 0                   & K1_{5,11}           & 0                   & 0          & 0          & 0 \\\\\n0         & 0         & K1_{6,6}  & 0                 & K1_{6,8}           & 0                  & 0                   & 0                   & K1_{6,12}           & 0          & 0          & 0 \\\\\n0         & 0         & 0         & K1_{7,7}+K2_{1,1} & 0                  & 0                  & 0                   & 0                   & 0                   & 0          & 0          & 0 \\\\\n0         & 0         & K1_{8,6}  & 0                 & K1_{8,8}+K_{2,2}   & 0                  & 0                   & 0                   & K1_{8,12}+K2_{2,6}  & 0          & 0          & K2_{2,12} \\\\\n0         & K1_{9,5}  & 0         & 0                 & 0                  & K1_{9,9}+K2_{3,3}  & 0                   & K1_{9,11}+K2_{3,5}  & 0                   & 0          & K2_{3,11}  & 0 \\\\\nK1_{10,4} & 0         & 0         & 0                 & 0                  & 0                  & K1_{10,10}+K2_{4,4} & 0                   & 0                   & K2_{4,10}  & 0          & 0 \\\\\n0         & K1_{11,5} & 0         & 0                 & 0                  & K1_{11,9}+K2_{5,3} & 0                   & K1_{11,11}+K2_{5,5} & 0                   & 0          & K2_{5,11}  & 0 \\\\\n0         & 0         & K1_{12,6} & 0                 & K1_{12,8}+K2_{6,2} & 0                  & 0                   & 0                   & K1_{12,12}+K2_{6,6} & 0          & 0          & K2_{6,12} \\\\\n0         & 0         & 0         & 0                 & 0                  & 0                  & K2_{10,4}           & 0                   & 0                   & K2_{10,10} & 0          & 0 \\\\\n0         & 0         & 0         & 0                 & 0                  & K2_{11,3}          & 0                   & K2_{11,5}           & 0                   & 0          & K2_{11,11} & 0 \\\\\n0         & 0         & 0         & 0                 & K2_{12,2}          & 0                  & 0                   & 0                   & K2_{12,6}           & 0          & 0          & K2_{12,12}\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n\\theta_{x1} \\\\ \\theta_{y1} \\\\ \\theta_{z1} \\\\\nu_2 \\\\ v_2 \\\\ w_2 \\\\ \\theta_{x2} \\\\ \\theta_{y2} \\\\ \\theta_{z2} \\\\\n\\theta_{x3} \\\\ \\theta_{y3} \\\\ \\theta_{z3}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 \\\\ 0 \\\\ 0 \\\\\n0 \\\\ -1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\\n0 \\\\ 0 \\\\ 0\n\\end{bmatrix}\n\\]\n\nНесложно убедиться, что определитель оставшейся части исходной матрицы равен нулю, и, соответственно, эта часть матрицы, необходимая для решения уравнения вида \\(X = K^{-1} \\cdot P\\), не очень хочет обращаться, что приводит к невозможности получения результата. Именно такую картину можно было наблюдать при попытке решить исходную задачу (без ограничений на углы поворота) в ANSYS и NASTRAN. Теперь добавим недостающее граничное условие на угол поворота вокруг оси балки, ещё немного вычёркивая строчки и столбцы:\n\nПолучаем в «остатке»:\n\n\\[\n\\begin{bmatrix}\nK1_{5,5}  & 0         & 0                 & 0                  & K1_{5,9}           & 0                   & K1_{5,11}           & 0                   & 0          & 0 \\\\\n0         & K1_{6,6}  & 0                 & K1_{6,8}           & 0                  & 0                   & 0                   & K1_{6,12}           & 0          & 0 \\\\\n0         & 0         & K1_{7,7}+K2_{1,1} & 0                  & 0                  & 0                   & 0                   & 0                   & 0          & 0 \\\\\n0         & K1_{8,6}  & 0                 & K1_{8,8}+K_{2,2}   & 0                  & 0                   & 0                   & K1_{8,12}+K2_{2,6}  & 0          & K2_{2,12} \\\\\nK1_{9,5}  & 0         & 0                 & 0                  & K1_{9,9}+K2_{3,3}  & 0                   & K1_{9,11}+K2_{3,5}  & 0                   & K2_{3,11}  & 0 \\\\\n0         & 0         & 0                 & 0                  & 0                  & K1_{10,10}+K2_{4,4} & 0                   & 0                   & 0          & 0 \\\\\nK1_{11,5} & 0         & 0                 & 0                  & K1_{11,9}+K2_{5,3} & 0                   & K1_{11,11}+K2_{5,5} & 0                   & K2_{5,11}  & 0 \\\\\n0         & K1_{12,6} & 0                 & K1_{12,8}+K2_{6,2} & 0                  & 0                   & 0                   & K1_{12,12}+K2_{6,6} & 0          & K2_{6,12} \\\\\n0         & 0         & 0                 & 0                  & K2_{11,3}          & 0                   & K2_{11,5}           & 0                   & K2_{11,11} & 0 \\\\\n0         & 0         & 0                 & K2_{12,2}          & 0                  & 0                   & 0                   & K2_{12,6}           & 0          & K2_{12,12}\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n\\theta_{y1} \\\\ \\theta_{z1} \\\\\nu_2 \\\\ v_2 \\\\ w_2 \\\\ \\theta_{x2} \\\\ \\theta_{y2} \\\\ \\theta_{z2} \\\\\n\\theta_{y3} \\\\ \\theta_{z3}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 \\\\ 0 \\\\\n0 \\\\ -1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\\n0 \\\\ 0\n\\end{bmatrix}\n\\]\n\nВ этом случае определитель оставшейся части исходной матрицы представляет собой положительное число, сам кусочек обращается на изи и можно получить конечное решение. Теперь, когда теоретический базис сформирован, можно приступить к подстановке чисел и получению решений. Реализуем несложный код (базовый, дальше будем его дополнять различными функциями) для случая с ограничением только на перемещения:\nimport numpy as np\nfrom numpy.typing import NDArray    ## Тип для массивов NumPy\nfrom typing import Tuple, List      ## Типы для подсказок, что возвращают функции\n\nclass BeamStructure:\n    def __init__(self) -&gt; None:\n        \"\"\" Исходные данные к задаче о шарнирно опёртой балке\"\"\"\n        self.L: float = 600.0           ## Длина, мм\n        self.L_e: float = self.L / 2    ## Длина элемента, мм\n        self.E: float = 20000.0         ## Модуль упругости, кгс/мм^2\n        self.G: float = 7692.31         ## Модуль сдвига, кгс/мм^2\n        self.A: float = 78.54           ## Площадь поперечного сечения, мм^2\n        self.Iz: float = 490.874        ## Момент инерции относительно оси z, мм^4\n        self.Iy: float = 490.874        ## Момент инерции относительно оси y, мм^4\n        self.J: float = 2 * self.Iz     ## Полярный момент инерции, мм^4\n        self.k: float = 10/9            ## Коэффициент формы\n        self.F: float = 1.0             ## Сила, кгс\n\n    def calculate_phi(self) -&gt; float:\n        \"\"\" Расчёт коэффициента Phi с учётом сдвиговой деформации\"\"\"\n        phi = 12 * self.E * self.Iz / (self.G * self.A * self.k * self.L_e ** 2)\n        return phi\n\n    def calculate_stiffness_coefficients(self, phi: float) -&gt; Tuple[float, ...]:\n        \"\"\" Расчёт коэффициентов жёсткости \"\"\"\n        k_ea = self.E * self.A / self.L_e\n        k_gj = self.G * self.J / self.L_e\n        k11 = 12 * self.E * self.Iz / (self.L_e**3 * (1 + phi))\n        k12 = 6 * self.E * self.Iz / (self.L_e**2 * (1+phi))\n        k22 = (4 + phi) * self.E * self.Iz / (self.L_e * (1 + phi))\n        k24 = (2 - phi) * self.E * self.Iz / (self.L_e * (1 + phi))\n        return k_ea, k_gj, k11, k12, k22, k24\n\n    def build_local_stiffness_matrix(self, k_ea: float, k_gj: float, k11: float,\n                                     k12: float, k22: float, k24: float) -&gt; NDArray:\n        \"\"\" Построение локальной матрицы жёсткости 12х12 \"\"\"\n        ## Создание пустой матрицы 12х12 (12 степеней свободы, 6 на каждом конце)\n        ke = np.zeros((12,12))\n        ## Заполнение ненулевых элементов\n        ## Растяжение вдоль оси балки (вдоль оси х)\n        ke[0, 0] = k_ea;  ke[0, 6] = -k_ea;  ke[6, 0] = -k_ea;  ke[6, 6] = k_ea\n        ## Изгиб в плоскости y (перемещения и повороты)\n        ke[1, 1] = k11;   ke[1, 5] = k12;   ke[1, 7] = -k11;  ke[1, 11] = k12\n        ke[5, 1] = k12;   ke[5, 5] = k22;   ke[5, 7] = -k12;  ke[5, 11] = k24\n        ke[7, 1] = -k11;  ke[7, 5] = -k12;  ke[7, 7] = k11;   ke[7, 11] = -k12\n        ke[11, 1] = k12;  ke[11, 5] = k24;  ke[11, 7] = -k12; ke[11, 11] = k22\n        ## Изгиб в плоскости z (перемещения и повороты)\n        ke[2, 2] = k11;   ke[2, 4] = -k12;  ke[2, 8] = -k11;  ke[2, 10] = -k12\n        ke[4, 2] = -k12;  ke[4, 4] = k22;   ke[4, 8] = k12;   ke[4, 10] = k24\n        ke[8, 2] = -k11;  ke[8, 4] = k12;   ke[8, 8] = k11;   ke[8, 10] = k12\n        ke[10, 2] = -k12; ke[10, 4] = k24;  ke[10, 8] = k12;  ke[10, 10] = k22\n        ## Кручение балки вокруг оси х\n        ke[3, 3] = k_gj;  ke[3, 9] = -k_gj; ke[9, 3] = -k_gj; ke[9, 9] = k_gj\n        return ke\n\n    def assemble_global_matrix(self, ke: NDArray) -&gt; NDArray:\n        \"\"\" Сборка глобальной матрицы жёсткости 18х18 \"\"\"\n        ## Создание пустой матрицы 18х18 (18 степеней свободы, 6 в каждом узле)\n        k_global = np.zeros((18, 18))\n        ## Добавление первого элемента (первые 12 строк и столбцов)\n        k_global[0:12, 0:12] += ke\n        ## Добавление второго элемента (последние 12 строк и столбцов)\n        k_global[6:18, 6:18] += ke\n        return k_global\n\n    def apply_boundary_conditions(self) -&gt; Tuple[List[int], NDArray]:\n        \"\"\" Применение граничных условий и определение свободных dofs \"\"\"\n        ## Шарнирные опоры в 1 и 3 узлах\n        ## (0 - u1x, 1 - u1y, 2 - u1z, 3 - theta1x, 12 - u3x, 13 - u3y, 14 - u3z, 15 - theta3z)\n        #fixed_dofs = [0, 1, 2, 3, 12, 13, 14, 15]\n        fixed_dofs = [0, 1, 2, 12, 13, 14]\n        ## Свободные степени свободы (всё, что не закреплено)\n        free_dofs = [i for i in range(18) if i not in fixed_dofs]\n        ## Вектор нагрузок (18 нулей, сила только по индексу 7 - u2y)\n        f_full = np.zeros(18)\n        f_full[7] = self.F ## Приложенная сила F2y\n        return free_dofs, f_full\n\n    def solve_system(self, k_global: NDArray, free_dofs: List[int],\n                     f_full: NDArray) -&gt; Tuple[NDArray, float, NDArray, float]:\n        \"\"\" Решение системы уравнений для перемещенеий \"\"\"\n        ## Оставляем только \"свободные части\" матрицы жёсткости и вектора нагрузок\n        k_red = k_global[np.ix_(free_dofs, free_dofs)]\n        f_red = f_full[free_dofs]\n\n        ## Решаем систему: K * u = F, где u - вектор перемещений\n        ## Используем функцию из билиотеки NumPy\n        u_red_np = None\n        try:\n            u_red_np = np.linalg.solve(k_red, f_red)\n        except ValueError as e:\n            print(f\"np.linalg.solve: система вырожденная - {e}\")\n\n        return u_red_np\n\ndef main() -&gt; None:\n    \"\"\" Основная функция \"\"\"\n    beam = BeamStructure()\n\n    ## Вывод исходный данных\n    print(f\"E = {beam.E:.2e} кгс/мм^2, G = {beam.G:.2e} кгс/мм^2, \"\n          f\"A = {beam.A:.2e} мм^2, Iz = {beam.Iz:.2e} мм^4, \"\n          f\"J = {beam.J:.2e} мм^4, L_e = {beam.L_e:.2e} мм\")\n\n    ## Расчёт промежуточных величин\n    phi = beam.calculate_phi()\n    print(f\"Phi = {phi:.4f}\")\n\n    k_ea, k_gj, k11, k12, k22, k24 = beam.calculate_stiffness_coefficients(phi)\n    print(f\"k11 = {k11:.2e}, k12 = {k12:.2e}, k22 = {k22:.2e}, \"\n          f\"k24 = {k24:.2e}\")\n    print(f\"k_ea = {k_ea:.2e}, k_gj = {k_gj:.2e}\")\n\n    # Построение матриц\n    ke = beam.build_local_stiffness_matrix(k_ea, k_gj, k11, k12, k22, k24)\n    k_global = beam.assemble_global_matrix(ke)\n\n    # Вывод матрицы\n    np.set_printoptions(precision=3)\n    print(\"Полная матрица жесткости:\")\n    print(k_global)\n\n    # Граничные условия и решение\n    free_dofs, f_full = beam.apply_boundary_conditions()\n    print(f\"Свободные степени свободы: {free_dofs}\")\n    print(f\"Вектор сил: {f_full}\")\n\n    k_red = k_global[np.ix_(free_dofs, free_dofs)]\n    print(f\"Детерминант K_red = {np.linalg.det(k_red):.2e}\")\n\n    ## Решаем и выводим результат\n    u_red_np = beam.solve_system(k_global, free_dofs, f_full)\n    if u_red_np is not None:\n        print(f\"Перемещения (NumPy): {u_red_np}\")\n        print(f\"Прогиб в точке u_2y (NumPy): {u_red_np[free_dofs.index(7)]:.4f} мм\")\n    else:\n        print(f\"Перемещения (NumPy) не удалось вычислить из-за вырожденности\")\n\nif __name__ == \"__main__\":\n    main()\nРезультатом его выполнения будет следующее сообщение:\nE = 2.00e+04 кгс/мм^2, G = 7.69e+03 кгс/мм^2, A = 7.85e+01 мм^2, Iz = 4.91e+02 мм^4, J = 9.82e+02 мм^4, L_e = 3.00e+02 мм\nPhi = 0.0019\nk11 = 4.35e+00, k12 = 6.53e+02, k22 = 1.31e+05, k24 = 6.53e+04\nk_ea = 5.24e+03, k_gj = 2.52e+04\nПолная матрица жесткости:\n[[ 5.236e+03  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00\n  -5.236e+03  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00\n   0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00]\n [ 0.000e+00  4.355e+00  0.000e+00  0.000e+00  0.000e+00  6.532e+02\n   0.000e+00 -4.355e+00  0.000e+00  0.000e+00  0.000e+00  6.532e+02\n   0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00]\n [ 0.000e+00  0.000e+00  4.355e+00  0.000e+00 -6.532e+02  0.000e+00\n   0.000e+00  0.000e+00 -4.355e+00  0.000e+00 -6.532e+02  0.000e+00\n   0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00]\n [ 0.000e+00  0.000e+00  0.000e+00  2.517e+04  0.000e+00  0.000e+00\n   0.000e+00  0.000e+00  0.000e+00 -2.517e+04  0.000e+00  0.000e+00\n   0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00]\n [ 0.000e+00  0.000e+00 -6.532e+02  0.000e+00  1.307e+05  0.000e+00\n   0.000e+00  0.000e+00  6.532e+02  0.000e+00  6.526e+04  0.000e+00\n   0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00]\n [ 0.000e+00  6.532e+02  0.000e+00  0.000e+00  0.000e+00  1.307e+05\n   0.000e+00 -6.532e+02  0.000e+00  0.000e+00  0.000e+00  6.526e+04\n   0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00]\n [-5.236e+03  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00\n   1.047e+04  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00\n  -5.236e+03  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00]\n [ 0.000e+00 -4.355e+00  0.000e+00  0.000e+00  0.000e+00 -6.532e+02\n   0.000e+00  8.710e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00\n   0.000e+00 -4.355e+00  0.000e+00  0.000e+00  0.000e+00  6.532e+02]\n [ 0.000e+00  0.000e+00 -4.355e+00  0.000e+00  6.532e+02  0.000e+00\n   0.000e+00  0.000e+00  8.710e+00  0.000e+00  0.000e+00  0.000e+00\n   0.000e+00  0.000e+00 -4.355e+00  0.000e+00 -6.532e+02  0.000e+00]\n [ 0.000e+00  0.000e+00  0.000e+00 -2.517e+04  0.000e+00  0.000e+00\n   0.000e+00  0.000e+00  0.000e+00  5.035e+04  0.000e+00  0.000e+00\n   0.000e+00  0.000e+00  0.000e+00 -2.517e+04  0.000e+00  0.000e+00]\n [ 0.000e+00  0.000e+00 -6.532e+02  0.000e+00  6.526e+04  0.000e+00\n   0.000e+00  0.000e+00  0.000e+00  0.000e+00  2.614e+05  0.000e+00\n   0.000e+00  0.000e+00  6.532e+02  0.000e+00  6.526e+04  0.000e+00]\n [ 0.000e+00  6.532e+02  0.000e+00  0.000e+00  0.000e+00  6.526e+04\n   0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  2.614e+05\n   0.000e+00 -6.532e+02  0.000e+00  0.000e+00  0.000e+00  6.526e+04]\n [ 0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00\n  -5.236e+03  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00\n   5.236e+03  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00]\n [ 0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00\n   0.000e+00 -4.355e+00  0.000e+00  0.000e+00  0.000e+00 -6.532e+02\n   0.000e+00  4.355e+00  0.000e+00  0.000e+00  0.000e+00 -6.532e+02]\n [ 0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00\n   0.000e+00  0.000e+00 -4.355e+00  0.000e+00  6.532e+02  0.000e+00\n   0.000e+00  0.000e+00  4.355e+00  0.000e+00  6.532e+02  0.000e+00]\n [ 0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00\n   0.000e+00  0.000e+00  0.000e+00 -2.517e+04  0.000e+00  0.000e+00\n   0.000e+00  0.000e+00  0.000e+00  2.517e+04  0.000e+00  0.000e+00]\n [ 0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00\n   0.000e+00  0.000e+00 -6.532e+02  0.000e+00  6.526e+04  0.000e+00\n   0.000e+00  0.000e+00  6.532e+02  0.000e+00  1.307e+05  0.000e+00]\n [ 0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00\n   0.000e+00  6.532e+02  0.000e+00  0.000e+00  0.000e+00  6.526e+04\n   0.000e+00 -6.532e+02  0.000e+00  0.000e+00  0.000e+00  1.307e+05]]\nСвободные степени свободы: [3, 4, 5, 6, 7, 8, 9, 10, 11, 15, 16, 17]\nВектор сил: [0. 0. 0. 0. 0. 0. 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\nДетерминант K_red = 0.00e+00\nnp.linalg.solve: система вырожденная - Singular matrix\nПеремещения (NumPy) не удалось вычислить из-за вырожденности\nТеперь добавим ограничение на угол поворота θx вдоль оси балки (и заодно закомментируем вывод матрицы жёсткости, чтобы не мешалась)\n## Шарнирные опоры в 1 и 3 узлах\n## (0 - u1x, 1 - u1y, 2 - u1z, 3 - theta1x, 12 - u3x, 13 - u3y, 14 - u3z, 15 - theta3z)\nfixed_dofs = [0, 1, 2, 3, 12, 13, 14, 15]\n#fixed_dofs = [0, 1, 2, 12, 13, 14]\nРезультатом выполнения такого кода будет уже знакомая нам величина прогиба:\nE = 2.00e+04 кгс/мм^2, G = 7.69e+03 кгс/мм^2, A = 7.85e+01 мм^2, Iz = 4.91e+02 мм^4, J = 9.82e+02 мм^4, L_e = 3.00e+02 мм\nPhi = 0.0019\nk11 = 4.35e+00, k12 = 6.53e+02, k22 = 1.31e+05, k24 = 6.53e+04\nk_ea = 5.24e+03, k_gj = 2.52e+04\nСвободные степени свободы: [4, 5, 6, 7, 8, 9, 10, 11, 16, 17]\nВектор сил: [0. 0. 0. 0. 0. 0. 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\nДетерминант K_red = 2.82e+40\nПеремещения (NumPy): [ 0.00000000e+00  2.29183049e-03  0.00000000e+00  4.58589551e-01\n -0.00000000e+00  0.00000000e+00  0.00000000e+00  8.49677854e-20\n  0.00000000e+00 -2.29183049e-03]\nПрогиб в точке u_2y (NumPy): 0.4586 мм\nТут можно заметить, что решение нашей задачи с использованием функции np.linalg.solve из библиотеки NumPy является таким же «прозрачным», как и решение с помощью остального ПО. Попробуем разобраться, какие процедуры происходят при работе этой функции. Классическим методом решения системы \\(K \\cdot x = f\\) является метод Гаусса, при котором матрица \\(K\\) с помощью элементарных операций (перестановки строк, умножения и вычитания) превращается в верхнетреугольную (с нулями под диагональю). Чтобы в процессе избежать деления на маленькие числа можно выбрать самый большой по модулю элемент в столбце как ведущий (при этом ведущий элемент лежит на главной диагонали или ниже). Рассмотрим простой пример в виде совместимой системы (вектор \\(f\\) можно представить как линейную комбинацию столбцов \\(K\\)) с вырожденной (пушто третья строка является суммой первых двух) матрицей:\n\\[\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n5 & 7 & 9\n\\end{bmatrix}\n\\cdot\nx=\n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 3\n\\end{bmatrix}\n\\]\nМаксимальный элемент в первом столбце равен 5 и содержащая эту величину строка отправляется на первое место:\n\\[\n\\begin{bmatrix}\n5 & 7 & 9 \\\\\n4 & 5 & 6 \\\\\n1 & 2 & 3\n\\end{bmatrix}\n\\cdot\nx=\n\\begin{bmatrix}\n3 \\\\ 2 \\\\ 1\n\\end{bmatrix}\n\\]\nТеперь разделим первую строку на 5, чтобы элемент (1,1) стал равен единице:\n\\[\n\\begin{bmatrix}\n1 & 1,4 & 1,8 \\\\\n4 & 5 & 6 \\\\\n1 & 2 & 3\n\\end{bmatrix}\n\\cdot\nx=\n\\begin{bmatrix}\n0,6 \\\\ 2 \\\\ 1\n\\end{bmatrix}\n\\]\nПовычитаем из второй и третьей строк первую строку в нужно количестве таким образом, чтобы в столбце под единичкой получились нули (очевидно, что из второй строки нужно вычесть 4 первых, а из третьей строки – одну первую):\n\\[\n\\begin{bmatrix}\n1 & 1,4 & 1,8 \\\\\n0 & -0,6 & -1,2 \\\\\n0 & 0,6 & 1,2\n\\end{bmatrix}\n\\cdot\nx=\n\\begin{bmatrix}\n0,6 \\\\ -0,4 \\\\ 0,4\n\\end{bmatrix}\n\\]\nПереходим ко второму столбцу: максимальное значение по модулю равно 1,4, но оно уже находится сверху, поэтому придётся брать следующее значение, равное -0,6. Делим на него вторую строку, получаем:\n\\[\n\\begin{bmatrix}\n1 & 1,4 & 1,8 \\\\\n0 & 1 & 2 \\\\\n0 & 0,6 & 1,2\n\\end{bmatrix}\n\\cdot\nx=\n\\begin{bmatrix}\n0,6 \\\\ 0,667 \\\\ 0,4\n\\end{bmatrix}\n\\]\nА теперь из последней строки вычтем вторую строку в количестве 0,6 штук:\n\\[\n\\begin{bmatrix}\n1 & 1,4 & 1,8 \\\\\n0 & 1 & 2 \\\\\n0 & 0 & 0\n\\end{bmatrix}\n\\cdot\nx=\n\\begin{bmatrix}\n0,6 \\\\ 0,667 \\\\ 0\n\\end{bmatrix}\n\\]\nПереходя к последнему столбцу, замечаем, что ведущий элемент равен 0, делить на него строку мы не можем и радостно вываливаемся из решения. Отметим, что формально система имеет бесконечное количество решений, которые в общем виде можно записать как:\n\\[\nx=\n\\begin{bmatrix}\n-0,333+t \\\\ 0,667-2 \\cdot t \\\\ t\n\\end{bmatrix}\n\\]\nРеализуем рассмотренный подход в задаче о шарнирно опёртой балке. Соответствующая функция будет выглядеть следующим образом:\ndef my_solve(A: np.ndarray, b: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Решение системы уравнений А * х = b методом Гаусса с частичным выбором ведущего элемента\n    Args:\n         A(np.ndarray): Квадратная матрица (n x n)\n         b(np.ndarray): Вектор правой части (n)\n    Returns:\n        np.ndarray: Вектор решения х (n)\n    Raises:\n        ValueError: Если матрица не квадратная или вырожденная (детерминант ≈ 0)\n    \"\"\"\n\n    ## Размер системы - число уравнений (и переменных)\n    n = len(b)\n    ## Проверяем, что матрица квадратная и соответствует вектору b\n    if A.shape != (n, n):\n        raise ValueError(\"Матрица А должна быть квадратной и соответствовать b!\")\n    ## Копируем А и b, чтобы не менять оригиналы (работаем с копиями)\n    A = A.copy()\n    b = b.copy()\n    ## Прямой ход: превращаем А в верхнетреугольную матрицу (нули под диагональю)\n    for i in range(n):\n        ## Ищем ведущий элемент (pivot) - самый большой по модулю в столбце i...\n        max_idx = i ## ...начинаем с текущей строки...\n        for k in range(i+1, n):     ## ...и смотрим все строки ниже\n            if abs(A[k, i]) &gt; abs(A[max_idx, i]):\n                max_idx = k     ## Запоминаем строку с максимальным элементом\n        ## Проверяем, не слишком ли маленький pivot (если ≈ 0, матрица вырожденная)\n        pivot = A[max_idx, i]\n        if abs(pivot) &lt; 1e-10:      ## 1e-10 — порог для учёта ошибок округления\n            raise ValueError(f\"Матрица вырожденна на шаге {i}!\")\n        ## Если нашли больший элемент ниже, меняем строки местами\n        if max_idx != i:\n            A[[i, max_idx]] = A[[max_idx, i]]       ## Меняем строки в матрице A\n            b[i], b[max_idx] = b[max_idx], b[i]     ## Меняем элементы в векторе b\n        ## Делаем ведущий элемент равным 1: делим строку i на pivot\n        A[i, :] = A[i, :] / pivot\n        b[i] = b[i] / pivot\n        ## Убираем элементы под ведущим элементом (делаем нули в столбце i)\n        for j in range(i + 1, n):                   ## Проходим по строкам ниже текущей\n            factor = A[j, i]                        ## Коэффициент, на который умножаем строку i\n            A[j, :] = A[j, :] - factor * A[i, :]    ## Вычитаем, чтобы обнулить A[j, i]\n            b[j] = b[j] - factor * b[i]             ## То же для правой части\n    ## Обратный ход: решаем систему снизу вверх, начиная с последнего уравнения\n    x = np.zeros(n)                         ## Создаём вектор для хранения решения\n    for i in range(n-1, -1, -1):            ## Идём от последней строки к первой\n        x[i] = b[i]                         ## Берём правую часть текущего уравнения\n        # Вычитаем все уже найденные переменные (x[j] для j &gt; i)\n        for j in range(i+1, n):\n            x[i] = x[i] - A[i, j] * x[j]    ## Учитываем влияние верхних элементов\n    return x\nРезультат решения задачи с помощью этой функции будет аналогичен предыдущему – максимальный прогиб \\(0,4586~{\\text{мм}}\\) при полном наборе кинематических граничных условий (с учётом угла поворота \\(\\theta_x\\)) и сообщение об ошибке при неполном наборе граничных условий.\nПокопавшись в доксах, можно предположить, что встроенная в NumPy функция реализует PLU-разложение, при котором матрица \\(K\\) «разбивается» на три части так, что \\(P \\cdot K = L \\cdot U\\), где \\(P\\) – матрица перестановок (показывающая, как менять строки), \\(L\\) – нижняя треугольная матрица с единицами на главной диагонали, \\(U\\) – верхняя треугольная матрица общего вида. После «разбиения» система решается в два шага: прямой ход \\(L \\cdot y = P \\cdot f\\) и обратный ход \\(U \\cdot x = y\\). Рассмотрим тот же простой пример с вырожденной матрицей:\n\\[\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n5 & 7 & 9\n\\end{bmatrix}\n\\cdot\nx=\n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 3\n\\end{bmatrix}\n\\]\nМаксимальное значение в первом столбце равно 5 и соответствует третьей строке. Таким образом, в рамках алгоритма необходимо отправить третью строку на первое место, первую строку – на третье, а вторую оставить на месте. Матрица \\(Р\\) примет следующий вид:\n\\[\nP=\n\\begin{bmatrix}\n0 & 0 & 1 \\\\\n0 & 1 & 0 \\\\\n1 & 0 & 0\n\\end{bmatrix}\n\\]\nА произведение \\(P \\cdot K\\):\n\\[\nP \\cdot K =\n\\begin{bmatrix}\n5 & 7 & 9 \\\\\n4 & 5 & 6 \\\\\n1 & 2 & 3\n\\end{bmatrix}\n\\]\nОбнуляем элементы под пятёркой, для чего вычитаем 0,8 первых строк из второй, и 0,2 первых строк из третьей:\n\\[\n\\begin{bmatrix}\n5 & 7 & 9 \\\\\n0 & -0,6 & -1,2 \\\\\n0 & 0,6 & 1,2\n\\end{bmatrix}\n\\]\nТеперь обнуляем элементы под -0,6, для чего вычитаем -1 вторых строк из третьей, получим:\n\\[\nU=\n\\begin{bmatrix}\n5 & 7 & 9 \\\\\n0 & -0,6 & -1,2 \\\\\n0 & 0 & 0\n\\end{bmatrix}\n\\]\nА матрица, куда отправляются коэффициенты вычитания, принимает вид:\n\\[\nL=\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0,8 & 1 & 0 \\\\\n0,2 & -1 & 1\n\\end{bmatrix}\n\\]\nНужные треугольные матрицы сформированы, матрица перестановок тоже, решаем \\(L \\cdot y = P \\cdot f\\):\n\\[\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0,8 & 1 & 0 \\\\\n0,2 & -1 & 1\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\ny_1 \\\\ y_2 \\\\ y_3\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n3 \\\\ 2 \\\\ 1\n\\end{bmatrix}\n\\]\nПолучаем:\n\\[\ny=\n\\begin{bmatrix}\n3 \\\\ -0,4 \\\\ 0\n\\end{bmatrix}\n\\]\nРешаем \\(U \\cdot x = y\\):\n\\[\n\\begin{bmatrix}\n5 & 7 & 9 \\\\\n0 & -0,6 & -1,2 \\\\\n0 & 0 & 0\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\nx_1 \\\\ x_2 \\\\ x_3\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n3 \\\\ -0,4 \\\\ 0\n\\end{bmatrix}\n\\]\nЗдесь так же, как и в предыдущем варианте, ведущий элемент в третьем столбце равен нулю, а решение уравнения:\n\\[\n0 \\cdot x_3 = 0\n\\]\nприводит к делению на ноль и неудаче в решении системы. При этом формально система всё ещё имеет бесконечное количество решений.\nРеализуем рассмотренный подход в задаче о шарнирно опёртой балке. Нужные для этого функции будут выглядеть следующим образом:\ndef plu_decomposition(A: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Выполняет PLU-разложение матрицы A на P (перестановки), L (нижнетреугольная), U (верхнетреугольная).\n      Args:\n        A (np.ndarray): Квадратная матрица (n x n).\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray]: Матрицы P, L, U.\n    Raises:\n        ValueError: Если матрица не квадратная.\n    \"\"\"\n\n    n = A.shape[0]\n    if A.shape[0] != A.shape[1]:\n        raise ValueError(\"Матрица должна быть квадратной!\")\n    ## Копируем А\n    A = A.copy()\n    ## Инициализируем P (единичная матрица), L и U\n    P = np.eye(n)  ## Матрица перестановок начинается как единичная\n    L = np.zeros((n, n))\n    U = np.zeros((n, n))\n    np.fill_diagonal(L, 1)  # Единицы на диагонали L\n    # Разложение с перестановками\n    for i in range(n):\n        # Ищем максимальный элемент в столбце i от i до конца\n        max_idx = i\n        for k in range(i + 1, n):\n            if abs(A[k, i]) &gt; abs(A[max_idx, i]):\n                max_idx = k\n        # Если нужно, меняем строки в A и P\n        if max_idx != i:\n            A[[i, max_idx]] = A[[max_idx, i]]\n            P[[i, max_idx]] = P[[max_idx, i]]\n            # Исправляем L: меняем строки до i (кроме диагонали)\n            if i &gt; 0:\n                L[[i, max_idx], :i] = L[[max_idx, i], :i]\n        # Заполняем U: элементы на диагонали и выше\n        for j in range(i, n):\n            U[i, j] = A[i, j] - sum(L[i, k] * U[k, j] for k in range(i))\n        # Заполняем L: элементы под диагональю\n        for j in range(i + 1, n):\n            if abs(U[i, i]) &lt; 1e-10:\n                raise ValueError(f\"Деление на ноль на шаге {i}!\")\n            L[j, i] = (A[j, i] - sum(L[j, k] * U[k, i] for k in range(i))) / U[i, i]\n    return P, L, U\n\ndef plu_solve(A: np.ndarray, b: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n     Решает систему A * x = b с помощью PLU-разложения.\n     Args:\n         A (np.ndarray): Квадратная матрица (n x n).\n         b (np.ndarray): Вектор правой части (n).\n     Returns:\n         np.ndarray: Вектор решения x (n).\n     \"\"\"\n    # Получаем P, L, U\n    P, L, U = plu_decomposition(A)\n    n = len(b)\n    b = b.copy()\n    # Применяем перестановки к b: Pb = P * b\n    Pb = P @ b\n    # Прямой ход: решаем L * y = Pb\n    y = np.zeros(n)\n    for i in range(n):\n        y[i] = Pb[i] - sum(L[i, j] * y[j] for j in range(i))\n    # Обратный ход: решаем U * x = y\n    x = np.zeros(n)\n    for i in range(n - 1, -1, -1):\n        if abs(U[i, i]) &lt; 1e-10:\n            raise ValueError(f\"Деление на ноль в U на шаге {i}!\")\n        x[i] = (y[i] - sum(U[i, j] * x[j] for j in range(i + 1, n))) / U[i, i]\n    return x\nРезультат решения задачи с помощью этой функции также будет аналогичен предыдущему – максимальный прогиб \\(0,4586~{\\text{мм}}\\) при полном наборе кинематических граничных условий (с учётом угла поворота \\(\\theta_x\\)) и сообщение об ошибке при неполном наборе граничных условий.\nПри этом, если сравнить между собой полученные в ходе решения задачи векторы перемещений, то результат будет выглядеть как:\nРазница my_solve vs NumPy: [0.000e+00 0.000e+00 0.000e+00 5.551e-17 0.000e+00 0.000e+00 0.000e+00\n 8.497e-20 0.000e+00 0.000e+00]\nРазница plu_solve vs NumPy: [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\nТаким образом, наше предположение о том, что встроенная в NumPy функция реализует PLU-разложение, можно считать верным. Заметим, что ни один из рассмотренных подходов не позволил получить решение для системы с вырожденной матрицей.\n\n\n\n2.2 Эталонное решение и сравнение с полученными ранее результатами\n\nК этому моменту уже была получена целая куча результатов, однако не понятно насколько они далеки от истины. Рассмотрим аналитическое решение для максимального прогиба балки Эйлера:\n\n\\[\nu_{max} = \\frac{F \\cdot L^3}{48 \\cdot E \\cdot I_z} = \\frac{1 \\cdot 600^3}{48 \\cdot 20000 \\cdot 490,87} = 0,458~{\\text{мм}}\n\\]\n\nгде \\(F\\) - поперечная сила, \\(F = 1~{\\text{кгс}}\\); \\(L\\) – длина балки, \\(L = 600~{\\text{мм}}\\); \\(E\\) – модуль упругости, \\(E=20000~{\\text{кгс/мм}}^2\\); \\(I_z\\) – момент инерции поперечного сечения, \\(I_z = \\frac{\\pi \\cdot D^4}{64} = \\frac{\\pi \\cdot 10^4}{64} = 490,87~{\\text{мм}}^4\\); \\(D\\) – диаметр поперечного сечения, \\(D = 10~{\\text{мм}}\\).\nАналитическое решение для максимального прогиба балки Тимошенко:\n\n\\[\nu_{max} = \\frac{F \\cdot L^3}{48 \\cdot E \\cdot I_z} + \\frac{F}{k \\cdot G \\cdot A} = \\frac{1 \\cdot 600^3}{48 \\cdot 20000 \\cdot 490,87} + \\frac{1}{1,111 \\cdot 7692 \\cdot 78,54} = 0,458~{\\text{мм}}\n\\]\n\nгде \\(A\\) – площадь поперечного сечения, \\(A = \\frac{\\pi \\cdot D^2}{4} = 78,54~{\\text{мм}}^2\\); \\(k\\) – коэффициент, который для круглого поперечного сечения равен \\(k = 10/9 = 1,111\\); \\(G\\) – модуль сдвига, \\(G = \\frac{E}{2 \\cdot (1 + \\mu)} = \\frac{20000}{2 \\cdot (1+0,3} = 7692~{\\text{кгс/мм}}^2\\).\nТаким образом, для нашей балки результаты получились одинаковыми (пушто наша балка достаточно длинная и влияние сдвига – минимально).\nТеперь настало время сопоставить полученные ранее результаты с эталонным решением. Сведём их в таблицу 1.\n\n\n\nTable 1: Таблица 1\n\n\n\n\n\n\n\n\n\n\n\nПрограмма\nРезультат решения задачи в исходной постановке\nМаксимальный прогиб\nРасхождение с аналитическим решением\n\n\n\n\nANSYS\nОшибка без фиксации вращений вращений вращений вращений\n-0,460 мм\n0,2%\n\n\nNASTRAN\nОшибка без фиксации вращений\n-0,459 мм\n0,2%\n\n\nCOMSOL\nДа\n-0,458 мм\n0%\n\n\nABAQUS\nДа\n-0,428 мм\n7%\n\n\nOptiStruct\nДа\n-0,459 мм\n0,2%\n\n\nЛОГОС\nДа\n-0,458 мм\n0%\n\n\nКод на Python с использованием функции из библиотеки NumPy\nОшибка без фиксации вращений\n-0,459 мм\n0,2%\n\n\nКод на Python с использованием PLU-разложения\nОшибка без фиксации вращений\n-0,459 мм\n0,2%\n\n\nКод на Python с использованием метода Гаусса\nОшибка без фиксации вращений\n-0,459 мм\n0,2%\n\n\n\n\n\n\n\n\n\n2.3 Промежуточный вывод\n\nПо результатам проведённого ресёрча можно сделать следующие выводы:\n\nДля задачи в исходной постановке (без ограничений на углы поворота) матрица жёсткости после приложения граничных условий становится вырожденной. Это связанно с тем, что оставшиеся свободные вращательные (вокруг оси балки) степени свободы позволяют системе совершать бесконтрольное вращение, что физически означает отсутствие равновесия (при отсутствии дополнительных ограничений).\nТакие программные продукты как ANSYS и NASTRAN, без использования дополнительных опций, используют классический подход с прямым обращением матрицы для линейных статических задач, т.е. пытаются решить систему уравнений \\(K \\cdot u=F\\) через разложение матрицы \\(K\\). В том случае, если матрица вырожденная и не было применено никаких «костылей» – решатель выдаёт сообщение об ошибке.\nТакие программные продукты как COMSOL, ABAQUS и OptiStruct (ну и, судя по всему, упомянутый господином Ш. SolidWorks Simulation) используют в качестве опций по умолчанию какие-то «костыли», позволяющие обрабатывать «вырожденность» матрицы жёсткости и получать таким образом конечное решение.\nВсе рассмотренные программные продукты (кроме ABAQUS), а также реализованный на Python код позволили получить решение, которое удовлетворительно соотносится с аналитическим, несмотря на, мягко скажем, небольшое количество конечных элементов в модели.\n\nЧто же, едем дальше.\n\n\n\n2.4 Немножко про матрицы жёсткости\n\nНе нашёл, куда бы это ещё приткнуть, пушто на первоначальный вопрос вида «почему у меня тут не считает, а вон там считает?» формируемые программными продуктами матрицы жёсткости не отвечают. Но я за каким-то хреном полез их смотреть – не пропадать же добру.\nЗапишем матрицу жёсткости всей модели, которую мы формируем ручками. Она будет выглядеть вот так:\n\n\\[\nK=\n\\begin{bmatrix}\n5.236e+03  & 0          & 0          & 0          & 0          & 0          & -5.236e+03 & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 4.355e+00  & 0          & 0          & 0          & 6.532e+02  & 0          & -4.355e+00 & 0          & 0          & 0          & 6.532e+02  & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 0          & 4.355e+00  & 0          & -6.532e+02 & 0          & 0          & 0          & -4.355e+00 & 0          & -6.532e+02 & 0          & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 0          & 0          & 2.517e+04  & 0          & 0          & 0          & 0          & 0          & -2.517e+04 & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 0          & -6.532e+02 & 0          & 1.307e+05  & 0          & 0          & 0          & 6.532e+02  & 0          & 6.526e+04  & 0          & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 6.532e+02  & 0          & 0          & 0          & 1.307e+05  & 0          & -6.532e+02 & 0          & 0          & 0          & 6.526e+04  & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n-5.236e+03 & 0          & 0          & 0          & 0          & 0          & 1.047e+04  & 0          & 0          & 0          & 0          & 0          & -5.236e+03 & 0          & 0          & 0          & 0          & 0 \\\\\n0          & -4.355e+00 & 0          & 0          & 0          & -6.532e+02 & 0          & 8.710e+00  & 0          & 0          & 0          & 0          & 0          & -4.355e+00 & 0          & 0          & 0          & 6.532e+02 \\\\\n0          & 0          & -4.355e+00 & 0          & 6.532e+02  & 0          & 0          & 0          & 8.710e+00  & 0          & 0          & 0          & 0          & 0          & -4.355e+00 & 0          & -6.532e+02 & 0 \\\\\n0          & 0          & 0          & -2.517e+04 & 0          & 0          & 0          & 0          & 0          & 5.035e+04  & 0          & 0          & 0          & 0          & 0          & -2.517e+04 & 0          & 0 \\\\\n0          & 0          & -6.532e+02 & 0          & 6.526e+04  & 0          & 0          & 0          & 0          & 0          & 2.614e+05  & 0          & 0          & 0          & 6.532e+02  & 0          & 6.526e+04  & 0 \\\\\n0          & 6.532e+02  & 0          & 0          & 0          & 6.526e+04  & 0          & 0          & 0          & 0          & 0          & 2.614e+05  & 0          & -6.532e+02 & 0          & 0          & 0          & 6.526e+04 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & -5.236e+03 & 0          & 0          & 0          & 0          & 0          & 5.236e+03  & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & -4.355e+00 & 0          & 0          & 0          & -6.532e+02 & 0          & 4.355e+00  & 0          & 0          & 0          & -6.532e+02 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & -4.355e+00 & 0          & 6.532e+02  & 0          & 0          & 0          & 4.355e+00  & 0          & 6.532e+02  & 0 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & -2.517e+04 & 0          & 0          & 0          & 0          & 0          & 2.517e+04  & 0          & 0 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & -6.532e+02 & 0          & 6.526e+04  & 0          & 0          & 0          & 6.532e+02  & 0          & 1.307e+05  & 0 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & 6.532e+02  & 0          & 0          & 0          & 6.526e+04  & 0          & -6.532e+02 & 0          & 0          & 0          & 1.307e+05\n\\end{bmatrix}\n\\]\n\nЕсли дёрнуть матрицу жёсткости из \\(NASTRAN\\), то она будет выглядеть вот так:\n\n\\[\nK=\n\\begin{bmatrix}\n5.236e+03  & 0          & 0          & 0          & 0          & 0          & -5.236e+03 & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 4.353e+00  & 0          & 0          & 0          & 6.529e+02  & 0          & -4.353e+00 & 0          & 0          & 0          & 6.529e+02  & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 0          & 4.353e+00  & 0          & -6.529e+02 & 0          & 0          & 0          & -4.353e+00 & 0          & -6.529e+02 & 0          & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 0          & 0          & 2.515e+04  & 0          & 0          & 0          & 0          & 0          & -2.515e+04 & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 0          & -6.529e+02 & 0          & 1.307e+05  & 0          & 0          & 0          & 6.529e+02  & 0          & 6.521e+04  & 0          & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 6.529e+02  & 0          & 0          & 0          & 1.307e+05  & 0          & -6.529e+02 & 0          & 0          & 0          & 6.521e+04  & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n-5.236e+03 & 0          & 0          & 0          & 0          & 0          & 1.047e+04  & 0          & 0          & 0          & 0          & 0          & -5.236e+03 & 0          & 0          & 0          & 0          & 0 \\\\\n0          & -4.355e+00 & 0          & 0          & 0          & -6.529e+02 & 0          & 8.705e+00  & 0          & 0          & 0          & 0          & 0          & -4.353e+00 & 0          & 0          & 0          & 6.529e+02 \\\\\n0          & 0          & -4.353e+00 & 0          & 6.529e+02  & 0          & 0          & 0          & 8.705e+00  & 0          & 0          & 0          & 0          & 0          & -4.353e+00 & 0          & -6.529e+02 & 0 \\\\\n0          & 0          & 0          & -2.515e+04 & 0          & 0          & 0          & 0          & 0          & 5.030e+04  & 0          & 0          & 0          & 0          & 0          & -2.515e+04 & 0          & 0 \\\\\n0          & 0          & -6.529e+02 & 0          & 6.521e+04  & 0          & 0          & 0          & 0          & 0          & 2.613e+05  & 0          & 0          & 0          & 6.529e+02  & 0          & 6.521e+04  & 0 \\\\\n0          & 6.529e+02  & 0          & 0          & 0          & 6.521e+04  & 0          & 0          & 0          & 0          & 0          & 2.613e+05  & 0          & -6.529e+02 & 0          & 0          & 0          & 6.521e+04 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & -5.236e+03 & 0          & 0          & 0          & 0          & 0          & 5.236e+03  & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & -4.353e+00 & 0          & 0          & 0          & -6.529e+02 & 0          & 4.353e+00  & 0          & 0          & 0          & -6.529e+02 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & -4.353e+00 & 0          & 6.529e+02  & 0          & 0          & 0          & 4.353e+00  & 0          & 6.529e+02  & 0 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & -2.515e+04 & 0          & 0          & 0          & 0          & 0          & 2.515e+04  & 0          & 0 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & -6.529e+02 & 0          & 6.521e+04  & 0          & 0          & 0          & 6.529e+02  & 0          & 1.307e+05  & 0 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & 6.529e+02  & 0          & 0          & 0          & 6.521e+04  & 0          & -6.529e+02 & 0          & 0          & 0          & 1.307e+05\n\\end{bmatrix}\n\\]\n\nНесложно заметить, что сформированная в \\(NASTRAN\\) матрица жёсткости демонстрирует практически полное совпадение с матрицей жёсткости, которую формирует наш код на Python. Небольшая разница в числах объясняется отсутствием учёта сдвига для балок Эйлера, используемых в \\(NASTRAN\\).\nМатрица жёсткости, сформированная в \\(ANSYS\\), выглядит вот так:\n\n\\[\nK=\n\\begin{bmatrix}\n5.232e+03  & 0          & 0          & 0          & 0          & 0          & -5.232e+03 & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 2.266e+01  & 0          & 0          & 0          & 3.399e+03  & 0          & -2.266e+01 & 0          & 0          & 0          & 3.399e+03  & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 0          & 2.266e+01  & 0          & -3.399e+03 & 0          & 0          & 0          & -2.266e+01 & 0          & -3.399e+03 & 0          & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 0          & 0          & 2.512e+04  & 0          & 0          & 0          & 0          & 0          & -2.512e+04 & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 0          & -3.399e+03 & 0          & 5.425e+05  & 0          & 0          & 0          & 3.399e+03  & 0          & 4.772e+05  & 0          & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 3.399e+03  & 0          & 0          & 0          & 5.425e+05  & 0          & -3.399e+03 & 0          & 0          & 0          & 4.772e+05  & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n-5.232e+03 & 0          & 0          & 0          & 0          & 0          & 1.046e+04  & 0          & 0          & 0          & 0          & 0          & -5.232e+03 & 0          & 0          & 0          & 0          & 0 \\\\\n0          & -2.266e+01 & 0          & 0          & 0          & -3.399e+03 & 0          & 4.532e+01  & 0          & 0          & 0          & 0          & 0          & -2.266e+01 & 0          & 0          & 0          & 3.399e+03 \\\\\n0          & 0          & -2.266e+01 & 0          & 3.399e+03  & 0          & 0          & 0          & 4.532e+01  & 0          & 0          & 0          & 0          & 0          & -2.266e+01 & 0          & -3.399e+03 & 0 \\\\\n0          & 0          & 0          & -2.512e+04 & 0          & 0          & 0          & 0          & 0          & 5.024e+04  & 0          & 0          & 0          & 0          & 0          & -2.512e+04 & 0          & 0 \\\\\n0          & 0          & -3.399e+03 & 0          & 4.772e+05  & 0          & 0          & 0          & 0          & 0          & 1.085e+06  & 0          & 0          & 0          & 3.399e+03  & 0          & 4.772e+05  & 0 \\\\\n0          & 3.399e+03  & 0          & 0          & 0          & 4.772e+05  & 0          & 0          & 0          & 0          & 0          & 1.085e+06  & 0          & -3.399e+03 & 0          & 0          & 0          & 4.772e+05 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & -5.232e+03 & 0          & 0          & 0          & 0          & 0          & 5.232e+03  & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & -2.266e+01 & 0          & 0          & 0          & -3.399e+03 & 0          & 2.266e+01  & 0          & 0          & 0          & -3.399e+03 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & -2.266e+01 & 0          & 3.399e+03  & 0          & 0          & 0          & 2.266e+01  & 0          & 3.399e+03  & 0 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & -2.512e+04 & 0          & 0          & 0          & 0          & 0          & 2.512e+04  & 0          & 0 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & -3.399e+03 & 0          & 4.772e+05  & 0          & 0          & 0          & 3.399e+03  & 0          & 5.425e+05  & 0 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & 3.399e+03  & 0          & 0          & 0          & 4.772e+05  & 0          & -3.399e+03 & 0          & 0          & 0          & 5.425e+05\n\\end{bmatrix}\n\\]\n\nЕё структура аналогична двум предыдущим, но в числах всё поехало куда-то не туда. При этом, стоит отметить, что полученная матрица жёсткости соответствует модели, построенной в \\(MAPDL\\) с нуля. Если же пробросить балку в \\(MAPDL\\) из \\(WB\\), то в числах она будет совсем по-другому (структура сохраняется и на том спасибо).\nМатрица жёсткости, которую формирует \\(COMSOL\\), имеет следующий вид:\n\n\\[\nK=\n\\begin{bmatrix}\n2.517e+02  & 0          & 0          & 0          & 0          & 0          & -2.517e+02 & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 1.309e+03  & -3.826e-13 & 0          & 1.168e-12  & 6.545e+03  & 0          & 6.545e+02  & -1.830e-13 & 0          & -1.168e-12 & -6.545e+03 & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & -3.826e-13 & 1.309e+03  & 0          & -6.545e+03 & -1.168e-12 & 0          & -1.830e-13 & 6.545e+02  & 0          & 6.545e+03  & 1.168e-12  & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 0          & 0          & 5.236e+07  & 0          & 0          & 0          & 0          & 0          & -5.236e+07 & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 1.395e-12  & -6.545e+03 & 0          & 4.363e+04  & 1.182e-11  & 0          & 1.137e-12  & -6.545e+03 & 0          & -4.363e+04 & -1.182e-11 & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 6.545e+03  & -1.395e-12 & 0          & 1.182e-11  & 4.363e+04  & 0          & 6.545e+03  & -1.137e-12 & 0          & -1.182e-11 & -4.363e+04 & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n-2.517e+02 & 0          & 0          & 0          & 0          & 0          & 5.035e+02  & 0          & 0          & 0          & 0          & 0          & -2.517e+02 & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 6.545e+02  & -1.834e-13 & 0          & 1.023e-12  & 6.545e+03  & 0          & 2.618e+03  & -5.815e-13 & 0          & 2.842e-14  & -1.819e-12 & 0          & 6.545e+02  & -1.510e-13 & 0          & -1.052e-12 & -6.545e+03 \\\\\n0          & -1.834e-13 & 6.545e+02  & 0          & -6.545e+03 & -1.023e-12 & 0          & -5.815e-13 & 2.618e+03  & 0          & 1.819e-12  & -2.842e-14 & 0          & -1.510e-13 & 6.545e+02  & 0          & 6.545e+03  & 1.052e-12 \\\\\n0          & 0          & 0          & -5.236e+07 & 0          & 0          & 0          & 0          & 0          & 1.047e+08  & 0          & 0          & 0          & 0          & 0          & -5.236e+07 & 0          & 0 \\\\\n0          & -1.395e-12 & 6.545e+03  & 0          & -4.363e+04 & -1.182e-11 & 0          & 1.412e-13  & 2.729e-12  & 0          & 8.727e+04  & 1.819e-11  & 0          & 6.821e-13  & -6.545e+03 & 0          & -4.363e+04 & -6.367e-12 \\\\\n0          & -6.545e+03 & 1.395e-12  & 0          & -1.182e-11 & -4.363e+04 & 0          & -2.729e-12 & -1.412e-13 & 0          & 1.819e-11  & 8.727e+04  & 0          & 6.545e+03  & -6.821e-13 & 0          & -6.367e-12 & -4.363e+04 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & -2.517e+02 & 0          & 0          & 0          & 0          & 0          & 2.517e+02  & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & 6.545e+02  & -1.519e-13 & 0          & 1.705e-12  & 6.545e+03  & 0          & 1.309e+03  & -1.990e-13 & 0          & -1.705e-12 & -6.545e+03 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & -1.519e-13 & 6.545e+02  & 0          & -6.545e+03 & -1.705e-12 & 0          & -1.990e-13 & 1.309e+03  & 0          & 6.545e+03  & 1.705e-12 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & -5.236e+07 & 0          & 0          & 0          & 0          & 0          & 5.236e+07  & 0          & 0 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & -1.278e-12 & 6.545e+03  & 0          & -4.363e+04 & -6.367e-12 & 0          & -6.821e-13 & 6.545e+03  & 0          & 4.363e+04  & 6.367e-12 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & -6.545e+03 & 1.278e-12  & 0          & -6.367e-12 & -4.363e+04 & 0          & -6.545e+03 & 6.821e-13  & 0          & 6.367e-12  & 4.363e+04\n\\end{bmatrix}\n\\]\n\nМатрица, полученная в \\(COMSOL\\) примечательна наличием очень маленьких, однако не нулевых элементов. При этом элементы, отличные от нуля, отличаются от своих собратьев из «ручной» и настрановской матриц.\nМатрица жёсткости модели, которую собирает \\(OptiStruct\\), будет выглядеть вот так:\n\n\\[\nK=\n\\begin{bmatrix}\n5.236e+03  & 0          & 0          & 0          & 0          & 0          & -5.236e+03 & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 4.354e+00  & 0          & 0          & 0          & 6.531e+02  & 0          & -4.354e+00 & 0          & 0          & 0          & 6.531e+02  & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 0          & 4.354e+00  & 0          & -6.531e+02 & 0          & 0          & 0          & -4.354e+00 & 0          & -6.531e+02 & 0          & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 0          & 0          & 2.517e+04  & 0          & 0          & 0          & 0          & 0          & -2.517e+04 & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 0          & -6.531e+02 & 0          & 1.307e+05  & 0          & 0          & 0          & 6.531e+02  & 0          & 6.524e+04  & 0          & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 6.531e+02  & 0          & 0          & 0          & 1.307e+05  & 0          & -6.531e+02 & 0          & 0          & 0          & 6.526e+04  & 0          & 0          & 0          & 0          & 0          & 0 \\\\\n-5.236e+03 & 0          & 0          & 0          & 0          & 0          & 1.047e+04  & 0          & 0          & 0          & 0          & 0          & -5.236e+03 & 0          & 0          & 0          & 0          & 0 \\\\\n0          & -4.354e+00 & 0          & 0          & 0          & -6.531e+02 & 0          & 8.708e+00  & 0          & 0          & 0          & 0          & 0          & -4.354e+00 & 0          & 0          & 0          & 6.531e+02 \\\\\n0          & 0          & -4.354e+00 & 0          & 6.531e+02  & 0          & 0          & 0          & 8.708e+00  & 0          & 0          & 0          & 0          & 0          & -4.354e+00 & 0          & -6.531e+02 & 0 \\\\\n0          & 0          & 0          & -2.517e+04 & 0          & 0          & 0          & 0          & 0          & 5.035e+04  & 0          & 0          & 0          & 0          & 0          & -2.517e+04 & 0          & 0 \\\\\n0          & 0          & -6.531e+02 & 0          & 6.524e+04  & 0          & 0          & 0          & 0          & 0          & 2.614e+05  & 0          & 0          & 0          & 6.531e+02  & 0          & 6.524e+04  & 0 \\\\\n0          & 6.531e+02  & 0          & 0          & 0          & 6.524e+04  & 0          & 0          & 0          & 0          & 0          & 2.614e+05  & 0          & -6.531e+02 & 0          & 0          & 0          & 6.524e+04 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & -5.236e+03 & 0          & 0          & 0          & 0          & 0          & 5.236e+03  & 0          & 0          & 0          & 0          & 0 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & -4.354e+00 & 0          & 0          & 0          & -6.531e+02 & 0          & 4.354e+00  & 0          & 0          & 0          & -6.531e+02 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & -4.354e+00 & 0          & 6.531e+02  & 0          & 0          & 0          & 4.354e+00  & 0          & 6.531e+02  & 0 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & -2.517e+04 & 0          & 0          & 0          & 0          & 0          & 2.517e+04  & 0          & 0 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & -6.531e+02 & 0          & 6.524e+04  & 0          & 0          & 0          & 6.531e+02  & 0          & 1.307e+05  & 0 \\\\\n0          & 0          & 0          & 0          & 0          & 0          & 0          & 6.531e+02  & 0          & 0          & 0          & 6.524e+04  & 0          & -6.531e+02 & 0          & 0          & 0          & 1.307e+05\n\\end{bmatrix}\n\\]\n\n\\(OptiStruct\\) очень хорошо соотносится с «ручным» решением и результатом из \\(NASTRAN\\) как качественно, так и количественно.\nПри попытках выдрать матрицу жёсткости из \\(ABAQUS\\) у меня, к сожалению, сгорела жёппа, поэтому матрица жёсткости из него представлена не будет.\n\n\n\n2.5 «Костыли»\n\nУбедившись в отсутствии решения нашей задачи «классическими» методами, попробуем рассмотреть механизмы, позволяющие программным комплексам обойти проблему решения задачи с вырожденной матрицей жёсткости.\n\n2.5.1 Методы, основанные на сингулярном разложении\nЕжели вооружиться любой приличной книгой по Фортрану, то в каждой из них будет рассмотрен алгоритм SVD (Singular Value Decomposition), суть которого сводится к получению псевдообратной матрицы через разложение матрицы \\(K\\) на три части таким образом, что \\(K = U \\cdot Σ \\cdot V \\cdot T\\), где \\(U\\) – ортогональная матрица, столбцы которой представляют собой левые сингулярные векторы, \\(Σ\\) – диагональная матрица с сингулярными значениями (неотрицательными числами, показывающими «вес» каждого направления), \\(V\\) – ортогональная матрица, столбцы которой – правые сингулярные векторы.\nРассмотрим уже знакомую нам систему с вырожденной матрицей\n\\[\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n5 & 7 & 9\n\\end{bmatrix}\n\\cdot\nx=\n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 3\n\\end{bmatrix}\n\\]\nВ результате разложения (можно в маткаде прикинуть) получим:\n\n\\[\nU=\n\\begin{bmatrix}\n-0,235 & -0,782 & -0,577 \\\\\n-0,559 & 0,595 & -0,577 \\\\\n-0,795 & -0,187 & 0,577\n\\end{bmatrix}\n,~Σ=\n\\begin{bmatrix}\n15,663 & 0 & 0 \\\\\n0 & 0,813 & 0 \\\\\n0 & 0 & 0\n\\end{bmatrix}\n,~V=\n\\begin{bmatrix}\n-0,412 & 0,815 & -0,408 \\\\\n-0,564 & 0,124 & 0,816 \\\\\n-0,716 & -0,566 & -0,408\n\\end{bmatrix}\n\\]\n\nПсевдообратная (заменяем ненулевые элементы на диагонали на обратные) матрица для \\(Σ\\) будет выглядеть как:\n\n\\[\nΣ^{+}=\n\\begin{bmatrix}\n1/15,663 &0 & 0 \\\\\n0 & 1/0,813 & 0 \\\\\n0 & 0 & 0\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0,064 & 0 & 0 \\\\\n0 & 1,231 & 0 \\\\\n0 & 0 & 0\n\\end{bmatrix}\n\\]\n\nНайдём частное решение по соотношению \\(x_{\\text{част}} = V \\cdot Σ^{+} \\cdot U^{T} \\cdot f\\):\n\n\\[\nU^{T} \\cdot f =\n\\begin{bmatrix}\n-0,235 & -0,559 & -0,795 \\\\\n-0,782 & 0,595 & -0,187 \\\\\n-0,577 & -0,577 & 0,577\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 3\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-3,739 \\\\ -0,153 \\\\ 0\n\\end{bmatrix}\n\\]\n\n\n\\[\nΣ^{+} \\cdot U^{T} \\cdot f =\n\\begin{bmatrix}\n0,064 & 0 & 0 \\\\\n0 & 1,231 & 0 \\\\\n0 & 0 & 0  \n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n-3,739 \\\\ -0,153 \\\\ 0\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-0,239 \\\\ -0,189 \\\\ 0\n\\end{bmatrix}\n\\]\n\n\n\\[\nx_{\\text{част}} = K^{+} \\cdot f = V \\cdot Σ^{+} \\cdot U^{T} \\cdot f =\n\\begin{bmatrix}\n-0,412 & 0,815 & -0,408 \\\\\n-0,564 & 0,124 & 0,816 \\\\\n-0,716 & -0,566 & -0,408\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n-0,239 \\\\ -0,189 \\\\ 0\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-0,056 \\\\ 0,111 \\\\ 0,278\n\\end{bmatrix}\n\\]\n\nНаходим базис ядра (ядро матрицы \\(K\\) – это те векторы \\(x\\), для которых \\(K \\cdot x = 0\\)). В \\(Σ\\) третье значение равно нулю, значит, третий столбец \\(V\\) и есть базис ядра:\n\\[\nk=\n\\begin{bmatrix}\n-0,418 \\\\ 0,816 \\\\ -0,408\n\\end{bmatrix}\n\\]\nПолное решение находится в виде \\(x = x_{\\text{част}} + \\alpha \\cdot k\\), где \\(\\alpha\\) - произвольная константа:\n\\[\nx=\n\\begin{bmatrix}\n-0,056 \\\\ 0,111 \\\\ 0,278\n\\end{bmatrix}\n+ \\alpha \\cdot\n\\begin{bmatrix}\n-0,418 \\\\ 0,816 \\\\ -0,408\n\\end{bmatrix}\n\\]\nОчевидно, что в силу произвольности константы \\(\\alpha\\) для системы с вырожденной матрицей можно получить сколько угодно «полных» решений. Полученное выше частное решение является минимальным по норме \\((||x_{\\text{част}}|| = \\sqrt{x_{\\text{част}}^{T} \\cdot x_{\\text{част}}})\\) среди всех возможных решений и ортогональным ядру (то есть \\(x_{\\text{част}}\\) перпендикулярен всем векторам ядра \\(K\\): \\(x_{\\text{част}}^{T} \\cdot v_{i} = 0\\) для любого \\(v_{i}\\) из ядра). Для задачи с шарнирно опёртой балкой найденное частное решение будет представлять собой перемещения с минимальной «энергией».\nАлсо, если в решение в общем виде, которое мы получили равнее, подставить \\(t = 0,278\\), то получим:\n\n\\[\nx=\n\\begin{bmatrix}\n-0,333 + t \\\\ 0,667 - 2 \\cdot t \\\\ t\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-0,333 + 0,278 \\\\ 0,667 - 2 \\cdot 0,278 \\\\ 0,278\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-0,055 \\\\ 0,111 \\\\ 0,278\n\\end{bmatrix}\n,\n\\]\n\nчто отлично соотносится с результатом, полученным через SVD-разложение.\nПодстановка полученного частного решения в исходную систему даёт:\n\\[\nK \\cdot x_{\\text{част}}=\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n5 & 7 & 9\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n-0,056 \\\\ 0,111 \\\\ 0,278\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 3\n\\end{bmatrix}\n\\]\nРеализуем рассмотренный подход в задаче о шарнирно опёртой балке. Нужная для этого функция будет выглядеть следующим образом:\ndef svd_solve(A: np.ndarray, b: np.ndarray, tol: float = 1e-10) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Решает вырожденную систему через SVD, возвращая частное решение и базис ядра.\n    Args:\n        A (np.ndarray): Матрица (n x n).\n        b (np.ndarray): Вектор правой части (n).\n        tol (float): Порог для обрезки сингулярных значений.\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: Частное решение x_p и базис ядра (столбцы).\n    \"\"\"\n    U, Sigma, Vt = np.linalg.svd(A)\n    n = len(b)\n\n    # Частное решение\n    Sigma_plus = np.zeros((n, n))\n    rank = 0\n    for i in range(n):\n        if Sigma[i] &gt; tol:\n            Sigma_plus[i, i] = 1 / Sigma[i]\n            rank += 1\n    x_p = Vt.T @ Sigma_plus @ U.T @ b\n\n    # Базис ядра (столбцы Vt для нулевых Sigma)\n    kernel_basis = Vt[rank:].T  # Транспонируем, чтобы столбцы были векторами\n\n    return x_p, kernel_basis\nГотовым аналогом этой функции из библиотеки NumPy служит функция np.linalg.pinv, решение с помощью которой будет выглядеть как:\nu_red_pinv = np.linalg.pinv(k_red) @ f_red\nРезультат выполнения кода с использованием этих функций применительно к задаче о шарнирно опёртой балке с неполным набором граничных условий будет выглядеть так:\nПеремещения (my_solve): не удалось вычислить из-за вырожденности\nПеремещения (NumPy): не удалось вычислить из-за вырожденности\nПеремещения (plu_solve): не удалось вычислить из-за вырожденности\nПеремещения (псевдообратная): [-6.364e-18 -1.345e-15  2.292e-03 -1.129e-16  4.586e-01  2.772e-13\n -9.976e-18 -4.090e-17 -2.618e-17 -9.806e-18  1.411e-15 -2.292e-03]\nПрогиб u_2y (псевдообратная): 0.4586 мм\nПеремещения (SVD частное): [-6.364e-18 -1.345e-15  2.292e-03 -1.129e-16  4.586e-01  2.772e-13\n -9.976e-18 -4.090e-17 -2.618e-17 -9.806e-18  1.411e-15 -2.292e-03]\nПрогиб u_2y (SVD): 0.4586 мм\nОпределённая величина прогиба в центре балки совпадает как с аналитическим решением, так и с результатами из различных программных комплексов.\n\n\n2.5.2 Методы, основанные на анализе собственных значений\nМожно было бы отнести этот подход в группу к предыдущему, пушто процедура получения решения похожа, но посмотрим отдельно. Если матрица \\(K\\) в системе \\(K \\cdot x = f\\) – симметричная, что соответствует нашей исходной задаче о шарнирно опёртой балке, то можно её диагонализировать \\(K = V \\cdot Λ \\cdot V^{T}\\), где \\(V\\) – матрица собственных векторов, \\(Λ\\) – диагональная матрица собственных значений (в случае вырожденной матрицы \\(K\\) некоторые значения будут равны нулю). После такого преобразования перейдём к новой системе \\(Λ \\cdot y = g\\), где \\(g = V^{T} \\cdot f\\) и \\(y = V^{T} \\cdot x\\). Убирая из системы нулевые значения (в случае вырожденной матрицы \\(K\\)) перейдём к «сокращённой системе» \\(Λ_{red} \\cdot y_{red} = g_{red}\\) и восстанавливаем результат как \\(x = V_{red} \\cdot y_{red}\\). Посмотрим, как это будет выглядеть на примере:\n\\[\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n5 & 7 & 9\n\\end{bmatrix}\n\\cdot\nx=\n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 3\n\\end{bmatrix}\n\\]\nС прискорбием замечаем, что наша «тестовая» матрица далека от симметричной, поэтому будем искать решение не для системы \\(K \\cdot x = f\\), а для системы \\(K^{T} \\cdot K \\cdot x = K^{T} \\cdot f\\):\n\n\\[\nK^{T} \\cdot K=\n\\begin{bmatrix}\n1 & 4 & 5 \\\\\n2 & 5 & 7 \\\\\n3 & 6 & 9\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n5 & 7 & 9\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n42 & 57 & 72 \\\\\n57 & 78 & 99 \\\\\n72 & 99 & 126\n\\end{bmatrix}\n\\]\n\nМатрицы собственных значений и собственных векторов для \\(K^{T} \\cdot K\\) имеют вид:\n\n\\[\nΛ=\n\\begin{bmatrix}\n0 & 0 & 0 \\\\\n0 & 0,66 & 0 \\\\\n0 & 0 & 245,34\n\\end{bmatrix}\n,~V=\n\\begin{bmatrix}\n-0,408 & -0,815 & 0,412 \\\\\n0,816 & -0,124 & 0,564 \\\\\n-0,408 & 0,566 & 0,716\n\\end{bmatrix}\n\\]\n\nЭлемент (1,1) матрицы собственных значений – нулевой, поэтому редуцированные матрицы примут вид:\n\n\\[\nΛ_{red}=\n\\begin{bmatrix}\n0,66 & 0 \\\\\n0 & 245,34\n\\end{bmatrix}\n,~V_{red}=\n\\begin{bmatrix}\n-0,815 & 0,412 \\\\\n-0,124 & 0,564 \\\\\n0,566 & 0,716\n\\end{bmatrix}\n\\]\n\nРедуцированный вектор сил примет вид:\n\n\\[\nf_{red} = V_{red}^{T} \\cdot K^{T} \\cdot f =\n\\begin{bmatrix}\n-0,815 & -0,124 & 0,566 \\\\\n0,412 & 0,564 & 0,716\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n1 & 4 & 5 \\\\\n2 & 5 & 7 \\\\\n3 & 6 & 9\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 3\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0,125 \\\\ 58,558\n\\end{bmatrix}\n\\]\n\nРешаем систему \\(Λ_{red} \\cdot x_{red} = f_{red}\\):\n\n\\[\n\\begin{bmatrix}\n0,66 & 0 \\\\\n0 & 245,34\n\\end{bmatrix}\n\\cdot\nx_{red}=\n\\begin{bmatrix}\n0,125 \\\\ 58,558\n\\end{bmatrix}\n\\]\n\nПолучим:\n\\[\nx_{red}=\n\\begin{bmatrix}\n0,189 \\\\ 0,239\n\\end{bmatrix}\n\\]\nВосстанавливаем полное решение как \\(x = V_{red} \\cdot x_{red}\\):\n\n\\[\nx=V_{red} \\cdot x_{red}=\n\\begin{bmatrix}\n-0,815 & 0,412 \\\\\n-0,124 & 0,564 \\\\\n0,566 & 0,716\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n0,189 \\\\ 0,239\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-0,056 \\\\ 0,111 \\\\ 0,278\n\\end{bmatrix}\n\\]\n\nАналогичное решение уже было получено ранее с использованием SVD-разложения.\nРеализуем рассмотренный подход в задаче о шарнирно опёртой балке. Нужная для этого функция будет выглядеть следующим образом:\ndef eigen_solve(K: np.ndarray, f: np.ndarray, tol: float = 1e-10) -&gt; NDArray:\n    \"\"\"\n    Решает систему через анализ собственных значений, убирая нулевые моды.\n    Args:\n        K (np.ndarray): Матрица жёсткости (n x n).\n        f (np.ndarray): Вектор сил (n).\n        tol (float): Порог для нулевых собственных значений.\n    Returns:\n        NDArray: Решение x.\n    \"\"\"\n    # Собственные значения и векторы\n    eigenvalues, eigenvectors = np.linalg.eigh(K)\n    # Определяем \"жёсткие\" моды\n    active_modes = eigenvalues &gt; tol\n    Lambda_red = np.diag(eigenvalues[active_modes])\n    V_red = eigenvectors[:, active_modes]\n    # Решаем в сокращённом базисе: V_red * Lambda_red * V_red^T * x = f\n    f_red = V_red.T @ f\n    x_red = np.linalg.solve(Lambda_red, f_red)\n    # Восстанавливаем полное решение\n    x = V_red @ x_red\n    return x\nРезультат выполнения кода с использованием этих функций применительно к задаче о шарнирно опёртой балке с неполным набором граничных условий будет выглядеть так:\nПеремещения (Eigen): [ 1.129e-27  7.458e-16  2.292e-03 -1.762e-16  4.586e-01 -1.491e-13\n -1.179e-21  3.898e-17  2.222e-17 -1.280e-19 -7.605e-16 -2.292e-03]\nПрогиб u_2y (Eigen): 0.4586 мм\nОчередной верный ответ.\n\n\n2.5.3 Методы, основанные на регуляризации\nКогда матрица \\(K\\) вырождена и система \\(K \\cdot x = f\\) не имеет единственного решения, метод регуляризации Тихонова «исправляет» это, добавляя небольшую регуляризацию, чтобы сделать матрицу \\(K\\) невырожденной. При этом вместо прямого решения уравнения \\(K \\cdot x = f\\) мы решаем модифицированную задачу, минимизируя функционал \\(J(x)=||K \\cdot x~–~f \\cdot ||2+λ \\cdot ||x||^2\\), что приводит к системе \\((K^{T} \\cdot K + λ \\cdot I) \\cdot x = K^{T} \\cdot f\\). Рассмотрим пример:\n\\[\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n5 & 7 & 9\n\\end{bmatrix}\n\\cdot\nx=\n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 3\n\\end{bmatrix}\n\\]\nСчитаем \\(K^{T} \\cdot K\\):\n\\[\nK^{T}=\n\\begin{bmatrix}\n1 & 4 & 5 \\\\\n2 & 5 & 7 \\\\\n3 & 6 & 9\n\\end{bmatrix}\n\\]\n\n\\[\nK^{T} \\cdot K=\n\\begin{bmatrix}\n1 & 4 & 5 \\\\\n2 & 5 & 7 \\\\\n3 & 6 & 9\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n5 & 7 & 9\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n42 & 57 & 72 \\\\\n57 & 78 & 99 \\\\\n72 & 99 & 126\n\\end{bmatrix}\n\\]\n\nДобавляем \\(λ \\cdot I\\), где \\(λ\\) – некоторое малое значение (\\(λ = 10-6\\)):\n\\[\nI=\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\]\n\n\\[\nK^{T} \\cdot K + \\lambda \\cdot I =\n\\begin{bmatrix}\n42 & 57 & 72 \\\\\n57 & 78 & 99 \\\\\n72 & 99 & 126\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n0,000001 & 0 & 0 \\\\\n0 & 0,000001 & 0 \\\\\n0 & 0 & 0,000001\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n42,000001 & 57 & 72 \\\\\n57 & 78,000001 & 99 \\\\\n72 & 99 & 126,000001\n\\end{bmatrix}\n\\]\n\nОтсюда, решая систему \\((K^{T} \\cdot K + \\lambda \\cdot I) \\cdot x = K^{T} \\cdot f\\), получим:\n\\[\nx=\n\\begin{bmatrix}\n-0,056 \\\\ 0,111 \\\\ 0,278\n\\end{bmatrix}\n\\]\nАналогичный результат мы уже получали раньше при решении системы через SVD-разложение. Проверка результата подстановкой в \\(K \\cdot x\\) даёт:\n\\[\nK \\cdot x =\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n5 & 7 & 9\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n-0,056 \\\\ 0,111 \\\\ 0,278\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 3\n\\end{bmatrix}\n.\n\\]\nКак несложно заметить, полученное решение с хорошей точностью удовлетворяет исходной системе.\nРеализуем рассмотренный подход в задаче о шарнирно опёртой балке. Нужная для этого функция будет выглядеть следующим образом:\ndef tikhonov_solve(A: np.ndarray, b: np.ndarray, lambda_: float = 1e-6) -&gt; np.ndarray:\n    \"\"\"\n    Решает вырожденную систему через регуляризацию Тихонова: (A^T A + λI) x = A^T b.\n    Args:\n        A (np.ndarray): Матрица (n x n).\n        b (np.ndarray): Вектор правой части (n).\n        lambda_ (float): Параметр регуляризации.\n    Returns:\n        np.ndarray: Решение x.\n    \"\"\"\n    n = len(b)\n    # Решаем уравнение с добавленной регуляризацией\n    return np.linalg.solve(A.T @ A + lambda_ * np.eye(n), A.T @ b)\nРезультат выполнения кода с использованием этой функции применительно к задаче о шарнирно опёртой балке с неполным набором граничных условий будет выглядеть так:\nПеремещения (Тихонов): [-0.     0.     0.002  0.     0.459  0.     0.    -0.    -0.     0.\n  0.    -0.002]\nПрогиб u_2y (Тихонов): 0.4586 мм\nАналогом такого подхода является, сюрприз-сюрприз, использование «мягких пружин», опция использования которых имеется в ANSYS. Отличие «мягких пружин» заключается в том, что вместо добавления \\(λ \\cdot I\\) ко всей диагонали создаётся матрица \\(K_{s}\\), в которой малые величины \\(k_{s}\\) добавляются только к определённым элементам исходной матрицы \\(K\\), а модифицированная система выглядит как \\((K + K_{s}) \\cdot x = f\\). Это больше подходит к реальной физике: в балке стабилизируются только те узлы или направления, у которых нет жёстких граничных условий. Вернёмся к нашему примеру:\n\\[\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n5 & 7 & 9\n\\end{bmatrix}\n\\cdot\nx=\n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 3\n\\end{bmatrix}\n\\]\nФормируем \\(K_{s}\\) таким образом, чтобы стабилизировать \\(х_3\\):\n\\[\nK_{s}=\n\\begin{bmatrix}\n0 & 0 & 0 \\\\\n0 & 0 & 0 \\\\\n0 & 0 & 0,000001\n\\end{bmatrix}\n\\]\nТогда:\n\n\\[\nK + K_{s} =\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n5 & 7 & 9\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n0 & 0 & 0 \\\\\n0 & 0 & 0 \\\\\n0 & 0 & 0,000001\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n5 & 7 & 9,000001\n\\end{bmatrix}\n\\]\n\nОтсюда, решая систему \\((K + K_{s}) \\cdot x = f\\), получим:\n\\[\nx=\n\\begin{bmatrix}\n-0,333 \\\\ 0,667 \\\\ 0\n\\end{bmatrix}\n\\]\nЭто частное решение можно получить из полученного ранее решения в общем виде подстановкой \\(t = 0\\):\n\n\\[\nx=\n\\begin{bmatrix}\n-0,333 + t \\\\ 0,667 - 2 \\cdot t \\\\ t\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-0,333 + 0 \\\\ 0,667 - 2 \\cdot 0 \\\\ 0\n\\end{bmatrix}\n\\begin{bmatrix}\n-0,333 \\\\ 0,667 \\\\ 0\n\\end{bmatrix}\n\\]\n\nПроверка результата подстановкой в \\(K \\cdot х\\) даёт:\n\\[\nK \\cdot x =\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n5 & 7 & 9\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n-0,333 \\\\ 0,667 \\\\ 0\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 3\n\\end{bmatrix}\n.\n\\]\nЗаметим, что вектора \\(х\\), полученные с использованием метода Тихонова и «мягких пружин», различаются, что связано с минимизацией нормы вектора \\(х\\) в методе Тихонова. Несмотря на эту разницу, реализуем подход с «мягкими пружинами» в задаче про балку и посмотрим на результат. Нужная для этого функция будет выглядеть следующим образом:\nclass BeamStructure:\n    ...\n    ## Решаем систему: K * u = F, где u - вектор перемещений\n    ## Мягкие пружины\n    global_stab_indices = [3, 4, 5, 15, 16, 17] # theta1x, theta1y, theta1z, theta3x, theta3y, theta3z в k_global\n    u_red_spring = None\n    try:\n        u_red_spring = spring_solve(k_red, f_red, global_stab_indices, free_dofs)\n        if u_red_spring is None:  # Если сингулярна, выходим из цикла\n            raise np.linalg.LinAlgError(\"Сингулярность осталась\")\n    except np.linalg.LinAlgError:\n        time_spring = 0.0\ndef spring_solve(K: np.ndarray, f: np.ndarray, global_spring_indices: List[int], free_dofs: List[int],\n                 epsilon_factor: float = 1e-6) -&gt; np.ndarray:\n    \"\"\"\n    Решает систему с \"мягкими пружинами\" на заданных глобальных индексах, учитывая свободные степени.\n    Args:\n        K (np.ndarray): Ред. матрица жёсткости (n x n).\n        f (np.ndarray): Ред. вектор сил (n).\n        global_spring_indices (List[int]): Глобальные индексы для пружин (в K_global).\n        free_dofs (List[int]): Свободные степени свободы (глобальные индексы).\n        epsilon_factor (float): Фактор масштабирования жёсткости.\n    Returns:\n        NDArray | None: Решение x или None, если матрица сингулярна.\n    \"\"\"\n    K_stab = K.copy()\n    n = len(free_dofs)\n    # Базовая жёсткость из K_red\n    k_base = K[2, 2] if abs(K[2, 2]) &gt; 1e-10 else np.mean(np.diag(K))\n    epsilon = epsilon_factor * k_base\n    # Переводим глобальные индексы в локальные для K_red\n    stab_indices = [free_dofs.index(idx) for idx in global_spring_indices if idx in free_dofs]\n    # Добавляем жёсткость только к активным индексам\n    for idx in stab_indices:\n        K_stab[idx, idx] += epsilon\n    # Пробуем решить с обработкой сингулярности\n    try:\n        return np.linalg.solve(K_stab, f)\n    except np.linalg.LinAlgError:\n        print(f\"spring_solve: матрица сингулярна, стабилизация не помогла (активные индексы: {stab_indices})\")\n        return None\nРезультат выполнения кода с использованием этой функции применительно к задаче о шарнирно опёртой балке с неполным набором граничных условий будет выглядеть так:\nПеремещения (мягкие пружины): [ 0.000e+00  0.000e+00  2.292e-03  0.000e+00  4.586e-01 -0.000e+00\n  0.000e+00  0.000e+00  1.699e-19  0.000e+00  0.000e+00 -2.292e-03]\nПрогиб u_2y (мягкие пружины): 0.4586 мм\nПо результатам выполнения двух вариантов кода получилась одинаковая величина прогиба в центре балки при, в целом, различных векторах перемещений. Разница проявляется в «свободных» степенях свободы, в то время как перемещение в точке приложения нагрузки мало зависит от конкретного частного решения, если «стабилизирующие параметры» достаточно малы.\nТеперь самое время вспомнить первоначальный вопрос, заданный сообществу господином Ш., в котором упоминались «мягкие пружины», не оказавшие должного эффекта. Для начала взглянем на эти самые пружины – загрузим нашу балку в классический интерфейс ANSYS. На рисунке 9 представлен результат этого действия – видно, что к узлам, на которые наложены силовые и кинематические граничные условия добавилось три пружинки. На всякий случай, проверим, действительно ли задача не считается, ведь пружины мы видим и, теоретически, они должны способствовать решению. Результат приведён на рисунке 10 – не считается и предупреждает об отсутствии недостающего закрепления по углу поворота вокруг оси балки.\n\n\n\nРисунок 9 - Модель балки с «мягкими пружинами»\n\n\n\n\n\nРисунок 10 - Результат попытки решить задачу о шарнирно опёртой балке с «мягкими пружинами» в ANSYS\n\n\nНемного покопавшись в исходных данных, заметим, что «мягкие пружины» представляют собой элементы типа COMBIN14 (рисунок 11), которые, по умолчанию, работают только в продольном направлении на «растяжение-сжатие». Так как с линейными перемещениями у нас всё в порядке и дополнительные ограничения по их направлениям нам не нужны, поменяем принцип работы «мягких пружин» (рисунок 12) и проверим, запустится ли задача в таком случае.\n\n\n\nРисунок 11 - Объяснение неудачи при решении задачи о шарнирно опёртой балке с «мягкими пружинами» в ANSYS\n\n\n\n\n\nРисунок 12 - Смена поведения «мягких пружин» в ANSYS\n\n\nПосле смены «поведения» «мягких пружин» наша тестовая задача решилась без каких либо проблем, что представлено на рисунке 13. Максимальный прогиб в центре составил 0,459607 мм.\n\n\n\nРисунок 13 - Результат решения задачи о шарнирно опёртой балке с «мягкими пружинами» в ANSYS с учётом смены «поведения» пружин\n\n\n\nК этому моменту мы наконец-то можем сделать ещё один вывод: ANSYS при настройках по умолчанию пытается решить задачу через один из классических методов, связанных с разложением исходной матрицы \\(K\\). При включении опции «мягких пружин» ANSYS добавляет малые жёсткости к узлам, к которым приложены граничные условия (что соответствует выборочному добавлению малых величин к элементам матрицы жёсткости, как было рассмотрено выше). По умолчанию эти пружины соответствуют линейным перемещениям, но поскольку мы уже в явном виде ограничили перемещения в этих узлах, то они просто «вычёркиваются» из полной матрицы жёсткости и не оказывают влияния на «редуцированную» матрицу жёсткости. При смене «поведения» «мягких пружин» задача решается так же, как и в написанном ранее коде.\n\n\n\n2.5.3 Методы, редуцирующие исходную систему\nДля простоты восприятия, к разобранным в этом разделе методам можно применить следующую аналогию: в конце бурной попойки вам надлежит последовательно раздать своим 12 (как степеней свободы в балочном элементе) друзьям 1 большой пирог. Вот они все 12 перед вами выстроились. Однако один из друзей, в серединке, уже в совершенно невменяемом состоянии и портит делёжку. Поэтому вы перемещаете этого неадеквата в конец очереди, все нормальные друзья получают свой кусочек пирога, а перебравшему обрыгану вы говорите: «Сиди тихо, тебе 0».\n\n2.5.3.1 QR-разложение\nРешение системы \\(K \\cdot x = f\\) ищется путём разложения матрицы \\(K\\) на две части таким образом, что \\(K = Q \\cdot R\\), где \\(Q\\) – ортогональная, \\(R\\) – верхнетреугольная. Зачем опять что-то раскладывать? А вот зачем: после разложения исходная система \\(K \\cdot x = f\\) преобразуется в систему \\(Q \\cdot R \\cdot x = f\\), а результат находится из решения системы \\(R \\cdot x = Q \\cdot T \\cdot f\\), которая примет вид «лесенки» (так как \\(R\\) – верхнетреугольная). Если исходная матрица \\(K\\) – вырожденная, то «лишние» элементы просто откидываем и ищем решение для того, что осталось. Уже знакомая нам система имеет вид:\n\\[\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n5 & 7 & 9\n\\end{bmatrix}\n\\cdot\nx=\n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 3\n\\end{bmatrix}\n\\]\nВ результате разложения (можно опять прикинуть в маткаде) получим:\n\n\\[\nQ=\n\\begin{bmatrix}\n-0,154 & 0,802 & -0,577 \\\\\n-0,617 & -0,535 & -0,577 \\\\\n-0,772 & 0,267 & 0,577\n\\end{bmatrix}\n,~R=\n\\begin{bmatrix}\n-6,481 & -8,795 & -11,11 \\\\\n0 & 0,802 & 1,604 \\\\\n0 & 0 & 0\n\\end{bmatrix}\n\\]\n\nПо числу ненулевых элементов на диагонали матрицы \\(R\\) делаем несложный вывод о ранге матрицы, который равен двум. Вычисляем \\(Q^{T} \\cdot f\\):\n\n\\[\nQ^{T} \\cdot f =\n\\begin{bmatrix}\n-0,154 & -0,617 & -0,772 \\\\\n0,802 & -0,535 & 0,267 \\\\\n-0,577 & -0,577 & 0,577\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 3\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-3,704 \\\\ 0,533 \\\\ 0\n\\end{bmatrix}\n.\n\\]\n\nТак как ранг равен двум, то берём первые 2 строки и первые 2 столбца и решаем систему для усечённой части \\(R_{red} \\cdot x = (Q^{T} \\cdot f)_{red}\\):\n\\[\n\\begin{bmatrix}\n-6,481 & -8,795 \\\\\n0 & 0,802\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\nx_{1} \\\\ x_{2}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-3,704 \\\\ 0,533\n\\end{bmatrix}\n\\]\nВ результате получаем:\n\\[\nx_{red}=\n\\begin{bmatrix}\n-0,331 \\\\ 0,665\n\\end{bmatrix}\n\\]\nОтбрасывание «лишних» элементов соответствует нулевому решению, и «полный» вектор \\(х\\) будет выглядеть как:\n\\[\nx=\n\\begin{bmatrix}\n-0,331 \\\\ 0,665 \\\\ 0\n\\end{bmatrix}\n\\]\nПолученное таким образом решение неплохо соотносится с решением, полученным с использованием «мягких пружин».\nПрименим рассмотренный подход к задаче с балкой. Нужная для этого функция будет выглядеть следующим образом:\ndef qr_solve(K: np.ndarray, f: np.ndarray, tol: float = 1e-10) -&gt; NDArray:\n    \"\"\"\n    Решает систему через QR-разложение с выбором ранга.\n    Args:\n        K (np.ndarray): Матрица жёсткости (n x n).\n        f (np.ndarray): Вектор сил (n).\n        tol (float): Порог для определения ранга.\n    Returns:\n        NDArray: Решение x.\n    \"\"\"\n    # QR-разложение с поворотами\n    Q, R, P = linalg.qr(K, pivoting=True)\n    rank = sum(abs(np.diag(R)) &gt; tol)  # Определяем ранг\n    # Решаем усечённую систему\n    Qb = Q.T @ f\n    R_red = R[:rank, :rank]\n    Qb_red = Qb[:rank]\n    # Обратная подстановка для усечённой части\n    x_red = np.linalg.solve(R_red, Qb_red)\n    # Восстанавливаем полный вектор x с учётом перестановок\n    x = np.zeros(len(f))\n    x[P[:rank]] = x_red\n\n    return x\nРезультат выполнения кода с использованием этой функции применительно к задаче о шарнирно опёртой балке с неполным набором граничных условий будет выглядеть так:\nПеремещения (QR): [-2.370e-19  7.596e-17  2.292e-03 -1.315e-18  4.586e-01 -1.518e-14\n -7.884e-20 -3.475e-20 -1.514e-19  0.000e+00 -7.586e-17 -2.292e-03]\nПрогиб u_2y (QR): 0.4586 мм\nСаксес!\n\n\n2.5.3.2 PARDISO\nPARDISO – это прямой решатель для разреженных систем вида \\(K \\cdot x = f\\), запускаемый по умолчанию в ABAQUS, OptiStruct и ЛОГОС. PARDISO использует перестановки и для симметричных матриц – \\(LDL^{T}\\)-разложение, для несимметричных матриц – \\(LU\\)-разложение, приходя таким образом к виду:\n\\[\nP_{L} \\cdot K \\cdot P_{R} = L \\cdot U~{\\text{(для случая с несимметричной матрицей)}},\n\\]\nгде \\(P_L\\) – матрица перестановки строк, \\(P_R\\) – матрица перестановки столбцов. После преобразований последовательно решаем несколько систем: сначала \\(L \\cdot y = P_L \\cdot f\\), потом \\(U \\cdot z = y\\) и окончательно \\(x = P_R \\cdot z\\). Для вырожденной матрицы таким образом можно получить некоторое частное решение, например, приравняв «лишнюю» неизвестную к нулю, аналогично решению через \\(QR\\)-разложение.\nПоехали смотреть на нашу «тестовую» систему:\n\\[\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n5 & 7 & 9\n\\end{bmatrix}\n\\cdot\nx=\n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 3\n\\end{bmatrix}\n\\]\nПереставляем строки (меняем местами 1-ю и 3-ю строки, как уже делали ранее), а столбцы оставляем как есть (то есть $P_R = I). Получим:\n\n\\[\nP_L =\n\\begin{bmatrix}\n0 & 0 & 1 \\\\\n0 & 1 & 0 \\\\\n1 & 0 & 0\n\\end{bmatrix}\n,~P_L \\cdot K =\n\\begin{bmatrix}\n0 & 0 & 1 \\\\\n0 & 1 & 0 \\\\\n1 & 0 & 0\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n5 & 7 & 9\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n5 & 7 & 9 \\\\\n4 & 5 & 6 \\\\\n1 & 2 & 3\n\\end{bmatrix}\n.\n\\]\n\nLU-разложение для матрицы даст уже знакомый результат:\n\\[\nL =\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0,8 & 1 & 0 \\\\\n0,2 & -1 & 1\n\\end{bmatrix}\n,~U =\n\\begin{bmatrix}\n5 & 7 & 9 \\\\\n0 & -0,6 & -1,2 \\\\\n0 & 0 & 0\n\\end{bmatrix}\n.\n\\]\nА дальше просто топаем по алгоритму, находим \\(P_L \\cdot f\\):\n\\[\nP_L \\cdot f =\n\\begin{bmatrix}\n0 & 0 & 1 \\\\\n0 & 1 & 0 \\\\\n1 & 0 & 0\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 3\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n3 \\\\ 2 \\\\ 1\n\\end{bmatrix}\n\\]\nРешая систему \\(L \\cdot y = P_L \\cdot f\\):\n\\[\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0,8 & 1 & 0 \\\\\n0,2 & -1 & 1\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\ny_1 \\\\ y_2 \\\\ y_3\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n3 \\\\ 2 \\\\ 1\n\\end{bmatrix}\n\\]\nПолучаем следующий результат:\n\\[\ny =\n\\begin{bmatrix}\n3 \\\\ -0,4 \\\\ 0\n\\end{bmatrix}\n\\]\nА решая систему \\(U \\cdot z = y\\):\n\\[\n\\begin{bmatrix}\n5 & 7 & 9 \\\\\n0 & -0,6 & -1,2 \\\\\n0 & 0 & 0\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\nz_1 \\\\ z_2 \\\\ z_3\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n3 \\\\ -0,4 \\\\ 0\n\\end{bmatrix}\n\\]\nПолучаем следующий результат (приравнивая «лишнюю» неизвестную \\(z_3\\) к нулю):\n\\[\nz =\n\\begin{bmatrix}\n-0,333 \\\\ 0,667 \\\\ 0\n\\end{bmatrix}\n.\n\\]\nОкончательно имеем:\n\\[\nx = P_R \\cdot z =\n\\begin{bmatrix}\n-0,333 \\\\ 0,667 \\\\ 0\n\\end{bmatrix}\n.\n\\]\nЭтот результат мы уже неоднократно получали ранее, он представляет собой одно из многочисленных частных решений.\nПрименим рассмотренный подход к задаче с балкой. Нужная для этого функция будет выглядеть следующим образом:\ndef pardiso_solve(K: np.ndarray, f: np.ndarray) -&gt; NDArray:\n    \"\"\"\n    Решает Kx = f через PARDISO для симметричных матриц.\n    Args:\n        K (np.ndarray): Симметричная матрица жёсткости (n x n).\n        f (np.ndarray): Вектор сил (n).\n    Returns:\n        NDArray: Решение x.\n    \"\"\"\n    # Преобразуем K в разреженный формат CSR\n    K_sparse = csr_matrix(K)\n\n    # Решаем систему через PARDISO\n    try:\n        x = spsolve(K_sparse, f)\n        residual = K @ x - f\n        print(f\"Невязка PARDISO: {np.linalg.norm(residual):.2e}\")\n    except Exception as e:\n        print(f\"PARDISO упал с ошибкой: {e}\")\n        x = np.full_like(f, np.nan)\n\n    return x\nРезультат выполнения кода с использованием этой функции применительно к задаче о шарнирно опёртой балке с неполным набором граничных условий будет выглядеть так:\nПеремещения (PARDISO): [ 0.000e+00  0.000e+00  2.292e-03  0.000e+00  4.586e-01  0.000e+00\n  0.000e+00  0.000e+00  4.113e-23  0.000e+00  0.000e+00 -2.292e-03]\nПрогиб u_2y (PARDISO): 0.4586 мм\nИ опять получилась знакомая (и верная, что немаловажно) величина прогиба в 0,4586 мм.\n\n\n2.5.3.3 MUMPS\nИспользуемый по умолчанию в COMSOL решатель MUMPS (MUltifrontal Massively Parallel Sparse direct Solver) – прямой решатель, работающий с \\(LU\\) или \\(LDL^{T}\\) разложением для разреженных систем. Делает то же, что и PARDISO, но с акцентом на параллелизм и большие системы.\nВот тут то и случился у меня праздник сердца. После возни с доступными опциями оказалось, что MUMPS в зависимости от тонких настроек решателя позволяет для нашей тестовой матрицы получить неприлично большое количество частных решений (которые сведены в таблицу 2), показывающих слабую корреляцию к конкретным настройкам. Поскольку обычно эти настройки «лежат» в недосягаемом для пользователя «чёрном ящике» программного комплекса, то трудно сказать, чем должен руководствоваться пользователь при оценке адекватности полученного решения в случае с практически значимой задачей. Тейк в том, что лучше всё таки ставить полный набор граничных условий, не приводящий к «пляскам с бубном».\n\n\n\nTable 2: Таблица 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nICNTL(6)\nICNTL(7)\nICNTL(8)\nICNTL(24)\n\\(x_1\\)\n\\(x_2\\)\n\\(x_3\\)\nResidual\n\n\n\n\n0\n0\n0\n0\n0\n0\n0,333\n0\n\n\n0\n0\n0\n1\n0\n0\n0,333\n0\n\n\n0\n0\n7\n0\n-0,301\n0,603\n0,032\n4,58E-16\n\n\n0\n0\n8\n0\n-0,203\n0,406\n0,130\n5,44E-16\n\n\n0\n6\n1\n0\n-0,112\n0,224\n0,222\n0\n\n\n0\n6\n3\n0\n0,286\n-0,571\n0,619\n4,58E-16\n\n\n0\n6\n4\n0\n-0,286\n0,571\n0,048\n6,66E-16\n\n\n0\n6\n7\n0\n-0,524\n1,047\n-0,190\n9,16E-16\n\n\n0\n6\n7\n1\n0\n0\n0,333\n6,66E-16\n\n\n0\n6\n8\n0\n-0,156\n0,313\n0,177\n4,44E-16\n\n\n2\n0\n0\n0\n-0,333\n0,667\n0\n0\n\n\n2\n0\n1\n0\n-0,622\n1,244\n-0,289\n4,44E-16\n\n\n2\n0\n1\n1\n-0,333\n0,667\n0\n4,44E-16\n\n\n2\n0\n3\n0\n-0,067\n0,133\n0,267\n0\n\n\n2\n0\n4\n0\n-0,167\n0,333\n0,167\n4,97E-16\n\n\n2\n0\n7\n0\n-0,300\n0,599\n0,034\n9,42E-16\n\n\n2\n0\n8\n0\n-0,183\n0,366\n0,150\n5,44E-16\n\n\n4\n0\n7\n0\n-0,288\n0,576\n0,045\n6,66E-16\n\n\n4\n0\n7\n1\n0\n0\n0,333\n8,01E-16\n\n\n4\n0\n8\n0\n-0,213\n0,425\n0,121\n2,48E-16\n\n\n4\n6\n3\n0\n0,533\n-1,067\n0,867\n1,12E-15\n\n\n4\n6\n4\n0\n-0,356\n0,711\n-0,022\n8,95E-16\n\n\n4\n6\n7\n0\n-0,053\n0,107\n0,280\n0\n\n\n4\n6\n8\n0\n-0,780\n1,560\n-0,446\n2,32E-15\n\n\n5\n0\n0\n0\n0,188\n-0,375\n0,521\n4,58E-16\n\n\n5\n0\n1\n0\n-0,255\n0,509\n0,079\n4,58E-16\n\n\n5\n0\n3\n0\n0,302\n-0,603\n0,635\n4,44E-16\n\n\n5\n0\n4\n0\n-0,133\n0,267\n0,200\n2,22E-16\n\n\n5\n0\n7\n0\n-0,507\n1,014\n-0,174\n9,16E-16\n\n\n5\n0\n8\n0\n-0,352\n0,704\n-0,019\n4,44E-16\n\n\n5\n0\n77\n0\n-0,111\n0,222\n0,222\n1,11E-16\n\n\n5\n6\n1\n0\n-0,189\n0,378\n0,144\n4,97E-16\n\n\n5\n6\n77\n0\n-0,250\n0,500\n0,083\n9,99E-16\n\n\n6\n0\n77\n0\n-0,074\n0,148\n0,259\n2,22E-16\n\n\n\n\n\n\nПрименим этот подход к задаче с балкой. Нужная функция будет выглядеть следующим образом:\ndef mumps_solve(K: np.ndarray, f: np.ndarray) -&gt; NDArray:\n    \"\"\"\n    Решает систему через MUMPS без стабилизации.\n    Args:\n        K (np.ndarray): Матрица жёсткости (n x n).\n        f (np.ndarray): Вектор сил (n).\n    Returns:\n        NDArray: Решение x.\n    \"\"\"\n    K_sparse = csr_matrix(K)\n    solver = DMumpsContext()\n    # Включаем вывод для диагностики\n    solver.set_icntl(1, 6)     # Вывод ошибок\n    solver.set_icntl(3, 6)     # Глобальная информация\n    solver.set_icntl(4, 1)     # Уровень вывода (1 — только ошибки)\n\n    solver.set_icntl(7, 5)     # METIS для упорядочения\n    solver.set_icntl(14, 100)  # Максимум памяти\n    solver.set_icntl(24, 1)    # Обнаружение вырожденности\n    solver.set_icntl(25, 0)    # По умолчанию\n\n    f_copy = f.copy()   # копируем f, чтобы не портить оригинал, а то потом хер найдёшь ошибку\n    solver.set_centralized_sparse(K_sparse)\n    solver.set_rhs(f_copy)\n    try:\n        solver.run(job=1)  # Анализ\n        print(\"Анализ прошёл\")\n        solver.run(job=2)  # Факторизация\n        print(\"Факторизация прошла\")\n        solver.run(job=3)  # Решение\n        print(\"Решение найдено\")\n        x = f_copy    # f_copy теперь содержит решение\n        residual = K @ x - f    # Считаем невязку с исходным f\n        print(f\"Невязка MUMPS: {np.linalg.norm(residual):.2e}\")\n    except RuntimeError as e:\n        print(f\"MUMPS упал с ошибкой: {e}\")\n        x = np.full_like(f, np.nan)\n    finally:\n        solver.destroy()\n    return x\nИли, если отвязаться от настроек MUMPS и выполнить часть операций вручную:\ndef mumps_like_lu_solve(K: np.ndarray, f: np.ndarray) -&gt; NDArray:\n    \"\"\"\n    Решает Kx = f через LU с RCM, как MUMPS для несимметричных матриц.\n    Args:\n        K (np.ndarray): Матрица жёсткости (n x n).\n        f (np.ndarray): Вектор сил (n).\n    Returns:\n        NDArray: Частное решение x, совместимое с f.\n    \"\"\"\n    # Упорядочение RCM\n    K_sparse = csr_matrix(K)\n    perm = reverse_cuthill_mckee(K_sparse, symmetric_mode=True)   # симметричная матрица\n    print(f\"Перестановка perm = {perm}\")\n    # Перестановка k_red и f_red\n    K_perm = K[np.ix_(perm, perm)]\n    f_perm = f[perm]\n    # LU-разложение\n    P, L, U = lu(K_perm)\n    # Прямая подстановка: L y = P F_perm\n    PF_perm = P @ f_perm\n    y = np.linalg.solve(L, PF_perm)\n    # Обратная подстановка U u_perm = y\n    n = len(U)\n    x_perm = np.zeros(n)\n    tol = 1e-10\n    for i in range(n-1, -1, -1):\n        if abs(U[i, i]) &lt; tol:\n            if abs(y[i]) &lt; tol:\n                x_perm[i] = 0\n            else:\n                raise ValueError(f\"Система несовместима на шаге {i}\")\n        else:\n            x_perm[i] = (y[i] - np.dot(U[i, i+1:], x_perm[i+1:])) / U[i, i]\n    # Обратная перестановка\n    x_red = np.zeros(n)\n    for i, p in enumerate(perm):\n        x_red[p] = x_perm[i]\n    return x_red\nРезультат выполнения кода с использованием этих функций применительно к задаче о шарнирно опёртой балке с неполным набором граничных условий будет выглядеть так:\nПеремещения (MUMPS): [ 0.000e+00  0.000e+00  2.292e-03  0.000e+00  4.586e-01  0.000e+00\n  0.000e+00  0.000e+00  1.440e-19  0.000e+00  0.000e+00 -2.292e-03]\nПрогиб u_2y (MUMPS): 0.4586 мм\nПеремещения (LU): [ 0.000e+00 -0.000e+00  2.292e-03  0.000e+00  4.586e-01  0.000e+00\n  0.000e+00  0.000e+00 -2.028e-20  0.000e+00  0.000e+00 -2.292e-03]\nПрогиб u_2y (LU): 0.4586 мм\n\nВ обоих рассмотренных случаях получилась верная величина прогиба балки 0,4586 мм."
  },
  {
    "objectID": "balka.html#вывод",
    "href": "balka.html#вывод",
    "title": "Разбор задачи о шарнирно опёртой балке с «неполным» набором граничных условий",
    "section": "Вывод",
    "text": "Вывод\n\nКакие выводы мы можем сделать из проведённых расчётов несчастной балочки с использованием прямых методов:\n\nANSYS и NASTRAN с настройками по умолчанию требуют задания полного набора граничных условий, позволяющего получить однозначное «честное» решение.\nПрименение «мягких пружин», позволяет устранить вырожденность матрицы жёсткости при неполном наборе граничных условий и получить близкое к «честному» решение (если их жёсткость и в самом деле невелика), однако стоит ясно представлять себе, что за «пружины» вы используете (как в примере с ANSYS).\nТакие программные комплексы как COMSOL, ABAQUS, OptiStruct и ЛОГОС позволяют получить решение при неполном наборе граничных условий, так как заложенные алгоритмы с помощью перестановок и разложений приводят к получению некоторого частного решения. В рассмотренном случае с балкой, полученные таким образом решения, оказались достаточно близки к точному. Тем не менее, для тестовой матрицы при использовании алгоритма MUMPS был получен целый набор частных решений, в зависимости от настроек решателя, которые пользователю не всегда доступны. Таким образом, применение полного набора граничных условий, независимо от используемого алгоритма, лишает нас неопределённости при интерпретации результатов.\nХвалёный ABAQUS выдал решение, отличающееся на 7% от эталонного. Но так как в повседневной жизни я его не использую и достаю из пыльного ящика только в случае каких-то тестов для кроссверификации, и с первоначальным вопросом это расхождение имеет мало общего, то и ковырять его дальше мне лениво.\nНаверняка какие-то математики напихают мне панамку того, чего напихивают целую панамку, зато вышло довольно доходчиво.\nИтоговый код, реализующий все рассмотренные подходы, представлен ниже:\n\nimport numpy as np\nfrom numpy.typing import NDArray    ## Тип для массивов NumPy\nfrom typing import Tuple, List      ## Типы для подсказок, что возвращают функции\nfrom scipy import linalg\n## импорт для MUMPS-like реализации\nfrom scipy.linalg import lu\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import reverse_cuthill_mckee\n## импорт для MUMPS (е**я кочергой)\nfrom mumps import DMumpsContext\n## импорт для PARDISO\nfrom pypardiso import spsolve  # Основная функция для решения\n## теперь можно и время померять\nimport time\nfrom functools import wraps\n\ndef measure_time(func):\n    \"\"\"Декоратор для замера времени выполнения функции.\"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start = time.perf_counter()\n        result = func(*args, **kwargs)\n        elapsed = time.perf_counter() - start\n        print(\"*************************************\")\n        print(\"*************************************\")\n        print(f\"{func.__name__} time: {elapsed:.6f} с\")\n        return result\n    return wrapper\n\n@measure_time\ndef my_solve(A: np.ndarray, b: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Решение системы уравнений А * х = b методом Гаусса с частичным выбором ведущего элемента\n    Args:\n         A(np.ndarray): Квадратная матрица (n x n)\n         b(np.ndarray): Вектор правой части (n)\n    Returns:\n        np.ndarray: Вектор решения х (n)\n    Raises:\n        ValueError: Если матрица не квадратная или вырожденная (детерминант ≈ 0)\n    \"\"\"\n\n    ## Размер системы - число уравнений (и переменных)\n    n = len(b)\n    ## Проверяем, что матрица квадратная и соответствует вектору b\n    if A.shape != (n, n):\n        raise ValueError(\"Матрица А должна быть квадратной и соответствовать b!\")\n    ## Копируем А и b, чтобы не менять оригиналы (работаем с копиями)\n    A = A.copy()\n    b = b.copy()\n    ## Прямой ход: превращаем А в верхнетреугольную матрицу (нули под диагональю)\n    for i in range(n):\n        ## Ищем ведущий элемент (pivot) - самый большой по модулю в столбце i...\n        max_idx = i ## ...начинаем с текущей строки...\n        for k in range(i+1, n):     ## ...и смотрим все строки ниже\n            if abs(A[k, i]) &gt; abs(A[max_idx, i]):\n                max_idx = k     ## Запоминаем строку с максимальным элементом\n        ## Проверяем, не слишком ли маленький pivot (если ≈ 0, матрица вырожденная)\n        pivot = A[max_idx, i]\n        if abs(pivot) &lt; 1e-10:      ## 1e-10 — порог для учёта ошибок округления\n            raise ValueError(f\"Матрица вырожденна на шаге {i}!\")\n        ## Если нашли больший элемент ниже, меняем строки местами\n        if max_idx != i:\n            A[[i, max_idx]] = A[[max_idx, i]]       ## Меняем строки в матрице A\n            b[i], b[max_idx] = b[max_idx], b[i]     ## Меняем элементы в векторе b\n        ## Делаем ведущий элемент равным 1: делим строку i на pivot\n        A[i, :] = A[i, :] / pivot\n        b[i] = b[i] / pivot\n        ## Убираем элементы под ведущим элементом (делаем нули в столбце i)\n        for j in range(i + 1, n):                   ## Проходим по строкам ниже текущей\n            factor = A[j, i]                        ## Коэффициент, на который умножаем строку i\n            A[j, :] = A[j, :] - factor * A[i, :]    ## Вычитаем, чтобы обнулить A[j, i]\n            b[j] = b[j] - factor * b[i]             ## То же для правой части\n    ## Обратный ход: решаем систему снизу вверх, начиная с последнего уравнения\n    x = np.zeros(n)                         ## Создаём вектор для хранения решения\n    for i in range(n-1, -1, -1):            ## Идём от последней строки к первой\n        x[i] = b[i]                         ## Берём правую часть текущего уравнения\n        # Вычитаем все уже найденные переменные (x[j] для j &gt; i)\n        for j in range(i+1, n):\n            x[i] = x[i] - A[i, j] * x[j]    ## Учитываем влияние верхних элементов\n    return x\n\ndef plu_decomposition(A: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Выполняет PLU-разложение матрицы A на P (перестановки), L (нижнетреугольная), U (верхнетреугольная).\n      Args:\n        A (np.ndarray): Квадратная матрица (n x n).\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray]: Матрицы P, L, U.\n    Raises:\n        ValueError: Если матрица не квадратная.\n    \"\"\"\n\n    n = A.shape[0]\n    if A.shape[0] != A.shape[1]:\n        raise ValueError(\"Матрица должна быть квадратной!\")\n    ## Копируем А\n    A = A.copy()\n    ## Инициализируем P (единичная матрица), L и U\n    P = np.eye(n)  ## Матрица перестановок начинается как единичная\n    L = np.zeros((n, n))\n    U = np.zeros((n, n))\n    np.fill_diagonal(L, 1)  # Единицы на диагонали L\n    # Разложение с перестановками\n    for i in range(n):\n        # Ищем максимальный элемент в столбце i от i до конца\n        max_idx = i\n        for k in range(i + 1, n):\n            if abs(A[k, i]) &gt; abs(A[max_idx, i]):\n                max_idx = k\n        # Если нужно, меняем строки в A и P\n        if max_idx != i:\n            A[[i, max_idx]] = A[[max_idx, i]]\n            P[[i, max_idx]] = P[[max_idx, i]]\n            # Исправляем L: меняем строки до i (кроме диагонали)\n            if i &gt; 0:\n                L[[i, max_idx], :i] = L[[max_idx, i], :i]\n        # Заполняем U: элементы на диагонали и выше\n        for j in range(i, n):\n            U[i, j] = A[i, j] - sum(L[i, k] * U[k, j] for k in range(i))\n        # Заполняем L: элементы под диагональю\n        for j in range(i + 1, n):\n            if abs(U[i, i]) &lt; 1e-10:\n                raise ValueError(f\"Деление на ноль на шаге {i}!\")\n            L[j, i] = (A[j, i] - sum(L[j, k] * U[k, i] for k in range(i))) / U[i, i]\n    return P, L, U\n\n@measure_time\ndef plu_solve(A: np.ndarray, b: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n     Решает систему A * x = b с помощью PLU-разложения.\n     Args:\n         A (np.ndarray): Квадратная матрица (n x n).\n         b (np.ndarray): Вектор правой части (n).\n     Returns:\n         np.ndarray: Вектор решения x (n).\n     \"\"\"\n    # Получаем P, L, U\n    P, L, U = plu_decomposition(A)\n    n = len(b)\n    b = b.copy()\n    # Применяем перестановки к b: Pb = P * b\n    Pb = P @ b\n    # Прямой ход: решаем L * y = Pb\n    y = np.zeros(n)\n    for i in range(n):\n        y[i] = Pb[i] - sum(L[i, j] * y[j] for j in range(i))\n    # Обратный ход: решаем U * x = y\n    x = np.zeros(n)\n    for i in range(n - 1, -1, -1):\n        if abs(U[i, i]) &lt; 1e-10:\n            raise ValueError(f\"Деление на ноль в U на шаге {i}!\")\n        x[i] = (y[i] - sum(U[i, j] * x[j] for j in range(i + 1, n))) / U[i, i]\n    return x\n\n@measure_time\ndef svd_solve(A: np.ndarray, b: np.ndarray, tol: float = 1e-10) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Решает вырожденную систему через SVD, возвращая частное решение и базис ядра.\n    Args:\n        A (np.ndarray): Матрица (n x n).\n        b (np.ndarray): Вектор правой части (n).\n        tol (float): Порог для обрезки сингулярных значений.\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: Частное решение x_p и базис ядра (столбцы).\n    \"\"\"\n    U, Sigma, Vt = np.linalg.svd(A)\n    n = len(b)\n\n    # Частное решение\n    Sigma_plus = np.zeros((n, n))\n    rank = 0\n    for i in range(n):\n        if Sigma[i] &gt; tol:\n            Sigma_plus[i, i] = 1 / Sigma[i]\n            rank += 1\n    x_p = Vt.T @ Sigma_plus @ U.T @ b\n\n    # Базис ядра (столбцы Vt для нулевых Sigma)\n    kernel_basis = Vt[rank:].T  # Транспонируем, чтобы столбцы были векторами\n\n    return x_p, kernel_basis\n\n@measure_time\ndef tikhonov_solve(A: np.ndarray, b: np.ndarray, lambda_: float = 1e-6) -&gt; np.ndarray:\n    \"\"\"\n    Решает вырожденную систему через регуляризацию Тихонова: (A^T A + λI) x = A^T b.\n    Args:\n        A (np.ndarray): Матрица (n x n).\n        b (np.ndarray): Вектор правой части (n).\n        lambda_ (float): Параметр регуляризации.\n    Returns:\n        np.ndarray: Решение x.\n    \"\"\"\n    n = len(b)\n    # Решаем уравнение с добавленной регуляризацией\n    return np.linalg.solve(A.T @ A + lambda_ * np.eye(n), A.T @ b)\n\n@measure_time\ndef spring_solve(K: np.ndarray, f: np.ndarray, global_spring_indices: List[int], free_dofs: List[int],\n                 epsilon_factor: float = 1e-6) -&gt; np.ndarray:\n    \"\"\"\n    Решает систему с \"мягкими пружинами\" на заданных глобальных индексах, учитывая свободные степени.\n    Args:\n        K (np.ndarray): Ред. матрица жёсткости (n x n).\n        f (np.ndarray): Ред. вектор сил (n).\n        global_spring_indices (List[int]): Глобальные индексы для пружин (в K_global).\n        free_dofs (List[int]): Свободные степени свободы (глобальные индексы).\n        epsilon_factor (float): Фактор масштабирования жёсткости.\n    Returns:\n        NDArray | None: Решение x или None, если матрица сингулярна.\n    \"\"\"\n    K_stab = K.copy()\n    n = len(free_dofs)\n    # Базовая жёсткость из K_red\n    k_base = K[2, 2] if abs(K[2, 2]) &gt; 1e-10 else np.mean(np.diag(K))\n    epsilon = epsilon_factor * k_base\n    # Переводим глобальные индексы в локальные для K_red\n    stab_indices = [free_dofs.index(idx) for idx in global_spring_indices if idx in free_dofs]\n    # Добавляем жёсткость только к активным индексам\n    for idx in stab_indices:\n        K_stab[idx, idx] += epsilon\n    # Пробуем решить с обработкой сингулярности\n    try:\n        return np.linalg.solve(K_stab, f)\n    except np.linalg.LinAlgError:\n        print(f\"spring_solve: матрица сингулярна, стабилизация не помогла (активные индексы: {stab_indices})\")\n        return None\n\n@measure_time\ndef qr_solve(K: np.ndarray, f: np.ndarray, tol: float = 1e-10) -&gt; NDArray:\n    \"\"\"\n    Решает систему через QR-разложение с выбором ранга.\n    Args:\n        K (np.ndarray): Матрица жёсткости (n x n).\n        f (np.ndarray): Вектор сил (n).\n        tol (float): Порог для определения ранга.\n    Returns:\n        NDArray: Решение x.\n    \"\"\"\n    # QR-разложение с поворотами\n    Q, R, P = linalg.qr(K, pivoting=True)\n    rank = sum(abs(np.diag(R)) &gt; tol)  # Определяем ранг\n    # Решаем усечённую систему\n    Qb = Q.T @ f\n    R_red = R[:rank, :rank]\n    Qb_red = Qb[:rank]\n    # Обратная подстановка для усечённой части\n    x_red = np.linalg.solve(R_red, Qb_red)\n    # Восстанавливаем полный вектор x с учётом перестановок\n    x = np.zeros(len(f))\n    x[P[:rank]] = x_red\n\n    return x\n\n@measure_time\ndef eigen_solve(K: np.ndarray, f: np.ndarray, tol: float = 1e-10) -&gt; NDArray:\n    \"\"\"\n    Решает систему через анализ собственных значений, убирая нулевые моды.\n    Args:\n        K (np.ndarray): Матрица жёсткости (n x n).\n        f (np.ndarray): Вектор сил (n).\n        tol (float): Порог для нулевых собственных значений.\n    Returns:\n        NDArray: Решение x.\n    \"\"\"\n    # Собственные значения и векторы\n    eigenvalues, eigenvectors = np.linalg.eigh(K)\n\n    # Определяем \"жёсткие\" моды\n    active_modes = eigenvalues &gt; tol\n    Lambda_red = np.diag(eigenvalues[active_modes])\n    V_red = eigenvectors[:, active_modes]\n\n    # Решаем в сокращённом базисе: V_red * Lambda_red * V_red^T * x = f\n    f_red = V_red.T @ f\n    x_red = np.linalg.solve(Lambda_red, f_red)\n\n    # Восстанавливаем полное решение\n    x = V_red @ x_red\n\n    return x\n\n@measure_time\ndef mumps_solve(K: np.ndarray, f: np.ndarray) -&gt; NDArray:\n    \"\"\"\n    Решает систему через MUMPS без стабилизации.\n    Args:\n        K (np.ndarray): Матрица жёсткости (n x n).\n        f (np.ndarray): Вектор сил (n).\n    Returns:\n        NDArray: Решение x.\n    \"\"\"\n    K_sparse = csr_matrix(K)\n    solver = DMumpsContext()\n    # Включаем вывод для диагностики\n    solver.set_icntl(1, 6)     # Вывод ошибок\n    solver.set_icntl(3, 6)     # Глобальная информация\n    solver.set_icntl(4, 1)     # Уровень вывода (1 — только ошибки)\n\n    solver.set_icntl(7, 5)     # METIS для упорядочения\n    solver.set_icntl(14, 100)  # Максимум памяти\n    solver.set_icntl(24, 1)    # Обнаружение вырожденности\n    solver.set_icntl(25, 0)    # По умолчанию\n\n    f_copy = f.copy()   # копируем f, чтобы не портить оригинал, а то потом хер найдёшь ошибку\n    solver.set_centralized_sparse(K_sparse)\n    solver.set_rhs(f_copy)\n    try:\n        solver.run(job=1)  # Анализ\n        print(\"Анализ прошёл\")\n        solver.run(job=2)  # Факторизация\n        print(\"Факторизация прошла\")\n        solver.run(job=3)  # Решение\n        print(\"Решение найдено\")\n        x = f_copy    # f_copy теперь содержит решение\n        residual = K @ x - f    # Считаем невязку с исходным f\n        print(f\"Невязка MUMPS: {np.linalg.norm(residual):.2e}\")\n    except RuntimeError as e:\n        print(f\"MUMPS упал с ошибкой: {e}\")\n        x = np.full_like(f, np.nan)\n    finally:\n        solver.destroy()\n    return x\n\n@measure_time\ndef pardiso_solve(K: np.ndarray, f: np.ndarray) -&gt; NDArray:\n    \"\"\"\n    Решает Kx = f через PARDISO для симметричных матриц.\n    Args:\n        K (np.ndarray): Симметричная матрица жёсткости (n x n).\n        f (np.ndarray): Вектор сил (n).\n    Returns:\n        NDArray: Решение x.\n    \"\"\"\n    # Преобразуем K в разреженный формат CSR\n    K_sparse = csr_matrix(K)\n\n    # Решаем систему через PARDISO\n    try:\n        x = spsolve(K_sparse, f)\n        residual = K @ x - f\n        print(f\"Невязка PARDISO: {np.linalg.norm(residual):.2e}\")\n    except Exception as e:\n        print(f\"PARDISO упал с ошибкой: {e}\")\n        x = np.full_like(f, np.nan)\n\n    return x\n\n@measure_time\ndef mumps_like_lu_solve(K: np.ndarray, f: np.ndarray) -&gt; NDArray:\n    \"\"\"\n    Решает Kx = f через LDLᵀ с RCM, как MUMPS для симметричных матриц.\n\n    Args:\n        K (np.ndarray): Симметричная матрица жёсткости (n x n).\n        f (np.ndarray): Вектор сил (n).\n\n    Returns:\n        NDArray: Частное решение x, совместимое с f.\n    \"\"\"\n    # Упорядочение RCM\n    K_sparse = csr_matrix(K)\n    perm = reverse_cuthill_mckee(K_sparse, symmetric_mode=True)   # симметричная матрица\n    print(f\"Перестановка perm = {perm}\")\n\n    # Перестановка k_red и f_red\n    K_perm = K[np.ix_(perm, perm)]\n    f_perm = f[perm]\n\n    # LU-разложение\n    P, L, U = lu(K_perm)\n\n    # Прямая подстановка: L y = P F_perm\n    PF_perm = P @ f_perm\n    y = np.linalg.solve(L, PF_perm)\n\n    # Обратная подстановка U u_perm = y\n    n = len(U)\n    x_perm = np.zeros(n)\n    tol = 1e-10\n    for i in range(n-1, -1, -1):\n        if abs(U[i, i]) &lt; tol:\n            if abs(y[i]) &lt; tol:\n                x_perm[i] = 0\n            else:\n                raise ValueError(f\"Система несовместима на шаге {i}\")\n        else:\n            x_perm[i] = (y[i] - np.dot(U[i, i+1:], x_perm[i+1:])) / U[i, i]\n\n    # Обратная перестановка\n    x_red = np.zeros(n)\n    for i, p in enumerate(perm):\n        x_red[p] = x_perm[i]\n\n    return x_red\n\nclass BeamStructure:\n    def __init__(self) -&gt; None:\n        \"\"\" Исходные данные к задаче о шарнирно опёртой балке\"\"\"\n        self.L: float = 600.0           ## Длина, мм\n        self.L_e: float = self.L / 2    ## Длина элемента, мм\n        self.E: float = 20000.0         ## Модуль упругости, кгс/мм^2\n        self.G: float = 7692.31         ## Модуль сдвига, кгс/мм^2\n        self.A: float = 78.54           ## Площадь поперечного сечения, мм^2\n        self.Iz: float = 490.874        ## Момент инерции относительно оси z, мм^4\n        self.Iy: float = 490.874        ## Момент инерции относительно оси y, мм^4\n        self.J: float = 2 * self.Iz     ## Полярный момент инерции, мм^4\n        self.k: float = 10/9            ## Коэффициент формы\n        self.F: float = 1.0             ## Сила, кгс\n\n    def calculate_phi(self) -&gt; float:\n        \"\"\" Расчёт коэффициента Phi с учётом сдвиговой деформации\"\"\"\n        phi = 12 * self.E * self.Iz / (self.G * self.A * self.k * self.L_e ** 2)\n        return phi\n\n    def calculate_stiffness_coefficients(self, phi: float) -&gt; Tuple[float, ...]:\n        \"\"\" Расчёт коэффициентов жёсткости \"\"\"\n        k_ea = self.E * self.A / self.L_e                               ## Жёсткость при растяжении вдоль балки\n        k_gj = self.G * self.J / self.L_e                               ## Жёсткость при кручении\n        k11 = 12 * self.E * self.Iz / (self.L_e**3 * (1 + phi))         ## Жёсткость при изгибе (перемещение)\n        k12 = 6 * self.E * self.Iz / (self.L_e**2 * (1+phi))            ## Жёсткость при изгибе (перемещение и поворот)\n        k22 = (4 + phi) * self.E * self.Iz / (self.L_e * (1 + phi))     ## Жёскость при повороте на одном конце\n        k24 = (2 - phi) * self.E * self.Iz / (self.L_e * (1 + phi))     ## Жёсткость между поворотами на концах\n        return k_ea, k_gj, k11, k12, k22, k24\n\n    def build_local_stiffness_matrix(self, k_ea: float, k_gj: float, k11: float,\n                                     k12: float, k22: float, k24: float) -&gt; NDArray:\n        \"\"\" Построение локальной матрицы жёсткости 12х12 \"\"\"\n        ## Создание пустой матрицы 12х12 (12 степеней свободы, 6 на каждом конце)\n        ke = np.zeros((12,12))\n        ## Заполнение ненулевых элементов\n        ## Растяжение вдоль оси балки (вдоль оси х)\n        ke[0, 0] = k_ea;  ke[0, 6] = -k_ea;  ke[6, 0] = -k_ea;  ke[6, 6] = k_ea\n        ## Изгиб в плоскости y (перемещения и повороты)\n        ke[1, 1] = k11;   ke[1, 5] = k12;   ke[1, 7] = -k11;  ke[1, 11] = k12\n        ke[5, 1] = k12;   ke[5, 5] = k22;   ke[5, 7] = -k12;  ke[5, 11] = k24\n        ke[7, 1] = -k11;  ke[7, 5] = -k12;  ke[7, 7] = k11;   ke[7, 11] = -k12\n        ke[11, 1] = k12;  ke[11, 5] = k24;  ke[11, 7] = -k12; ke[11, 11] = k22\n        ## Изгиб в плоскости z (перемещения и повороты)\n        ke[2, 2] = k11;   ke[2, 4] = -k12;  ke[2, 8] = -k11;  ke[2, 10] = -k12\n        ke[4, 2] = -k12;  ke[4, 4] = k22;   ke[4, 8] = k12;   ke[4, 10] = k24\n        ke[8, 2] = -k11;  ke[8, 4] = k12;   ke[8, 8] = k11;   ke[8, 10] = k12\n        ke[10, 2] = -k12; ke[10, 4] = k24;  ke[10, 8] = k12;  ke[10, 10] = k22\n        ## Кручение балки вокруг оси х\n        ke[3, 3] = k_gj;  ke[3, 9] = -k_gj; ke[9, 3] = -k_gj; ke[9, 9] = k_gj\n        return ke\n\n    def assemble_global_matrix(self, ke: NDArray) -&gt; NDArray:\n        \"\"\" Сборка глобальной матрицы жёсткости 18х18 \"\"\"\n        ## Создание пустой матрицы 18х18 (18 степеней свободы, 6 в каждом узле)\n        k_global = np.zeros((18, 18))\n        ## Добавление первого элемента (первые 12 строк и столбцов)\n        k_global[0:12, 0:12] += ke\n        ## Добавление второго элемента (последние 12 строк и столбцов)\n        k_global[6:18, 6:18] += ke\n        return k_global\n\n    def apply_boundary_conditions(self) -&gt; Tuple[List[int], NDArray]:\n        \"\"\" Применение граничных условий и определение свободных dofs \"\"\"\n        ## Шарнирные опоры в 1 и 3 узлах\n        ## (0 - u1x, 1 - u1y, 2 - u1z, 3 - theta1x, 12 - u3x, 13 - u3y, 14 - u3z, 15 - theta3z)\n        ##fixed_dofs = [0, 1, 2, 3, 12, 13, 14, 15]\n        fixed_dofs = [0, 1, 2, 12, 13, 14]\n        ## Свободные степени свободы (всё, что не закреплено)\n        free_dofs = [i for i in range(18) if i not in fixed_dofs]\n        ## Вектор нагрузок (18 нулей, сила только по индексу 7 - u2y)\n        f_full = np.zeros(18)\n        f_full[7] = self.F ## Приложенная сила F2y\n        return free_dofs, f_full\n\n    def solve_system(self, k_global: NDArray, free_dofs: List[int],\n                     f_full: NDArray) -&gt; Tuple[NDArray, float, NDArray, float]:\n        \"\"\" Решение системы уравнений для перемещенеий \"\"\"\n        ## Оставляем только \"свободные части\" матрицы жёсткости и вектора нагрузок\n        k_red = k_global[np.ix_(free_dofs, free_dofs)]\n        f_red = f_full[free_dofs]\n\n        ## Решаем систему: K * u = F, где u - вектор перемещений\n        ## Используем собственную функцию, реализующую метод Гаусса\n        u_red_my = None\n        try:\n            u_red_my = my_solve(k_red, f_red)\n        except ValueError as e:\n            print(f\"my_solve: система вырожденная - {e}\")\n\n        ## Решаем систему: K * u = F, где u - вектор перемещений\n        ## Используем функцию из билиотеки NumPy (PLU азложение с оптимизацией)\n        u_red_np = None\n        try:\n            u_red_np = np.linalg.solve(k_red, f_red)\n        except ValueError as e:\n            print(f\"np.linalg.solve: система вырожденная - {e}\")\n\n        ## Решаем систему: K * u = F, где u - вектор перемещений\n        ## Используем собственную функцию plu_solve (PLU разложение)\n        u_red_plu = None\n        try:\n            u_red_plu = plu_solve(k_red, f_red)\n        except ValueError as e:\n            print(f\"plu_solve: система вырожденная - {e}\")\n\n        ## Решаем систему: K * u = F, где u - вектор перемещений\n        ## Используем псевдообратную матрицу через сингулярное разложение SVD\n        u_red_pinv = np.linalg.pinv(k_red) @ f_red\n\n        ## Решаем систему: K * u = F, где u - вектор перемещений\n        ## Находим базис ядра и частное решение через сингулярное разложение SVD\n        u_red_svd, kernel = svd_solve(k_red, f_red)\n\n        ## Решаем систему: K * u = F, где u - вектор перемещений\n        # Регуляризация Тихонова\n        u_red_tikh = tikhonov_solve(k_red, f_red)\n\n        ## Решаем систему: K * u = F, где u - вектор перемещений\n        ## Мягкие пружины\n        ##global_stab_indices = [0, 1, 2, 12, 13, 14]  # u1x, u1y, u1z, u3x, u3y, u3z в K_global\n        global_stab_indices = [3, 4, 5, 15, 16, 17] # theta1x, theta1y, theta1z, theta3x, theta3y, theta3z в k_global\n        u_red_spring = None\n        try:\n            u_red_spring = spring_solve(k_red, f_red, global_stab_indices, free_dofs)\n            if u_red_spring is None:  # Если сингулярна, выходим из цикла\n                raise np.linalg.LinAlgError(\"Сингулярность осталась\")\n        except np.linalg.LinAlgError:\n            time_spring = 0.0\n\n        ## Решаем систему: K * u = F, где u - вектор перемещений\n        ## QR-разложение\n        u_red_qr = qr_solve(k_red, f_red)\n\n        ## Решаем систему: K * u = F, где u - вектор перемещений\n        # Анализ собственных значений\n        u_red_eigen = eigen_solve(k_red, f_red)\n\n        ## Решаем систему: K * u = F, где u - вектор перемещений\n        ## MUMPS\n        u_red_mumps = mumps_solve(k_red, f_red)\n\n        ## Решаем систему: K * u = F, где u - вектор перемещений\n        ## MUMPS-like\n        u_red_lu = mumps_like_lu_solve(k_red, f_red)\n\n        # PARDISO\n        u_red_pardiso = pardiso_solve(k_red, f_red)\n\n        return u_red_my, u_red_np, u_red_plu, u_red_pinv, u_red_svd, kernel, u_red_tikh, u_red_spring, u_red_qr, \\\n            u_red_eigen, u_red_mumps, u_red_lu, u_red_pardiso\n\ndef main() -&gt; None:\n    \"\"\" Основная функция \"\"\"\n    beam = BeamStructure()\n\n    ## Вывод исходный данных\n    print(f\"E = {beam.E:.2e} кгс/мм^2, G = {beam.G:.2e} кгс/мм^2, \"\n          f\"A = {beam.A:.2e} мм^2, Iz = {beam.Iz:.2e} мм^4, \"\n          f\"J = {beam.J:.2e} мм^4, L_e = {beam.L_e:.2e} мм\")\n\n    ## Расчёт промежуточных величин\n    phi = beam.calculate_phi()\n    print(f\"Phi = {phi:.4f}\")\n\n    k_ea, k_gj, k11, k12, k22, k24 = beam.calculate_stiffness_coefficients(phi)\n    print(f\"k11 = {k11:.2e}, k12 = {k12:.2e}, k22 = {k22:.2e}, \"\n          f\"k24 = {k24:.2e}\")\n    print(f\"k_ea = {k_ea:.2e}, k_gj = {k_gj:.2e}\")\n\n    # Построение матриц\n    ke = beam.build_local_stiffness_matrix(k_ea, k_gj, k11, k12, k22, k24)\n    k_global = beam.assemble_global_matrix(ke)\n\n    # Вывод матрицы\n    np.set_printoptions(precision=3)\n    print(\"Полная матрица жесткости:\")\n    print(k_global)\n\n    # Граничные условия и решение\n    free_dofs, f_full = beam.apply_boundary_conditions()\n    print(f\"Свободные степени свободы: {free_dofs}\")\n    print(f\"Вектор сил: {f_full}\")\n\n    k_red = k_global[np.ix_(free_dofs, free_dofs)]\n    print(f\"Детерминант K_red = {np.linalg.det(k_red):.2e}\")\n\n    ## Решаем с замерами времени ## u_red_gmres,\n    u_red_my, u_red_np, u_red_plu, u_red_pinv, u_red_svd, kernel, u_red_tikh, u_red_spring, u_red_qr, \\\n        u_red_eigen, u_red_mumps, u_red_lu, u_red_pardiso = \\\n        beam.solve_system(k_global, free_dofs, f_full)\n\n    # Вывод с проверкой на None\n    if u_red_my is not None:\n        print(f\"Перемещения (my_solve): {u_red_my}\")\n        print(f\"Прогиб u_2y (my_solve): {u_red_my[free_dofs.index(7)]:.4f} мм\")\n    else:\n        print(\"Перемещения (my_solve): не удалось вычислить из-за вырожденности\")\n\n    if u_red_np is not None:\n        print(f\"Перемещения (NumPy): {u_red_np}\")\n        print(f\"Прогиб u_2y (NumPy): {u_red_np[free_dofs.index(7)]:.4f} мм\")\n    else:\n        print(\"Перемещения (NumPy): не удалось вычислить из-за вырожденности\")\n\n    if u_red_plu is not None:\n        print(f\"Перемещения (plu_solve): {u_red_plu}\")\n        print(f\"Прогиб u_2y (plu_solve): {u_red_plu[free_dofs.index(7)]:.4f} мм\")\n    else:\n        print(\"Перемещения (plu_solve): не удалось вычислить из-за вырожденности\")\n\n    print(f\"Перемещения (псевдообратная): {u_red_pinv}\")\n    print(f\"Прогиб u_2y (псевдообратная): {u_red_pinv[free_dofs.index(7)]:.4f} мм\")\n\n    print(f\"Перемещения (SVD частное): {u_red_svd}\")\n    print(f\"Прогиб u_2y (SVD): {u_red_svd[free_dofs.index(7)]:.4f} мм\")\n\n    print(f\"Перемещения (Тихонов): {u_red_tikh}\")\n    print(f\"Прогиб u_2y (Тихонов): {u_red_tikh[free_dofs.index(7)]:.4f} мм\")\n\n    if u_red_spring is not None:\n        print(f\"Перемещения (мягкие пружины): {u_red_spring}\")\n        print(f\"Прогиб u_2y (мягкие пружины): {u_red_spring[free_dofs.index(7)]:.4f} мм\")\n    else:\n        print(f\"Перемещения (spring_solve) не удалось вычислить из-за вырожденности\")\n\n    print(f\"Перемещения (QR): {u_red_qr}\")\n    print(f\"Прогиб u_2y (QR): {u_red_qr[free_dofs.index(7)]:.4f} мм\")\n\n    print(f\"Перемещения (Eigen): {u_red_eigen}\")\n    print(f\"Прогиб u_2y (Eigen): {u_red_eigen[free_dofs.index(7)]:.4f} мм\")\n\n    print(f\"Перемещения (MUMPS): {u_red_mumps}\")\n    print(f\"Прогиб u_2y (MUMPS): {u_red_mumps[free_dofs.index(7)]:.4f} мм\")\n\n    print(f\"Перемещения (LU): {u_red_lu}\")\n    print(f\"Прогиб u_2y (LU): {u_red_lu[free_dofs.index(7)]:.4f} мм\")\n\n    print(f\"Перемещения (PARDISO): {u_red_pardiso}\")\n    print(f\"Прогиб u_2y (PARDISO): {u_red_pardiso[free_dofs.index(7)]:.4f} мм\")\n\nif __name__ == \"__main__\":\n    main()"
  }
]