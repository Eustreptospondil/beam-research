<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.23">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Разбор задачи о шарнирно опёртой балке с «неполным» набором граничных условий</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-226bd0f977fa82dfae4534cac220d79a.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-bb5f9278568ae542f8467bdb635b70ac.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles/styles.css">
</head>

<body class="fullcontent quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Разбор задачи о шарнирно опёртой балке с «неполным» набором граничных условий</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="введение" class="level2">
<h2 class="anchored" data-anchor-id="введение">Введение</h2>
<p>Одним прекрасным октябрьским днём раздался вопрос из зала от господина Ш.:</p>
<blockquote class="blockquote">
<p>Коллеги, столкнулся с совсем банальностью… Хотел посчитать прогиб свободной опёртой балки под вертикальным ускорением. Делал соответственно через beam elements. Накладываю на обоих концах ограничения через Remote displacements: ограничивая перемещения 0, повороты оставляю Free. Использовал прямой решатель с мягкими пружинами. В итоге решатель выдаёт ошибку – матрица жёсткости вырождена, бла-бла-бла, тра-ла-ла… Пробовал через simply supported – та же самая история… Причём на shell’ах, где тоже 6 степеней свободы в узле как бе, с такими же ограничениями как на бимах всё бодренько считает… В Solidworks Simulation без всяких танцев с бубном получаю результат</p>
</blockquote>
<p>Что надо делать, мы оперативно обсудили, но вопрос «почему здесь вот так, а здесь не так» остался лежать до лучших времён. Вот эти времена и настали. Начнём с двух оценочных суждений:</p>
<ol type="1">
<li><p>На мой взгляд, Solidworks Simulation – это инструмент, предназначенный, в первую очередь, для подпирающего справочником Писаренко собственноручно спроектированный стол конструктора-недоучки, чтобы тот гордо размахивал цветными картинками (не имеющими никакого отношения к делу), верещал «Ну вот, я же посчитал!» (на расчётную схему без слёз не взглянешь) и доводил меня до белого каления. Так как других кейсов использования данного программного продукта мне встречать не доводилось, то на моей технике его не было, нет и не будет, а рассматривать его в дальнейшем будем (не будем) лишь в теоретическом плане.</p></li>
<li><p>На мой взгляд, «мягкие пружины» (weak springs) представляют собой «костыль» для тех, кто по тем или иным причинам должным образом не задаёт полный набор граничных условий, а их использование при проведении прочностных расчётов – плохая практика.</p></li>
</ol>
<p>А теперь перейдём к основной части и попробуем разобраться, что же считает нам вычислительная машина, каким образом получается тот или иной результат, как устроены «мягкие пружины», ну и, может быть, сделаем какой-нибудь вывод. Изначально предполагалось, что получение ответа на все вопросы займёт совсем немного времени, но обработка некоторых результатов затянулась, я то болел, то пил, то работал, а энтузиазм разбираться со всем этим периодически угасал.</p>
<p>Для большей простоты и наглядности немного упростим задачку и будем рассматривать её в следующей постановке: линейно упругая стальная (модуль упругости <span class="math inline">\(E=20000~{\text{кгс/мм}}^2\)</span>, коэффициент Пуассона <span class="math inline">\(\mu=0,3\)</span>) балка длиной <span class="math inline">\(L=600~{\text{мм}}\)</span>, поперечное сечение которой – круг радиусом <span class="math inline">\(R=5~{\text{мм}}\)</span>, шарнирно опёрта на торцах и нагружена в центре поперечной силой, равной <span class="math inline">\(F=1~{\text{кгс}}\)</span>. При этом в узлах опирания ограничены только перемещения, а все углы поворота оставлены свободными. Конечноэлементная сетка будет включать в себя целых два балочных элемента.</p>
<hr>
</section>
<section id="результаты-решения-в-приличных-не-solidworks-программных-комплексах" class="level2">
<h2 class="anchored" data-anchor-id="результаты-решения-в-приличных-не-solidworks-программных-комплексах">1. Результаты решения в приличных (не SolidWorks) программных комплексах</h2>
<section id="ansys" class="level3">
<h3 class="anchored" data-anchor-id="ansys">1.1 ANSYS</h3>
<p>Результат решения задачи в указанной постановке представлены на рисунке 1. Такую задачу программа считать отказалась, любезно предоставив нам сообщение об ошибке с указанием на нехватку ограничений по углу поворота балки вокруг оси балки.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Pic_1.png" class="img-fluid figure-img"></p>
<figcaption>Рисунок 1 - Результат решения задачи о шарнирно опёртой балке без ограничений на углы поворота в Ansys (сообщение об ошибке с указанием на нехватку ограничений по углу поворота вокруг оси балки)</figcaption>
</figure>
</div>
<p>Стоит отметить, что похожий отрицательный результат был ранее получен господином Ш. Почему похожий? Потому что в его постановке дополнительно использовались «мягкие пружины», которых у нас нет. А вот почему они не сработали, мы рассмотрим попозже. А сейчас не будем спорить с машиной, добавим требуемое ограничение на угол поворота <span class="math inline">\(\theta_x\)</span> вокруг оси балки и получим результат, представленный на рисунке 2: задачка посчиталась, максимальный прогиб в центре балки составил <span class="math inline">\(0,45961~{\text{мм}}\)</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Pic_2.png" class="img-fluid figure-img"></p>
<figcaption>Рисунок 2 - Результат решения задачи о шарнирно опёртой балке с ограничениями на углы поворота вокруг её оси в Ansys (никаких сообщений об ошибках, максимальный прогиб в центре 0,45961 мм)</figcaption>
</figure>
</div>
</section>
<section id="simcenter-nastran" class="level3">
<h3 class="anchored" data-anchor-id="simcenter-nastran">1.2 Simcenter Nastran</h3>
<p>Результат решения задачи в исходной постановке представлены на рисунке 3. Тут мы опять видим сообщение о нехватке граничных условий, превращающее нашу балку в механизм. А так как никакие дополнительные параметры решателя типа BAILOUT мы не трогали – результат получился, на мой взгляд, вполне закономерным. Добавим требуемое ограничение на угол поворота <span class="math inline">\(\theta_x\)</span> вокруг оси балки и получим результат, представленный на рисунке 4: задачка посчиталась, максимальный прогиб в центре балки составил <span class="math inline">\(0,4586~{\text{мм}}\)</span>, весьма похоже на решение, полученное в ANSYS.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Pic_3.png" class="img-fluid figure-img"></p>
<figcaption>Рисунок 3 - Результат решения задачи о шарнирно опёртой балке без ограничений на углы поворота в Simcenter Nastran (сообщение об ошибке указывает на недостаточное количество ограничений)</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Pic_4.png" class="img-fluid figure-img"></p>
<figcaption>Рисунок 4 - Результат решения задачи о шарнирно опёртой балке с ограничениями на углы поворота вокруг её оси в Simcenter Nastran (никаких сообщений об ошибках, максимальный прогиб в центре 0,4586 мм)</figcaption>
</figure>
</div>
</section>
<section id="comsol" class="level3">
<h3 class="anchored" data-anchor-id="comsol">1.3 COMSOL</h3>
<p>Результат решения задачи в исходной постановке представлен на рисунке 5. Этот программный комплекс «съел» кинематические граничные условия в виде одних лишь перемещений и спокойно выдал результат – <span class="math inline">\(0,45837~{\text{мм}}\)</span>, что весьма близко к двум предыдущим решениям, требовавшим дополнительное ограничение на угол поворота. Если добавить это ограничение в COMSOL, то результат останется без изменений, поэтому отдельно его приводить не будем.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Pic_5.png" class="img-fluid figure-img"></p>
<figcaption>Рисунок 5 - Результат решения задачи о шарнирно опёртой балке без ограничений на углы поворота в COMSOL (никаких сообщений об ошибках, максимальный прогиб в центре – 0,45837 мм)</figcaption>
</figure>
</div>
</section>
<section id="abaqus" class="level3">
<h3 class="anchored" data-anchor-id="abaqus">1.4 ABAQUS</h3>
<p>Результат решения задачи в исходной постановке представлен на рисунке 6. ABAQUS так же как и COMSOL съел кинематические граничные условия в виде одних лишь перемещений, однако максимальный прогиб в центре балки составил <span class="math inline">\(0,4277~{\text{мм}}\)</span>, что сильно меньше решений, полученных ранее. При добавлении ограничения на угол поворота вокруг оси балки результат остался без изменений, поэтому отдельно приводить его тоже не будем.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Pic_6.png" class="img-fluid figure-img"></p>
<figcaption>Рисунок 6 - Результат решения задачи о шарнирно опёртой балке без ограничений на углы поворота в Abaqus</figcaption>
</figure>
</div>
</section>
<section id="optistruct-altair-hyperworks" class="level3">
<h3 class="anchored" data-anchor-id="optistruct-altair-hyperworks">1.5 OptiStruct (Altair Hyperworks)</h3>
<p>Результат решения задачи в исходной постановке представлен на рисунке 7. Здесь мы опять получили результат с «неполным» набором кинематических граничных условий – максимальный прогиб в центре равен <span class="math inline">\(0,4586~{\text{мм}}\)</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Pic_7.png" class="img-fluid figure-img"></p>
<figcaption>Рисунок 7 - Результат решения задачи о шарнирно опёртой балке без ограничений на углы поворота в Altair Hyperworks (OptiStruct)</figcaption>
</figure>
</div>
</section>
<section id="логос" class="level3">
<h3 class="anchored" data-anchor-id="логос">1.6 ЛОГОС</h3>
<p>Ну да, Логос, а почему бы и нет. Результат решения задачи в исходной постановке представлен на рисунке 8. Не будем описывать проблемы, возникшие при запуске даже такой незамысловатой задачи, перейдём сразу к числам – максимальный прогиб в центре балки с формально неполным набором кинематических граничных условий получился <span class="math inline">\(0,458366~{\text{мм}}\)</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Pic_8.png" class="img-fluid figure-img"></p>
<figcaption>Рисунок 8 - решения задачи о шарнирно опёртой балке без ограничений на углы поворота в ЛОГОС</figcaption>
</figure>
</div>
<hr>
</section>
</section>
<section id="немножко-теории" class="level2">
<h2 class="anchored" data-anchor-id="немножко-теории">2. Немножко теории</h2>
<section id="а-что-там-внутри" class="level3">
<h3 class="anchored" data-anchor-id="а-что-там-внутри">2.1 А что там внутри?</h3>
<hr>
<p>Попробуем покопаться в логах и документации и понять, почему был получен тот или иной результат (если это будет возможно, разумеется). В качестве отправной точки залезем в логи решения задачи в ANSYS, который потребовал ограничений на углы поворота, и увидим, что в нашем случае использовались конечные элементы типа BEAM188. Документация говорит нам, что эти элементы основаны на теории Тимошенко, с линейными функциями формы.</p>
<p>А теперь залезем в документацию COMSOL, который обошёлся ограничениями только на перемещения, и увидим, что в нашем случае использовались конечные элементы, основанный на теории Эйлера-Бернулли (есть опция выбора, но по умолчанию стоит Эйлер), с функциями формы, описываемыми кубическими полиномами.</p>
<p>Взглянем на то, как должны выглядеть матрицы жёсткости этих элементов (без их вывода, пушто мне лениво расписывать). В случае балки Эйлера матрица жёсткости примет следующий вид:</p>
<div class="scroll-matrix">
<p><span class="math display">\[
K =\begin{bmatrix}
  \frac{E \cdot A}{L} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -\frac{E \cdot A}{L} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; \frac{12 \cdot E \cdot I_y}{L^3} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{6 \cdot E \cdot I_y}{L^2} &amp; 0 &amp; -\frac{12 \cdot E \cdot I_y}{L^3} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{6 \cdot E \cdot I_y}{L^2} \\
  0 &amp; 0 &amp; \frac{12 \cdot E \cdot I_z}{L^3} &amp; 0 &amp; -\frac{6 \cdot E \cdot I_z}{L^2} &amp; 0 &amp; 0 &amp; 0 &amp; -\frac{12 \cdot E \cdot I_z}{L^3} &amp; 0 &amp; -\frac{6 \cdot E \cdot I_z}{L^2} &amp; 0 \\
  0 &amp; 0 &amp; 0 &amp; \frac{G \cdot J}{L} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -\frac{G \cdot J}{L} &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; -\frac{6 \cdot E \cdot I_z}{L^2} &amp; 0 &amp; \frac{4 \cdot E \cdot I_z}{L} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{6 \cdot E \cdot I_z}{L^2} &amp; 0 &amp; \frac{2 \cdot E \cdot I_z}{L} &amp; 0 \\
  0 &amp; \frac{6 \cdot E \cdot I_y}{L^2} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{4 \cdot E \cdot I_y}{L} &amp; 0 &amp; -\frac{6 \cdot E \cdot I_y}{L^2} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{2 \cdot E \cdot I_y}{L} \\
  -\frac{E \cdot A}{L} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \frac{E \cdot A}{L} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; -\frac{12 \cdot E \cdot I_y}{L^3} &amp; 0 &amp; 0 &amp; 0 &amp; -\frac{6 \cdot E \cdot I_y}{L^2} &amp; 0 &amp; \frac{12 \cdot E \cdot I_y}{L^3} &amp; 0 &amp; 0 &amp; 0 &amp; -\frac{6 \cdot E \cdot I_y}{L^2} \\
  0 &amp; 0 &amp; -\frac{12 \cdot E \cdot I_z}{L^3} &amp; 0 &amp; \frac{6 \cdot E \cdot I_z}{L^2} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{12 \cdot E \cdot I_z}{L^3} &amp; 0 &amp; \frac{6 \cdot E \cdot I_z}{L^2} &amp; 0 \\
  0 &amp; 0 &amp; 0 &amp; -\frac{G \cdot J}{L} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \frac{G \cdot J}{L} &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; -\frac{6 \cdot E \cdot I_z}{L^2} &amp; 0 &amp; \frac{2 \cdot E \cdot I_z}{L} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{6 \cdot E \cdot I_z}{L^2} &amp; 0 &amp; \frac{4 \cdot E \cdot I_z}{L} &amp; 0 \\
  0 &amp; \frac{6 \cdot E \cdot I_y}{L^2} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{2 \cdot E \cdot I_y}{L} &amp; 0 &amp; -\frac{6 \cdot E \cdot I_y}{L^2} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{4 \cdot E \cdot I_y}{L}
\end{bmatrix}
\]</span></p>
</div>
<p>где <span class="math inline">\(Е\)</span> – модуль упругости, <span class="math inline">\(I_y\)</span> и <span class="math inline">\(I_z\)</span> – моменты инерции поперечного сечения балочного элемента, <span class="math inline">\(L\)</span> – длина балочного элемента, <span class="math inline">\(G\)</span> – модуль сдвига, связанный с модулем упругости соотношением <span class="math inline">\(G = \frac{E}{2 \cdot (1 + \mu)}\)</span>, <span class="math inline">\(A\)</span> - площадь поперечного сечения балочного элемента, <span class="math inline">\(J\)</span> – момент инерции при кручении.</p>
<p>В случае балки Тимошенко матрица жёсткости примет следующий вид:</p>
<div class="scroll-matrix">
<p><span class="math display">\[
K=\begin{bmatrix}
\frac{E \cdot A}{L} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -\frac{E \cdot A}{L} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \frac{12 \cdot E \cdot I_z}{L^3 \cdot (1 + \Phi_z)} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{6 \cdot E \cdot I_z}{L^2 \cdot (1 + \Phi_z)} &amp; 0 &amp; -\frac{12 \cdot E \cdot I_z}{L^3 \cdot (1 + \Phi_z)} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{6 \cdot E \cdot I_z}{L^2 \cdot (1 + \Phi_z)} \\
0 &amp; 0 &amp; \frac{12 \cdot E \cdot I_y}{L^3 \cdot (1 + \Phi_y)} &amp; 0 &amp; -\frac{6 \cdot E \cdot I_y}{L^2 \cdot (1 + \Phi_y)} &amp; 0 &amp; 0 &amp; 0 &amp; -\frac{12 \cdot E \cdot I_y}{L^3 \cdot (1 + \Phi_y)} &amp; 0 &amp; -\frac{6 \cdot E \cdot I_y}{L^2 \cdot (1 + \Phi_y)} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; \frac{G \cdot J}{L} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -\frac{G \cdot J}{L} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; -\frac{6 \cdot E \cdot I_y}{L^2 \cdot (1 + \Phi_y)} &amp; 0 &amp; \frac{(4 + \Phi_y) \cdot E \cdot I_y}{L \cdot (1 + \Phi_y)} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{6 \cdot E \cdot I_y}{L^2 \cdot (1 + \Phi_y)} &amp; 0 &amp; \frac{(2 - \Phi_y) \cdot E \cdot I_y}{L \cdot (1 + \Phi_y)} &amp; 0 \\
0 &amp; \frac{6 \cdot E \cdot I_z}{L^2 \cdot (1 + \Phi_z)} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{(4 + \Phi_z) \cdot E \cdot I_z}{L \cdot (1 + \Phi_z)} &amp; 0 &amp; -\frac{6 \cdot E \cdot I_z}{L^2 \cdot (1 + \Phi_z)} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{(2 - \Phi_z) \cdot E \cdot I_z}{L \cdot (1 + \Phi_z)} \\
-\frac{E \cdot A}{L} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \frac{E \cdot A}{L} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; -\frac{12 \cdot E \cdot I_z}{L^3 \cdot (1 + \Phi_z)} &amp; 0 &amp; 0 &amp; 0 &amp; -\frac{6 \cdot E \cdot I_z}{L^2 \cdot (1 + \Phi_z)} &amp; 0 &amp; \frac{12 \cdot E \cdot I_z}{L^3 \cdot (1 + \Phi_z)} &amp; 0 &amp; 0 &amp; 0 &amp; -\frac{6 \cdot E \cdot I_z}{L^2 \cdot (1 + \Phi_z)} \\
0 &amp; 0 &amp; -\frac{12 \cdot E \cdot I_y}{L^3 \cdot (1 + \Phi_y)} &amp; 0 &amp; \frac{6 \cdot E \cdot I_y}{L^2 \cdot (1 + \Phi_y)} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{12 \cdot E \cdot I_y}{L^3 \cdot (1 + \Phi_y)} &amp; 0 &amp; \frac{6 \cdot E \cdot I_y}{L^2 \cdot (1 + \Phi_y)} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; -\frac{G \cdot J}{L} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \frac{G \cdot J}{L} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; -\frac{6 \cdot E \cdot I_y}{L^2 \cdot (1 + \Phi_y)} &amp; 0 &amp; \frac{(2 - \Phi_y) \cdot E \cdot I_y}{L \cdot (1 + \Phi_y)} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{6 \cdot E \cdot I_y}{L^2 \cdot (1 + \Phi_y)} &amp; 0 &amp; \frac{(4 + \Phi_y) \cdot E \cdot I_y}{L \cdot (1 + \Phi_y)} &amp; 0 \\
0 &amp; \frac{6 \cdot E \cdot I_z}{L^2 \cdot (1 + \Phi_z)} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{(2 - \Phi_z) \cdot E \cdot I_z}{L \cdot (1 + \Phi_z)} &amp; 0 &amp; -\frac{6 \cdot E \cdot I_z}{L^2 \cdot (1 + \Phi_z)} &amp; 0 &amp; 0 &amp; 0 &amp; \frac{(4 + \Phi_z) \cdot E \cdot I_z}{L \cdot (1 + \Phi_z)}
\end{bmatrix}
\]</span></p>
</div>
<p>где <span class="math inline">\(\Phi_z = \frac{12 \cdot E \cdot I_z}{G \cdot A \cdot k \cdot L^2}\label{eq:phi_z}\)</span>, <span class="math inline">\(\Phi_y = \frac{12 \cdot E \cdot I_y}{G \cdot A \cdot k \cdot L^2}\label{eq:phi_y}\)</span>, а <span class="math inline">\(k\)</span> - коэффициент, зависящий от формы поперечного сечения.</p>
<p>Как несложно заметить, структура обеих матриц одинакова и, с точки зрения процедуры дальнейшего решения системы линейных алгебраических уравнений, их можно считать идентичными. Перепишем в общем виде матрицу жёсткости одного конечного элемента:</p>
<p><span class="math display">\[
\mathbf{K} =
\begin{bmatrix}
K_{1,1} &amp; 0        &amp; 0        &amp; 0        &amp; 0        &amp; 0        &amp; K_{1,7} &amp; 0        &amp; 0        &amp; 0         &amp; 0         &amp; 0 \\
0       &amp; K_{2,2}  &amp; 0        &amp; 0        &amp; 0        &amp; K_{2,6}  &amp; 0       &amp; K_{2,8}  &amp; 0        &amp; 0         &amp; 0         &amp; K_{2,12} \\
0       &amp; 0        &amp; K_{3,3}  &amp; 0        &amp; K_{3,5}  &amp; 0        &amp; 0       &amp; 0        &amp; K_{3,9}  &amp; 0         &amp; K_{3,11}  &amp; 0 \\
0       &amp; 0        &amp; 0        &amp; K_{4,4}  &amp; 0        &amp; 0        &amp; 0       &amp; 0        &amp; 0        &amp; K_{4,10}  &amp; 0         &amp; 0 \\
0       &amp; 0        &amp; K_{5,3}  &amp; 0        &amp; K_{5,5}  &amp; 0        &amp; 0       &amp; 0        &amp; K_{5,9}  &amp; 0         &amp; K_{5,11}  &amp; 0 \\
0       &amp; K_{6,2}  &amp; 0        &amp; 0        &amp; 0        &amp; K_{6,6}  &amp; 0       &amp; K_{6,8}  &amp; 0        &amp; 0         &amp; 0         &amp; K_{6,12} \\
K_{7,1} &amp; 0        &amp; 0        &amp; 0        &amp; 0        &amp; 0        &amp; K_{7,7} &amp; 0        &amp; 0        &amp; 0         &amp; 0         &amp; 0 \\
0       &amp; K_{8,2}  &amp; 0        &amp; 0        &amp; 0        &amp; K_{8,6}  &amp; 0       &amp; K_{8,8}  &amp; 0        &amp; 0         &amp; 0         &amp; K_{8,12} \\
0       &amp; 0        &amp; K_{9,3}  &amp; 0        &amp; K_{9,5}  &amp; 0        &amp; 0       &amp; 0        &amp; K_{9,9}  &amp; 0         &amp; K_{9,11}  &amp; 0 \\
0       &amp; 0        &amp; 0        &amp; K_{10,4} &amp; 0        &amp; 0        &amp; 0       &amp; 0        &amp; 0        &amp; K_{10,10} &amp; 0         &amp; 0 \\
0       &amp; 0        &amp; K_{11,3} &amp; 0        &amp; K_{11,5} &amp; 0        &amp; 0       &amp; 0        &amp; K_{11,9} &amp; 0         &amp; K_{11,11} &amp; 0 \\
0       &amp; K_{12,2} &amp; 0        &amp; 0        &amp; 0        &amp; K_{12,6} &amp; 0       &amp; K_{12,8} &amp; 0        &amp; 0         &amp; 0         &amp; K_{12,12}
\end{bmatrix}
\label{eq:stiffness_matrix}
\]</span></p>
<p>А теперь соберём полную матрицу жёсткости и запишем разрешающее уравнение <span class="math inline">\(K \cdot u = P\)</span> для нашей модели:</p>
<div class="scroll-matrix">
<p><span class="math display">\[
\begin{bmatrix}
K1_{1,1} &amp; 0         &amp; 0         &amp; 0         &amp; 0         &amp; 0         &amp; K_{1,7}           &amp; 0                  &amp; 0                  &amp; 0                   &amp; 0                   &amp; 0                   &amp; 0        &amp; 0         &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0        &amp; K1_{2,2}  &amp; 0         &amp; 0         &amp; 0         &amp; K1_{2,6}  &amp; 0                 &amp; K1_{2,8}           &amp; 0                  &amp; 0                   &amp; 0                   &amp; K1_{2,12}           &amp; 0        &amp; 0         &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0        &amp; 0         &amp; K1_{3,3}  &amp; 0         &amp; K1_{3,5}  &amp; 0         &amp; 0                 &amp; 0                  &amp; K1_{3,9}           &amp; 0                   &amp; K1_{3,11}           &amp; 0                   &amp; 0        &amp; 0         &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0        &amp; 0         &amp; 0         &amp; K1_{4,4}  &amp; 0         &amp; 0         &amp; 0                 &amp; 0                  &amp; 0                  &amp; K1_{4,10}           &amp; 0                   &amp; 0                   &amp; 0        &amp; 0         &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0        &amp; 0         &amp; K1_{5,3}  &amp; 0         &amp; K1_{5,5}  &amp; 0         &amp; 0                 &amp; 0                  &amp; K1_{5,9}           &amp; 0                   &amp; K1_{5,11}           &amp; 0                   &amp; 0        &amp; 0         &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0        &amp; K1_{6,2}  &amp; 0         &amp; 0         &amp; 0         &amp; K1_{6,6}  &amp; 0                 &amp; K1_{6,8}           &amp; 0                  &amp; 0                   &amp; 0                   &amp; K1_{6,12}           &amp; 0        &amp; 0         &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
K1_{7,1} &amp; 0         &amp; 0         &amp; 0         &amp; 0         &amp; 0         &amp; K1_{7,7}+K2_{1,1} &amp; 0                  &amp; 0                  &amp; 0                   &amp; 0                   &amp; 0                   &amp; K2_{1,7} &amp; 0         &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0        &amp; K1_{8,2}  &amp; 0         &amp; 0         &amp; 0         &amp; K1_{8,6}  &amp; 0                 &amp; K1_{8,8}+K_{2,2}   &amp; 0                  &amp; 0                   &amp; 0                   &amp; K1_{8,12}+K2_{2,6}  &amp; 0        &amp; K2_{2,8}  &amp; 0         &amp; 0          &amp; 0          &amp; K2_{2,12} \\
0        &amp; 0         &amp; K1_{9,3}  &amp; 0         &amp; K1_{9,5}  &amp; 0         &amp; 0                 &amp; 0                  &amp; K1_{9,9}+K2_{3,3}  &amp; 0                   &amp; K1_{9,11}+K2_{3,5}  &amp; 0                   &amp; 0        &amp; 0         &amp; K2_{3,9}  &amp; 0          &amp; K2_{3,11}  &amp; 0 \\
0        &amp; 0         &amp; 0         &amp; K1_{10,4} &amp; 0         &amp; 0         &amp; 0                 &amp; 0                  &amp; 0                  &amp; K1_{10,10}+K2_{4,4} &amp; 0                   &amp; 0                   &amp; 0        &amp; 0         &amp; 0         &amp; K2_{4,10}  &amp; 0          &amp; 0 \\
0        &amp; 0         &amp; K1_{11,3} &amp; 0         &amp; K1_{11,5} &amp; 0         &amp; 0                 &amp; 0                  &amp; K1_{11,9}+K2_{5,3} &amp; 0                   &amp; K1_{11,11}+K2_{5,5} &amp; 0                   &amp; 0        &amp; 0         &amp; K2_{5,9}  &amp; 0          &amp; K2_{5,11}  &amp; 0 \\
0        &amp; K1_{12,2} &amp; 0         &amp; 0         &amp; 0         &amp; K1_{12,6} &amp; 0                 &amp; K1_{12,8}+K2_{6,2} &amp; 0                  &amp; 0                   &amp; 0                   &amp; K1_{12,12}+K2_{6,6} &amp; 0        &amp; K2_{6,8}  &amp; 0         &amp; 0          &amp; 0          &amp; K2_{6,12} \\
0        &amp; 0         &amp; 0         &amp; 0         &amp; 0         &amp; 0         &amp; K2_{7,1}          &amp; 0                  &amp; 0                  &amp; 0                   &amp; 0                   &amp; 0                   &amp; K2_{7,7} &amp; 0         &amp; 0         &amp; 0          &amp; 0          &amp; 0 \\
0        &amp; 0         &amp; 0         &amp; 0         &amp; 0         &amp; 0         &amp; 0                 &amp; K2_{8,2}           &amp; 0                  &amp; 0                   &amp; 0                   &amp; K2_{8,6}            &amp; 0        &amp; K2_{8,8}  &amp; 0         &amp; 0          &amp; 0          &amp; K2_{8,12} \\
0        &amp; 0         &amp; 0         &amp; 0         &amp; 0         &amp; 0         &amp; 0                 &amp; 0                  &amp; K2_{9,3}           &amp; 0                   &amp; K2_{9,5}            &amp; 0                   &amp; 0        &amp; 0         &amp; K2_{9,9}  &amp; 0          &amp; K2_{9,11}  &amp; 0 \\
0        &amp; 0         &amp; 0         &amp; 0         &amp; 0         &amp; 0         &amp; 0                 &amp; 0                  &amp; 0                  &amp; K2_{10,4}           &amp; 0                   &amp; 0                   &amp; 0        &amp; 0         &amp; 0         &amp; K2_{10,10} &amp; 0          &amp; 0 \\
0        &amp; 0         &amp; 0         &amp; 0         &amp; 0         &amp; 0         &amp; 0                 &amp; 0                  &amp; K2_{11,3}          &amp; 0                   &amp; K2_{11,5}           &amp; 0                   &amp; 0        &amp; 0         &amp; K2_{11,9} &amp; 0          &amp; K2_{11,11} &amp; 0 \\
0        &amp; 0         &amp; 0         &amp; 0         &amp; 0         &amp; 0         &amp; 0                 &amp; K2_{12,2}          &amp; 0                  &amp; 0                   &amp; 0                   &amp; K2_{12,6}           &amp; 0        &amp; K2_{12,8} &amp; 0         &amp; 0          &amp; 0          &amp; K2_{12,12}
\end{bmatrix}
\cdot
\begin{bmatrix}
u_1 \\ v_1 \\ w_1 \\ \theta_{x1} \\ \theta_{y1} \\ \theta_{z1} \\
u_2 \\ v_2 \\ w_2 \\ \theta_{x2} \\ \theta_{y2} \\ \theta_{z2} \\
u_3 \\ v_3 \\ w_3 \\ \theta_{x3} \\ \theta_{y3} \\ \theta_{z3}
\end{bmatrix}
=
\begin{bmatrix}
0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\
0 \\ -1 \\ 0 \\ 0 \\ 0 \\ 0 \\
0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0
\end{bmatrix}
\]</span></p>
</div>
<p>Применим к получившейся «модели» граничные условия исходной задачи, т.е. ограничим только перемещения в первом и третьем узле, простым вычёркиванием соответствующих строк и столбцов:</p>
<p><img src="images/Pic_matrix_1.png" class="img-fluid"></p>
<p>Получаем в «остатке»:</p>
<div class="scroll-matrix">
<p><span class="math display">\[
\begin{bmatrix}
K1_{4,4}  &amp; 0         &amp; 0         &amp; 0                 &amp; 0                  &amp; 0                  &amp; K1_{4,10}           &amp; 0                   &amp; 0                   &amp; 0          &amp; 0          &amp; 0 \\
0         &amp; K1_{5,5}  &amp; 0         &amp; 0                 &amp; 0                  &amp; K1_{5,9}           &amp; 0                   &amp; K1_{5,11}           &amp; 0                   &amp; 0          &amp; 0          &amp; 0 \\
0         &amp; 0         &amp; K1_{6,6}  &amp; 0                 &amp; K1_{6,8}           &amp; 0                  &amp; 0                   &amp; 0                   &amp; K1_{6,12}           &amp; 0          &amp; 0          &amp; 0 \\
0         &amp; 0         &amp; 0         &amp; K1_{7,7}+K2_{1,1} &amp; 0                  &amp; 0                  &amp; 0                   &amp; 0                   &amp; 0                   &amp; 0          &amp; 0          &amp; 0 \\
0         &amp; 0         &amp; K1_{8,6}  &amp; 0                 &amp; K1_{8,8}+K_{2,2}   &amp; 0                  &amp; 0                   &amp; 0                   &amp; K1_{8,12}+K2_{2,6}  &amp; 0          &amp; 0          &amp; K2_{2,12} \\
0         &amp; K1_{9,5}  &amp; 0         &amp; 0                 &amp; 0                  &amp; K1_{9,9}+K2_{3,3}  &amp; 0                   &amp; K1_{9,11}+K2_{3,5}  &amp; 0                   &amp; 0          &amp; K2_{3,11}  &amp; 0 \\
K1_{10,4} &amp; 0         &amp; 0         &amp; 0                 &amp; 0                  &amp; 0                  &amp; K1_{10,10}+K2_{4,4} &amp; 0                   &amp; 0                   &amp; K2_{4,10}  &amp; 0          &amp; 0 \\
0         &amp; K1_{11,5} &amp; 0         &amp; 0                 &amp; 0                  &amp; K1_{11,9}+K2_{5,3} &amp; 0                   &amp; K1_{11,11}+K2_{5,5} &amp; 0                   &amp; 0          &amp; K2_{5,11}  &amp; 0 \\
0         &amp; 0         &amp; K1_{12,6} &amp; 0                 &amp; K1_{12,8}+K2_{6,2} &amp; 0                  &amp; 0                   &amp; 0                   &amp; K1_{12,12}+K2_{6,6} &amp; 0          &amp; 0          &amp; K2_{6,12} \\
0         &amp; 0         &amp; 0         &amp; 0                 &amp; 0                  &amp; 0                  &amp; K2_{10,4}           &amp; 0                   &amp; 0                   &amp; K2_{10,10} &amp; 0          &amp; 0 \\
0         &amp; 0         &amp; 0         &amp; 0                 &amp; 0                  &amp; K2_{11,3}          &amp; 0                   &amp; K2_{11,5}           &amp; 0                   &amp; 0          &amp; K2_{11,11} &amp; 0 \\
0         &amp; 0         &amp; 0         &amp; 0                 &amp; K2_{12,2}          &amp; 0                  &amp; 0                   &amp; 0                   &amp; K2_{12,6}           &amp; 0          &amp; 0          &amp; K2_{12,12}
\end{bmatrix}
\cdot
\begin{bmatrix}
\theta_{x1} \\ \theta_{y1} \\ \theta_{z1} \\
u_2 \\ v_2 \\ w_2 \\ \theta_{x2} \\ \theta_{y2} \\ \theta_{z2} \\
\theta_{x3} \\ \theta_{y3} \\ \theta_{z3}
\end{bmatrix}
=
\begin{bmatrix}
0 \\ 0 \\ 0 \\
0 \\ -1 \\ 0 \\ 0 \\ 0 \\ 0 \\
0 \\ 0 \\ 0
\end{bmatrix}
\]</span></p>
</div>
<p>Несложно убедиться, что определитель оставшейся части исходной матрицы равен нулю, и, соответственно, эта часть матрицы, необходимая для решения уравнения вида <span class="math inline">\(X = K^{-1} \cdot P\)</span>, не очень хочет обращаться, что приводит к невозможности получения результата. Именно такую картину можно было наблюдать при попытке решить исходную задачу (без ограничений на углы поворота) в ANSYS и NASTRAN. Теперь добавим недостающее граничное условие на угол поворота вокруг оси балки, ещё немного вычёркивая строчки и столбцы:</p>
<p><img src="images/Pic_matrix_2.png" class="img-fluid"></p>
<p>Получаем в «остатке»:</p>
<div class="scroll-matrix">
<p><span class="math display">\[
\begin{bmatrix}
K1_{5,5}  &amp; 0         &amp; 0                 &amp; 0                  &amp; K1_{5,9}           &amp; 0                   &amp; K1_{5,11}           &amp; 0                   &amp; 0          &amp; 0 \\
0         &amp; K1_{6,6}  &amp; 0                 &amp; K1_{6,8}           &amp; 0                  &amp; 0                   &amp; 0                   &amp; K1_{6,12}           &amp; 0          &amp; 0 \\
0         &amp; 0         &amp; K1_{7,7}+K2_{1,1} &amp; 0                  &amp; 0                  &amp; 0                   &amp; 0                   &amp; 0                   &amp; 0          &amp; 0 \\
0         &amp; K1_{8,6}  &amp; 0                 &amp; K1_{8,8}+K_{2,2}   &amp; 0                  &amp; 0                   &amp; 0                   &amp; K1_{8,12}+K2_{2,6}  &amp; 0          &amp; K2_{2,12} \\
K1_{9,5}  &amp; 0         &amp; 0                 &amp; 0                  &amp; K1_{9,9}+K2_{3,3}  &amp; 0                   &amp; K1_{9,11}+K2_{3,5}  &amp; 0                   &amp; K2_{3,11}  &amp; 0 \\
0         &amp; 0         &amp; 0                 &amp; 0                  &amp; 0                  &amp; K1_{10,10}+K2_{4,4} &amp; 0                   &amp; 0                   &amp; 0          &amp; 0 \\
K1_{11,5} &amp; 0         &amp; 0                 &amp; 0                  &amp; K1_{11,9}+K2_{5,3} &amp; 0                   &amp; K1_{11,11}+K2_{5,5} &amp; 0                   &amp; K2_{5,11}  &amp; 0 \\
0         &amp; K1_{12,6} &amp; 0                 &amp; K1_{12,8}+K2_{6,2} &amp; 0                  &amp; 0                   &amp; 0                   &amp; K1_{12,12}+K2_{6,6} &amp; 0          &amp; K2_{6,12} \\
0         &amp; 0         &amp; 0                 &amp; 0                  &amp; K2_{11,3}          &amp; 0                   &amp; K2_{11,5}           &amp; 0                   &amp; K2_{11,11} &amp; 0 \\
0         &amp; 0         &amp; 0                 &amp; K2_{12,2}          &amp; 0                  &amp; 0                   &amp; 0                   &amp; K2_{12,6}           &amp; 0          &amp; K2_{12,12}
\end{bmatrix}
\cdot
\begin{bmatrix}
\theta_{y1} \\ \theta_{z1} \\
u_2 \\ v_2 \\ w_2 \\ \theta_{x2} \\ \theta_{y2} \\ \theta_{z2} \\
\theta_{y3} \\ \theta_{z3}
\end{bmatrix}
=
\begin{bmatrix}
0 \\ 0 \\
0 \\ -1 \\ 0 \\ 0 \\ 0 \\ 0 \\
0 \\ 0
\end{bmatrix}
\]</span></p>
</div>
<p>В этом случае определитель оставшейся части исходной матрицы представляет собой положительное число, сам кусочек обращается на изи и можно получить конечное решение. Теперь, когда теоретический базис сформирован, можно приступить к подстановке чисел и получению решений. Реализуем несложный код (базовый, дальше будем его дополнять различными функциями) для случая с ограничением только на перемещения:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy.typing <span class="im">import</span> NDArray    <span class="co">## Тип для массивов NumPy</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Tuple, List      <span class="co">## Типы для подсказок, что возвращают функции</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BeamStructure:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">""" Исходные данные к задаче о шарнирно опёртой балке"""</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.L: <span class="bu">float</span> <span class="op">=</span> <span class="fl">600.0</span>           <span class="co">## Длина, мм</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.L_e: <span class="bu">float</span> <span class="op">=</span> <span class="va">self</span>.L <span class="op">/</span> <span class="dv">2</span>    <span class="co">## Длина элемента, мм</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.E: <span class="bu">float</span> <span class="op">=</span> <span class="fl">20000.0</span>         <span class="co">## Модуль упругости, кгс/мм^2</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.G: <span class="bu">float</span> <span class="op">=</span> <span class="fl">7692.31</span>         <span class="co">## Модуль сдвига, кгс/мм^2</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.A: <span class="bu">float</span> <span class="op">=</span> <span class="fl">78.54</span>           <span class="co">## Площадь поперечного сечения, мм^2</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.Iz: <span class="bu">float</span> <span class="op">=</span> <span class="fl">490.874</span>        <span class="co">## Момент инерции относительно оси z, мм^4</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.Iy: <span class="bu">float</span> <span class="op">=</span> <span class="fl">490.874</span>        <span class="co">## Момент инерции относительно оси y, мм^4</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.J: <span class="bu">float</span> <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> <span class="va">self</span>.Iz     <span class="co">## Полярный момент инерции, мм^4</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.k: <span class="bu">float</span> <span class="op">=</span> <span class="dv">10</span><span class="op">/</span><span class="dv">9</span>            <span class="co">## Коэффициент формы</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.F: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1.0</span>             <span class="co">## Сила, кгс</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> calculate_phi(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">""" Расчёт коэффициента Phi с учётом сдвиговой деформации"""</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        phi <span class="op">=</span> <span class="dv">12</span> <span class="op">*</span> <span class="va">self</span>.E <span class="op">*</span> <span class="va">self</span>.Iz <span class="op">/</span> (<span class="va">self</span>.G <span class="op">*</span> <span class="va">self</span>.A <span class="op">*</span> <span class="va">self</span>.k <span class="op">*</span> <span class="va">self</span>.L_e <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> phi</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> calculate_stiffness_coefficients(<span class="va">self</span>, phi: <span class="bu">float</span>) <span class="op">-&gt;</span> Tuple[<span class="bu">float</span>, ...]:</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">""" Расчёт коэффициентов жёсткости """</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        k_ea <span class="op">=</span> <span class="va">self</span>.E <span class="op">*</span> <span class="va">self</span>.A <span class="op">/</span> <span class="va">self</span>.L_e</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        k_gj <span class="op">=</span> <span class="va">self</span>.G <span class="op">*</span> <span class="va">self</span>.J <span class="op">/</span> <span class="va">self</span>.L_e</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        k11 <span class="op">=</span> <span class="dv">12</span> <span class="op">*</span> <span class="va">self</span>.E <span class="op">*</span> <span class="va">self</span>.Iz <span class="op">/</span> (<span class="va">self</span>.L_e<span class="op">**</span><span class="dv">3</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">+</span> phi))</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        k12 <span class="op">=</span> <span class="dv">6</span> <span class="op">*</span> <span class="va">self</span>.E <span class="op">*</span> <span class="va">self</span>.Iz <span class="op">/</span> (<span class="va">self</span>.L_e<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> (<span class="dv">1</span><span class="op">+</span>phi))</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>        k22 <span class="op">=</span> (<span class="dv">4</span> <span class="op">+</span> phi) <span class="op">*</span> <span class="va">self</span>.E <span class="op">*</span> <span class="va">self</span>.Iz <span class="op">/</span> (<span class="va">self</span>.L_e <span class="op">*</span> (<span class="dv">1</span> <span class="op">+</span> phi))</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        k24 <span class="op">=</span> (<span class="dv">2</span> <span class="op">-</span> phi) <span class="op">*</span> <span class="va">self</span>.E <span class="op">*</span> <span class="va">self</span>.Iz <span class="op">/</span> (<span class="va">self</span>.L_e <span class="op">*</span> (<span class="dv">1</span> <span class="op">+</span> phi))</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> k_ea, k_gj, k11, k12, k22, k24</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> build_local_stiffness_matrix(<span class="va">self</span>, k_ea: <span class="bu">float</span>, k_gj: <span class="bu">float</span>, k11: <span class="bu">float</span>,</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>                                     k12: <span class="bu">float</span>, k22: <span class="bu">float</span>, k24: <span class="bu">float</span>) <span class="op">-&gt;</span> NDArray:</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">""" Построение локальной матрицы жёсткости 12х12 """</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Создание пустой матрицы 12х12 (12 степеней свободы, 6 на каждом конце)</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>        ke <span class="op">=</span> np.zeros((<span class="dv">12</span>,<span class="dv">12</span>))</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Заполнение ненулевых элементов</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Растяжение вдоль оси балки (вдоль оси х)</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>        ke[<span class="dv">0</span>, <span class="dv">0</span>] <span class="op">=</span> k_ea<span class="op">;</span>  ke[<span class="dv">0</span>, <span class="dv">6</span>] <span class="op">=</span> <span class="op">-</span>k_ea<span class="op">;</span>  ke[<span class="dv">6</span>, <span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span>k_ea<span class="op">;</span>  ke[<span class="dv">6</span>, <span class="dv">6</span>] <span class="op">=</span> k_ea</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Изгиб в плоскости y (перемещения и повороты)</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>        ke[<span class="dv">1</span>, <span class="dv">1</span>] <span class="op">=</span> k11<span class="op">;</span>   ke[<span class="dv">1</span>, <span class="dv">5</span>] <span class="op">=</span> k12<span class="op">;</span>   ke[<span class="dv">1</span>, <span class="dv">7</span>] <span class="op">=</span> <span class="op">-</span>k11<span class="op">;</span>  ke[<span class="dv">1</span>, <span class="dv">11</span>] <span class="op">=</span> k12</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>        ke[<span class="dv">5</span>, <span class="dv">1</span>] <span class="op">=</span> k12<span class="op">;</span>   ke[<span class="dv">5</span>, <span class="dv">5</span>] <span class="op">=</span> k22<span class="op">;</span>   ke[<span class="dv">5</span>, <span class="dv">7</span>] <span class="op">=</span> <span class="op">-</span>k12<span class="op">;</span>  ke[<span class="dv">5</span>, <span class="dv">11</span>] <span class="op">=</span> k24</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>        ke[<span class="dv">7</span>, <span class="dv">1</span>] <span class="op">=</span> <span class="op">-</span>k11<span class="op">;</span>  ke[<span class="dv">7</span>, <span class="dv">5</span>] <span class="op">=</span> <span class="op">-</span>k12<span class="op">;</span>  ke[<span class="dv">7</span>, <span class="dv">7</span>] <span class="op">=</span> k11<span class="op">;</span>   ke[<span class="dv">7</span>, <span class="dv">11</span>] <span class="op">=</span> <span class="op">-</span>k12</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>        ke[<span class="dv">11</span>, <span class="dv">1</span>] <span class="op">=</span> k12<span class="op">;</span>  ke[<span class="dv">11</span>, <span class="dv">5</span>] <span class="op">=</span> k24<span class="op">;</span>  ke[<span class="dv">11</span>, <span class="dv">7</span>] <span class="op">=</span> <span class="op">-</span>k12<span class="op">;</span> ke[<span class="dv">11</span>, <span class="dv">11</span>] <span class="op">=</span> k22</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Изгиб в плоскости z (перемещения и повороты)</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>        ke[<span class="dv">2</span>, <span class="dv">2</span>] <span class="op">=</span> k11<span class="op">;</span>   ke[<span class="dv">2</span>, <span class="dv">4</span>] <span class="op">=</span> <span class="op">-</span>k12<span class="op">;</span>  ke[<span class="dv">2</span>, <span class="dv">8</span>] <span class="op">=</span> <span class="op">-</span>k11<span class="op">;</span>  ke[<span class="dv">2</span>, <span class="dv">10</span>] <span class="op">=</span> <span class="op">-</span>k12</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>        ke[<span class="dv">4</span>, <span class="dv">2</span>] <span class="op">=</span> <span class="op">-</span>k12<span class="op">;</span>  ke[<span class="dv">4</span>, <span class="dv">4</span>] <span class="op">=</span> k22<span class="op">;</span>   ke[<span class="dv">4</span>, <span class="dv">8</span>] <span class="op">=</span> k12<span class="op">;</span>   ke[<span class="dv">4</span>, <span class="dv">10</span>] <span class="op">=</span> k24</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>        ke[<span class="dv">8</span>, <span class="dv">2</span>] <span class="op">=</span> <span class="op">-</span>k11<span class="op">;</span>  ke[<span class="dv">8</span>, <span class="dv">4</span>] <span class="op">=</span> k12<span class="op">;</span>   ke[<span class="dv">8</span>, <span class="dv">8</span>] <span class="op">=</span> k11<span class="op">;</span>   ke[<span class="dv">8</span>, <span class="dv">10</span>] <span class="op">=</span> k12</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>        ke[<span class="dv">10</span>, <span class="dv">2</span>] <span class="op">=</span> <span class="op">-</span>k12<span class="op">;</span> ke[<span class="dv">10</span>, <span class="dv">4</span>] <span class="op">=</span> k24<span class="op">;</span>  ke[<span class="dv">10</span>, <span class="dv">8</span>] <span class="op">=</span> k12<span class="op">;</span>  ke[<span class="dv">10</span>, <span class="dv">10</span>] <span class="op">=</span> k22</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Кручение балки вокруг оси х</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>        ke[<span class="dv">3</span>, <span class="dv">3</span>] <span class="op">=</span> k_gj<span class="op">;</span>  ke[<span class="dv">3</span>, <span class="dv">9</span>] <span class="op">=</span> <span class="op">-</span>k_gj<span class="op">;</span> ke[<span class="dv">9</span>, <span class="dv">3</span>] <span class="op">=</span> <span class="op">-</span>k_gj<span class="op">;</span> ke[<span class="dv">9</span>, <span class="dv">9</span>] <span class="op">=</span> k_gj</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ke</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> assemble_global_matrix(<span class="va">self</span>, ke: NDArray) <span class="op">-&gt;</span> NDArray:</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>        <span class="co">""" Сборка глобальной матрицы жёсткости 18х18 """</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Создание пустой матрицы 18х18 (18 степеней свободы, 6 в каждом узле)</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>        k_global <span class="op">=</span> np.zeros((<span class="dv">18</span>, <span class="dv">18</span>))</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Добавление первого элемента (первые 12 строк и столбцов)</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>        k_global[<span class="dv">0</span>:<span class="dv">12</span>, <span class="dv">0</span>:<span class="dv">12</span>] <span class="op">+=</span> ke</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Добавление второго элемента (последние 12 строк и столбцов)</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>        k_global[<span class="dv">6</span>:<span class="dv">18</span>, <span class="dv">6</span>:<span class="dv">18</span>] <span class="op">+=</span> ke</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> k_global</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> apply_boundary_conditions(<span class="va">self</span>) <span class="op">-&gt;</span> Tuple[List[<span class="bu">int</span>], NDArray]:</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>        <span class="co">""" Применение граничных условий и определение свободных dofs """</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Шарнирные опоры в 1 и 3 узлах</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>        <span class="co">## (0 - u1x, 1 - u1y, 2 - u1z, 3 - theta1x, 12 - u3x, 13 - u3y, 14 - u3z, 15 - theta3z)</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>        <span class="co">#fixed_dofs = [0, 1, 2, 3, 12, 13, 14, 15]</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>        fixed_dofs <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">12</span>, <span class="dv">13</span>, <span class="dv">14</span>]</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Свободные степени свободы (всё, что не закреплено)</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>        free_dofs <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">18</span>) <span class="cf">if</span> i <span class="kw">not</span> <span class="kw">in</span> fixed_dofs]</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Вектор нагрузок (18 нулей, сила только по индексу 7 - u2y)</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>        f_full <span class="op">=</span> np.zeros(<span class="dv">18</span>)</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>        f_full[<span class="dv">7</span>] <span class="op">=</span> <span class="va">self</span>.F <span class="co">## Приложенная сила F2y</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> free_dofs, f_full</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> solve_system(<span class="va">self</span>, k_global: NDArray, free_dofs: List[<span class="bu">int</span>],</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>                     f_full: NDArray) <span class="op">-&gt;</span> Tuple[NDArray, <span class="bu">float</span>, NDArray, <span class="bu">float</span>]:</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>        <span class="co">""" Решение системы уравнений для перемещенеий """</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Оставляем только "свободные части" матрицы жёсткости и вектора нагрузок</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>        k_red <span class="op">=</span> k_global[np.ix_(free_dofs, free_dofs)]</span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>        f_red <span class="op">=</span> f_full[free_dofs]</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Решаем систему: K * u = F, где u - вектор перемещений</span></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Используем функцию из билиотеки NumPy</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>        u_red_np <span class="op">=</span> <span class="va">None</span></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>            u_red_np <span class="op">=</span> np.linalg.solve(k_red, f_red)</span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">ValueError</span> <span class="im">as</span> e:</span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"np.linalg.solve: система вырожденная - </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> u_red_np</span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> main() <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>    <span class="co">""" Основная функция """</span></span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>    beam <span class="op">=</span> BeamStructure()</span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Вывод исходный данных</span></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"E = </span><span class="sc">{</span>beam<span class="sc">.</span>E<span class="sc">:.2e}</span><span class="ss"> кгс/мм^2, G = </span><span class="sc">{</span>beam<span class="sc">.</span>G<span class="sc">:.2e}</span><span class="ss"> кгс/мм^2, "</span></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>          <span class="ss">f"A = </span><span class="sc">{</span>beam<span class="sc">.</span>A<span class="sc">:.2e}</span><span class="ss"> мм^2, Iz = </span><span class="sc">{</span>beam<span class="sc">.</span>Iz<span class="sc">:.2e}</span><span class="ss"> мм^4, "</span></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>          <span class="ss">f"J = </span><span class="sc">{</span>beam<span class="sc">.</span>J<span class="sc">:.2e}</span><span class="ss"> мм^4, L_e = </span><span class="sc">{</span>beam<span class="sc">.</span>L_e<span class="sc">:.2e}</span><span class="ss"> мм"</span>)</span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Расчёт промежуточных величин</span></span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>    phi <span class="op">=</span> beam.calculate_phi()</span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Phi = </span><span class="sc">{</span>phi<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a>    k_ea, k_gj, k11, k12, k22, k24 <span class="op">=</span> beam.calculate_stiffness_coefficients(phi)</span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"k11 = </span><span class="sc">{</span>k11<span class="sc">:.2e}</span><span class="ss">, k12 = </span><span class="sc">{</span>k12<span class="sc">:.2e}</span><span class="ss">, k22 = </span><span class="sc">{</span>k22<span class="sc">:.2e}</span><span class="ss">, "</span></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a>          <span class="ss">f"k24 = </span><span class="sc">{</span>k24<span class="sc">:.2e}</span><span class="ss">"</span>)</span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"k_ea = </span><span class="sc">{</span>k_ea<span class="sc">:.2e}</span><span class="ss">, k_gj = </span><span class="sc">{</span>k_gj<span class="sc">:.2e}</span><span class="ss">"</span>)</span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Построение матриц</span></span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a>    ke <span class="op">=</span> beam.build_local_stiffness_matrix(k_ea, k_gj, k11, k12, k22, k24)</span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>    k_global <span class="op">=</span> beam.assemble_global_matrix(ke)</span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Вывод матрицы</span></span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a>    np.set_printoptions(precision<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Полная матрица жесткости:"</span>)</span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(k_global)</span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Граничные условия и решение</span></span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a>    free_dofs, f_full <span class="op">=</span> beam.apply_boundary_conditions()</span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Свободные степени свободы: </span><span class="sc">{</span>free_dofs<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Вектор сил: </span><span class="sc">{</span>f_full<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a>    k_red <span class="op">=</span> k_global[np.ix_(free_dofs, free_dofs)]</span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Детерминант K_red = </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>det(k_red)<span class="sc">:.2e}</span><span class="ss">"</span>)</span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Решаем и выводим результат</span></span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a>    u_red_np <span class="op">=</span> beam.solve_system(k_global, free_dofs, f_full)</span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> u_red_np <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Перемещения (NumPy): </span><span class="sc">{</span>u_red_np<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Прогиб в точке u_2y (NumPy): </span><span class="sc">{</span>u_red_np[free_dofs.index(<span class="dv">7</span>)]<span class="sc">:.4f}</span><span class="ss"> мм"</span>)</span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Перемещения (NumPy) не удалось вычислить из-за вырожденности"</span>)</span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true" tabindex="-1"></a>    main()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Результатом его выполнения будет следующее сообщение:</p>
<pre><code>E = 2.00e+04 кгс/мм^2, G = 7.69e+03 кгс/мм^2, A = 7.85e+01 мм^2, Iz = 4.91e+02 мм^4, J = 9.82e+02 мм^4, L_e = 3.00e+02 мм
Phi = 0.0019
k11 = 4.35e+00, k12 = 6.53e+02, k22 = 1.31e+05, k24 = 6.53e+04
k_ea = 5.24e+03, k_gj = 2.52e+04
Полная матрица жесткости:
[[ 5.236e+03  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00
  -5.236e+03  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00
   0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00]
 [ 0.000e+00  4.355e+00  0.000e+00  0.000e+00  0.000e+00  6.532e+02
   0.000e+00 -4.355e+00  0.000e+00  0.000e+00  0.000e+00  6.532e+02
   0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00]
 [ 0.000e+00  0.000e+00  4.355e+00  0.000e+00 -6.532e+02  0.000e+00
   0.000e+00  0.000e+00 -4.355e+00  0.000e+00 -6.532e+02  0.000e+00
   0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00]
 [ 0.000e+00  0.000e+00  0.000e+00  2.517e+04  0.000e+00  0.000e+00
   0.000e+00  0.000e+00  0.000e+00 -2.517e+04  0.000e+00  0.000e+00
   0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00]
 [ 0.000e+00  0.000e+00 -6.532e+02  0.000e+00  1.307e+05  0.000e+00
   0.000e+00  0.000e+00  6.532e+02  0.000e+00  6.526e+04  0.000e+00
   0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00]
 [ 0.000e+00  6.532e+02  0.000e+00  0.000e+00  0.000e+00  1.307e+05
   0.000e+00 -6.532e+02  0.000e+00  0.000e+00  0.000e+00  6.526e+04
   0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00]
 [-5.236e+03  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00
   1.047e+04  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00
  -5.236e+03  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00]
 [ 0.000e+00 -4.355e+00  0.000e+00  0.000e+00  0.000e+00 -6.532e+02
   0.000e+00  8.710e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00
   0.000e+00 -4.355e+00  0.000e+00  0.000e+00  0.000e+00  6.532e+02]
 [ 0.000e+00  0.000e+00 -4.355e+00  0.000e+00  6.532e+02  0.000e+00
   0.000e+00  0.000e+00  8.710e+00  0.000e+00  0.000e+00  0.000e+00
   0.000e+00  0.000e+00 -4.355e+00  0.000e+00 -6.532e+02  0.000e+00]
 [ 0.000e+00  0.000e+00  0.000e+00 -2.517e+04  0.000e+00  0.000e+00
   0.000e+00  0.000e+00  0.000e+00  5.035e+04  0.000e+00  0.000e+00
   0.000e+00  0.000e+00  0.000e+00 -2.517e+04  0.000e+00  0.000e+00]
 [ 0.000e+00  0.000e+00 -6.532e+02  0.000e+00  6.526e+04  0.000e+00
   0.000e+00  0.000e+00  0.000e+00  0.000e+00  2.614e+05  0.000e+00
   0.000e+00  0.000e+00  6.532e+02  0.000e+00  6.526e+04  0.000e+00]
 [ 0.000e+00  6.532e+02  0.000e+00  0.000e+00  0.000e+00  6.526e+04
   0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  2.614e+05
   0.000e+00 -6.532e+02  0.000e+00  0.000e+00  0.000e+00  6.526e+04]
 [ 0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00
  -5.236e+03  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00
   5.236e+03  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00]
 [ 0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00
   0.000e+00 -4.355e+00  0.000e+00  0.000e+00  0.000e+00 -6.532e+02
   0.000e+00  4.355e+00  0.000e+00  0.000e+00  0.000e+00 -6.532e+02]
 [ 0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00
   0.000e+00  0.000e+00 -4.355e+00  0.000e+00  6.532e+02  0.000e+00
   0.000e+00  0.000e+00  4.355e+00  0.000e+00  6.532e+02  0.000e+00]
 [ 0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00
   0.000e+00  0.000e+00  0.000e+00 -2.517e+04  0.000e+00  0.000e+00
   0.000e+00  0.000e+00  0.000e+00  2.517e+04  0.000e+00  0.000e+00]
 [ 0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00
   0.000e+00  0.000e+00 -6.532e+02  0.000e+00  6.526e+04  0.000e+00
   0.000e+00  0.000e+00  6.532e+02  0.000e+00  1.307e+05  0.000e+00]
 [ 0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00
   0.000e+00  6.532e+02  0.000e+00  0.000e+00  0.000e+00  6.526e+04
   0.000e+00 -6.532e+02  0.000e+00  0.000e+00  0.000e+00  1.307e+05]]
Свободные степени свободы: [3, 4, 5, 6, 7, 8, 9, 10, 11, 15, 16, 17]
Вектор сил: [0. 0. 0. 0. 0. 0. 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
Детерминант K_red = 0.00e+00
np.linalg.solve: система вырожденная - Singular matrix
Перемещения (NumPy) не удалось вычислить из-за вырожденности</code></pre>
<p>Теперь добавим ограничение на угол поворота θx вдоль оси балки (и заодно закомментируем вывод матрицы жёсткости, чтобы не мешалась)</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Шарнирные опоры в 1 и 3 узлах</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">## (0 - u1x, 1 - u1y, 2 - u1z, 3 - theta1x, 12 - u3x, 13 - u3y, 14 - u3z, 15 - theta3z)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>fixed_dofs <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">12</span>, <span class="dv">13</span>, <span class="dv">14</span>, <span class="dv">15</span>]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">#fixed_dofs = [0, 1, 2, 12, 13, 14]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Результатом выполнения такого кода будет уже знакомая нам величина прогиба:</p>
<pre><code>E = 2.00e+04 кгс/мм^2, G = 7.69e+03 кгс/мм^2, A = 7.85e+01 мм^2, Iz = 4.91e+02 мм^4, J = 9.82e+02 мм^4, L_e = 3.00e+02 мм
Phi = 0.0019
k11 = 4.35e+00, k12 = 6.53e+02, k22 = 1.31e+05, k24 = 6.53e+04
k_ea = 5.24e+03, k_gj = 2.52e+04
Свободные степени свободы: [4, 5, 6, 7, 8, 9, 10, 11, 16, 17]
Вектор сил: [0. 0. 0. 0. 0. 0. 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
Детерминант K_red = 2.82e+40
Перемещения (NumPy): [ 0.00000000e+00  2.29183049e-03  0.00000000e+00  4.58589551e-01
 -0.00000000e+00  0.00000000e+00  0.00000000e+00  8.49677854e-20
  0.00000000e+00 -2.29183049e-03]
Прогиб в точке u_2y (NumPy): 0.4586 мм</code></pre>
<p>Тут можно заметить, что решение нашей задачи с использованием функции np.linalg.solve из библиотеки NumPy является таким же «прозрачным», как и решение с помощью остального ПО. Попробуем разобраться, какие процедуры происходят при работе этой функции. Классическим методом решения системы <span class="math inline">\(K \cdot x = f\)</span> является метод Гаусса, при котором матрица <span class="math inline">\(K\)</span> с помощью элементарных операций (перестановки строк, умножения и вычитания) превращается в верхнетреугольную (с нулями под диагональю). Чтобы в процессе избежать деления на маленькие числа можно выбрать самый большой по модулю элемент в столбце как ведущий (при этом ведущий элемент лежит на главной диагонали или ниже). Рассмотрим простой пример в виде совместимой системы (вектор <span class="math inline">\(f\)</span> можно представить как линейную комбинацию столбцов <span class="math inline">\(K\)</span>) с вырожденной (пушто третья строка является суммой первых двух) матрицей:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
5 &amp; 7 &amp; 9
\end{bmatrix}
\cdot
x=
\begin{bmatrix}
1 \\ 2 \\ 3
\end{bmatrix}
\]</span></p>
<p>Максимальный элемент в первом столбце равен 5 и содержащая эту величину строка отправляется на первое место:</p>
<p><span class="math display">\[
\begin{bmatrix}
5 &amp; 7 &amp; 9 \\
4 &amp; 5 &amp; 6 \\
1 &amp; 2 &amp; 3
\end{bmatrix}
\cdot
x=
\begin{bmatrix}
3 \\ 2 \\ 1
\end{bmatrix}
\]</span></p>
<p>Теперь разделим первую строку на 5, чтобы элемент (1,1) стал равен единице:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 1,4 &amp; 1,8 \\
4 &amp; 5 &amp; 6 \\
1 &amp; 2 &amp; 3
\end{bmatrix}
\cdot
x=
\begin{bmatrix}
0,6 \\ 2 \\ 1
\end{bmatrix}
\]</span></p>
<p>Повычитаем из второй и третьей строк первую строку в нужно количестве таким образом, чтобы в столбце под единичкой получились нули (очевидно, что из второй строки нужно вычесть 4 первых, а из третьей строки – одну первую):</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 1,4 &amp; 1,8 \\
0 &amp; -0,6 &amp; -1,2 \\
0 &amp; 0,6 &amp; 1,2
\end{bmatrix}
\cdot
x=
\begin{bmatrix}
0,6 \\ -0,4 \\ 0,4
\end{bmatrix}
\]</span></p>
<p>Переходим ко второму столбцу: максимальное значение по модулю равно 1,4, но оно уже находится сверху, поэтому придётся брать следующее значение, равное -0,6. Делим на него вторую строку, получаем:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 1,4 &amp; 1,8 \\
0 &amp; 1 &amp; 2 \\
0 &amp; 0,6 &amp; 1,2
\end{bmatrix}
\cdot
x=
\begin{bmatrix}
0,6 \\ 0,667 \\ 0,4
\end{bmatrix}
\]</span></p>
<p>А теперь из последней строки вычтем вторую строку в количестве 0,6 штук:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 1,4 &amp; 1,8 \\
0 &amp; 1 &amp; 2 \\
0 &amp; 0 &amp; 0
\end{bmatrix}
\cdot
x=
\begin{bmatrix}
0,6 \\ 0,667 \\ 0
\end{bmatrix}
\]</span></p>
<p>Переходя к последнему столбцу, замечаем, что ведущий элемент равен 0, делить на него строку мы не можем и радостно вываливаемся из решения. Отметим, что формально система имеет бесконечное количество решений, которые в общем виде можно записать как:</p>
<p><span class="math display">\[
x=
\begin{bmatrix}
-0,333+t \\ 0,667-2 \cdot t \\ t
\end{bmatrix}
\]</span></p>
<p>Реализуем рассмотренный подход в задаче о шарнирно опёртой балке. Соответствующая функция будет выглядеть следующим образом:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> my_solve(A: np.ndarray, b: np.ndarray) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Решение системы уравнений А * х = b методом Гаусса с частичным выбором ведущего элемента</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">         A(np.ndarray): Квадратная матрица (n x n)</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co">         b(np.ndarray): Вектор правой части (n)</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co">        np.ndarray: Вектор решения х (n)</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Raises:</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co">        ValueError: Если матрица не квадратная или вырожденная (детерминант ≈ 0)</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Размер системы - число уравнений (и переменных)</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(b)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Проверяем, что матрица квадратная и соответствует вектору b</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> A.shape <span class="op">!=</span> (n, n):</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Матрица А должна быть квадратной и соответствовать b!"</span>)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Копируем А и b, чтобы не менять оригиналы (работаем с копиями)</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> A.copy()</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> b.copy()</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Прямой ход: превращаем А в верхнетреугольную матрицу (нули под диагональю)</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Ищем ведущий элемент (pivot) - самый большой по модулю в столбце i...</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        max_idx <span class="op">=</span> i <span class="co">## ...начинаем с текущей строки...</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>, n):     <span class="co">## ...и смотрим все строки ниже</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">abs</span>(A[k, i]) <span class="op">&gt;</span> <span class="bu">abs</span>(A[max_idx, i]):</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>                max_idx <span class="op">=</span> k     <span class="co">## Запоминаем строку с максимальным элементом</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Проверяем, не слишком ли маленький pivot (если ≈ 0, матрица вырожденная)</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>        pivot <span class="op">=</span> A[max_idx, i]</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">abs</span>(pivot) <span class="op">&lt;</span> <span class="fl">1e-10</span>:      <span class="co">## 1e-10 — порог для учёта ошибок округления</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Матрица вырожденна на шаге </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">!"</span>)</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Если нашли больший элемент ниже, меняем строки местами</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> max_idx <span class="op">!=</span> i:</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>            A[[i, max_idx]] <span class="op">=</span> A[[max_idx, i]]       <span class="co">## Меняем строки в матрице A</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>            b[i], b[max_idx] <span class="op">=</span> b[max_idx], b[i]     <span class="co">## Меняем элементы в векторе b</span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Делаем ведущий элемент равным 1: делим строку i на pivot</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>        A[i, :] <span class="op">=</span> A[i, :] <span class="op">/</span> pivot</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>        b[i] <span class="op">=</span> b[i] <span class="op">/</span> pivot</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Убираем элементы под ведущим элементом (делаем нули в столбце i)</span></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, n):                   <span class="co">## Проходим по строкам ниже текущей</span></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>            factor <span class="op">=</span> A[j, i]                        <span class="co">## Коэффициент, на который умножаем строку i</span></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>            A[j, :] <span class="op">=</span> A[j, :] <span class="op">-</span> factor <span class="op">*</span> A[i, :]    <span class="co">## Вычитаем, чтобы обнулить A[j, i]</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>            b[j] <span class="op">=</span> b[j] <span class="op">-</span> factor <span class="op">*</span> b[i]             <span class="co">## То же для правой части</span></span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Обратный ход: решаем систему снизу вверх, начиная с последнего уравнения</span></span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.zeros(n)                         <span class="co">## Создаём вектор для хранения решения</span></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):            <span class="co">## Идём от последней строки к первой</span></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>        x[i] <span class="op">=</span> b[i]                         <span class="co">## Берём правую часть текущего уравнения</span></span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Вычитаем все уже найденные переменные (x[j] для j &gt; i)</span></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>, n):</span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>            x[i] <span class="op">=</span> x[i] <span class="op">-</span> A[i, j] <span class="op">*</span> x[j]    <span class="co">## Учитываем влияние верхних элементов</span></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Результат решения задачи с помощью этой функции будет аналогичен предыдущему – максимальный прогиб <span class="math inline">\(0,4586~{\text{мм}}\)</span> при полном наборе кинематических граничных условий (с учётом угла поворота <span class="math inline">\(\theta_x\)</span>) и сообщение об ошибке при неполном наборе граничных условий.</p>
<p>Покопавшись в доксах, можно предположить, что встроенная в NumPy функция реализует PLU-разложение, при котором матрица <span class="math inline">\(K\)</span> «разбивается» на три части так, что <span class="math inline">\(P \cdot K = L \cdot U\)</span>, где <span class="math inline">\(P\)</span> – матрица перестановок (показывающая, как менять строки), <span class="math inline">\(L\)</span> – нижняя треугольная матрица с единицами на главной диагонали, <span class="math inline">\(U\)</span> – верхняя треугольная матрица общего вида. После «разбиения» система решается в два шага: прямой ход <span class="math inline">\(L \cdot y = P \cdot f\)</span> и обратный ход <span class="math inline">\(U \cdot x = y\)</span>. Рассмотрим тот же простой пример с вырожденной матрицей:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
5 &amp; 7 &amp; 9
\end{bmatrix}
\cdot
x=
\begin{bmatrix}
1 \\ 2 \\ 3
\end{bmatrix}
\]</span></p>
<p>Максимальное значение в первом столбце равно 5 и соответствует третьей строке. Таким образом, в рамках алгоритма необходимо отправить третью строку на первое место, первую строку – на третье, а вторую оставить на месте. Матрица <span class="math inline">\(Р\)</span> примет следующий вид:</p>
<p><span class="math display">\[
P=
\begin{bmatrix}
0 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 0
\end{bmatrix}
\]</span></p>
<p>А произведение <span class="math inline">\(P \cdot K\)</span>:</p>
<p><span class="math display">\[
P \cdot K =
\begin{bmatrix}
5 &amp; 7 &amp; 9 \\
4 &amp; 5 &amp; 6 \\
1 &amp; 2 &amp; 3
\end{bmatrix}
\]</span></p>
<p>Обнуляем элементы под пятёркой, для чего вычитаем 0,8 первых строк из второй, и 0,2 первых строк из третьей:</p>
<p><span class="math display">\[
\begin{bmatrix}
5 &amp; 7 &amp; 9 \\
0 &amp; -0,6 &amp; -1,2 \\
0 &amp; 0,6 &amp; 1,2
\end{bmatrix}
\]</span></p>
<p>Теперь обнуляем элементы под -0,6, для чего вычитаем -1 вторых строк из третьей, получим:</p>
<p><span class="math display">\[
U=
\begin{bmatrix}
5 &amp; 7 &amp; 9 \\
0 &amp; -0,6 &amp; -1,2 \\
0 &amp; 0 &amp; 0
\end{bmatrix}
\]</span></p>
<p>А матрица, куда отправляются коэффициенты вычитания, принимает вид:</p>
<p><span class="math display">\[
L=
\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0,8 &amp; 1 &amp; 0 \\
0,2 &amp; -1 &amp; 1
\end{bmatrix}
\]</span></p>
<p>Нужные треугольные матрицы сформированы, матрица перестановок тоже, решаем <span class="math inline">\(L \cdot y = P \cdot f\)</span>:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0,8 &amp; 1 &amp; 0 \\
0,2 &amp; -1 &amp; 1
\end{bmatrix}
\cdot
\begin{bmatrix}
y_1 \\ y_2 \\ y_3
\end{bmatrix}
=
\begin{bmatrix}
3 \\ 2 \\ 1
\end{bmatrix}
\]</span></p>
<p>Получаем:</p>
<p><span class="math display">\[
y=
\begin{bmatrix}
3 \\ -0,4 \\ 0
\end{bmatrix}
\]</span></p>
<p>Решаем <span class="math inline">\(U \cdot x = y\)</span>:</p>
<p><span class="math display">\[
\begin{bmatrix}
5 &amp; 7 &amp; 9 \\
0 &amp; -0,6 &amp; -1,2 \\
0 &amp; 0 &amp; 0
\end{bmatrix}
\cdot
\begin{bmatrix}
x_1 \\ x_2 \\ x_3
\end{bmatrix}
=
\begin{bmatrix}
3 \\ -0,4 \\ 0
\end{bmatrix}
\]</span></p>
<p>Здесь так же, как и в предыдущем варианте, ведущий элемент в третьем столбце равен нулю, а решение уравнения:</p>
<p><span class="math display">\[
0 \cdot x_3 = 0
\]</span></p>
<p>приводит к делению на ноль и неудаче в решении системы. При этом формально система всё ещё имеет бесконечное количество решений.</p>
<p>Реализуем рассмотренный подход в задаче о шарнирно опёртой балке. Нужные для этого функции будут выглядеть следующим образом:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plu_decomposition(A: np.ndarray) <span class="op">-&gt;</span> Tuple[np.ndarray, np.ndarray, np.ndarray]:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Выполняет PLU-разложение матрицы A на P (перестановки), L (нижнетреугольная), U (верхнетреугольная).</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">      Args:</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">        A (np.ndarray): Квадратная матрица (n x n).</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">        Tuple[np.ndarray, np.ndarray, np.ndarray]: Матрицы P, L, U.</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Raises:</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">        ValueError: Если матрица не квадратная.</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> A.shape[<span class="dv">0</span>]</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> A.shape[<span class="dv">0</span>] <span class="op">!=</span> A.shape[<span class="dv">1</span>]:</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Матрица должна быть квадратной!"</span>)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Копируем А</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> A.copy()</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Инициализируем P (единичная матрица), L и U</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> np.eye(n)  <span class="co">## Матрица перестановок начинается как единичная</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    L <span class="op">=</span> np.zeros((n, n))</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> np.zeros((n, n))</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    np.fill_diagonal(L, <span class="dv">1</span>)  <span class="co"># Единицы на диагонали L</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Разложение с перестановками</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Ищем максимальный элемент в столбце i от i до конца</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        max_idx <span class="op">=</span> i</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, n):</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">abs</span>(A[k, i]) <span class="op">&gt;</span> <span class="bu">abs</span>(A[max_idx, i]):</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>                max_idx <span class="op">=</span> k</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Если нужно, меняем строки в A и P</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> max_idx <span class="op">!=</span> i:</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>            A[[i, max_idx]] <span class="op">=</span> A[[max_idx, i]]</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>            P[[i, max_idx]] <span class="op">=</span> P[[max_idx, i]]</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Исправляем L: меняем строки до i (кроме диагонали)</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>                L[[i, max_idx], :i] <span class="op">=</span> L[[max_idx, i], :i]</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Заполняем U: элементы на диагонали и выше</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i, n):</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>            U[i, j] <span class="op">=</span> A[i, j] <span class="op">-</span> <span class="bu">sum</span>(L[i, k] <span class="op">*</span> U[k, j] <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i))</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Заполняем L: элементы под диагональю</span></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, n):</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">abs</span>(U[i, i]) <span class="op">&lt;</span> <span class="fl">1e-10</span>:</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Деление на ноль на шаге </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">!"</span>)</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>            L[j, i] <span class="op">=</span> (A[j, i] <span class="op">-</span> <span class="bu">sum</span>(L[j, k] <span class="op">*</span> U[k, i] <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i))) <span class="op">/</span> U[i, i]</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> P, L, U</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plu_solve(A: np.ndarray, b: np.ndarray) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a><span class="co">     Решает систему A * x = b с помощью PLU-разложения.</span></span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a><span class="co">     Args:</span></span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a><span class="co">         A (np.ndarray): Квадратная матрица (n x n).</span></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a><span class="co">         b (np.ndarray): Вектор правой части (n).</span></span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a><span class="co">     Returns:</span></span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a><span class="co">         np.ndarray: Вектор решения x (n).</span></span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a><span class="co">     """</span></span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Получаем P, L, U</span></span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a>    P, L, U <span class="op">=</span> plu_decomposition(A)</span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(b)</span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> b.copy()</span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Применяем перестановки к b: Pb = P * b</span></span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a>    Pb <span class="op">=</span> P <span class="op">@</span> b</span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Прямой ход: решаем L * y = Pb</span></span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.zeros(n)</span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a>        y[i] <span class="op">=</span> Pb[i] <span class="op">-</span> <span class="bu">sum</span>(L[i, j] <span class="op">*</span> y[j] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i))</span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Обратный ход: решаем U * x = y</span></span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.zeros(n)</span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">abs</span>(U[i, i]) <span class="op">&lt;</span> <span class="fl">1e-10</span>:</span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Деление на ноль в U на шаге </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">!"</span>)</span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true" tabindex="-1"></a>        x[i] <span class="op">=</span> (y[i] <span class="op">-</span> <span class="bu">sum</span>(U[i, j] <span class="op">*</span> x[j] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, n))) <span class="op">/</span> U[i, i]</span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Результат решения задачи с помощью этой функции также будет аналогичен предыдущему – максимальный прогиб <span class="math inline">\(0,4586~{\text{мм}}\)</span> при полном наборе кинематических граничных условий (с учётом угла поворота <span class="math inline">\(\theta_x\)</span>) и сообщение об ошибке при неполном наборе граничных условий.</p>
<p>При этом, если сравнить между собой полученные в ходе решения задачи векторы перемещений, то результат будет выглядеть как:</p>
<pre><code>Разница my_solve vs NumPy: [0.000e+00 0.000e+00 0.000e+00 5.551e-17 0.000e+00 0.000e+00 0.000e+00
 8.497e-20 0.000e+00 0.000e+00]
Разница plu_solve vs NumPy: [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]</code></pre>
<p>Таким образом, наше предположение о том, что встроенная в NumPy функция реализует PLU-разложение, можно считать верным. Заметим, что ни один из рассмотренных подходов не позволил получить решение для системы с вырожденной матрицей.</p>
<hr>
</section>
<section id="эталонное-решение-и-сравнение-с-полученными-ранее-результатами" class="level3">
<h3 class="anchored" data-anchor-id="эталонное-решение-и-сравнение-с-полученными-ранее-результатами">2.2 Эталонное решение и сравнение с полученными ранее результатами</h3>
<hr>
<p>К этому моменту уже была получена целая куча результатов, однако не понятно насколько они далеки от истины. Рассмотрим аналитическое решение для максимального прогиба балки Эйлера:</p>
<p><span class="math display">\[
u_{max} = \frac{F \cdot L^3}{48 \cdot E \cdot I_z} = \frac{1 \cdot 600^3}{48 \cdot 20000 \cdot 490,87} = 0,458~{\text{мм}}
\]</span></p>
<p>где <span class="math inline">\(F\)</span> - поперечная сила, <span class="math inline">\(F = 1~{\text{кгс}}\)</span>; <span class="math inline">\(L\)</span> – длина балки, <span class="math inline">\(L = 600~{\text{мм}}\)</span>; <span class="math inline">\(E\)</span> – модуль упругости, <span class="math inline">\(E=20000~{\text{кгс/мм}}^2\)</span>; <span class="math inline">\(I_z\)</span> – момент инерции поперечного сечения, <span class="math inline">\(I_z = \frac{\pi \cdot D^4}{64} = \frac{\pi \cdot 10^4}{64} = 490,87~{\text{мм}}^4\)</span>; <span class="math inline">\(D\)</span> – диаметр поперечного сечения, <span class="math inline">\(D = 10~{\text{мм}}\)</span>.</p>
<p>Аналитическое решение для максимального прогиба балки Тимошенко:</p>
<p><span class="math display">\[
u_{max} = \frac{F \cdot L^3}{48 \cdot E \cdot I_z} + \frac{F}{k \cdot G \cdot A} = \frac{1 \cdot 600^3}{48 \cdot 20000 \cdot 490,87} + \frac{1}{1,111 \cdot 7692 \cdot 78,54} = 0,458~{\text{мм}}
\]</span></p>
<p>где <span class="math inline">\(A\)</span> – площадь поперечного сечения, <span class="math inline">\(A = \frac{\pi \cdot D^2}{4} = 78,54~{\text{мм}}^2\)</span>; <span class="math inline">\(k\)</span> – коэффициент, который для круглого поперечного сечения равен <span class="math inline">\(k = 10/9 = 1,111\)</span>; <span class="math inline">\(G\)</span> – модуль сдвига, <span class="math inline">\(G = \frac{E}{2 \cdot (1 + \mu)} = \frac{20000}{2 \cdot (1+0,3} = 7692~{\text{кгс/мм}}^2\)</span>.</p>
<p>Таким образом, для нашей балки результаты получились одинаковыми (пушто наша балка достаточно длинная и влияние сдвига – минимально).</p>
<p>Теперь настало время сопоставить полученные ранее результаты с эталонным решением. Сведём их в таблицу 1.</p>
<div id="tbl-table1" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-table1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: Таблица 1
</figcaption>
<div aria-describedby="tbl-table1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 24%">
<col style="width: 37%">
<col style="width: 13%">
<col style="width: 24%">
</colgroup>
<thead>
<tr class="header">
<th>Программа</th>
<th>Результат решения задачи в исходной постановке</th>
<th>Максимальный прогиб</th>
<th>Расхождение с аналитическим решением</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ANSYS</td>
<td>Ошибка без фиксации вращений вращений вращений вращений</td>
<td>-0,460 мм</td>
<td>0,2%</td>
</tr>
<tr class="even">
<td>NASTRAN</td>
<td>Ошибка без фиксации вращений</td>
<td>-0,459 мм</td>
<td>0,2%</td>
</tr>
<tr class="odd">
<td>COMSOL</td>
<td>Да</td>
<td>-0,458 мм</td>
<td>0%</td>
</tr>
<tr class="even">
<td>ABAQUS</td>
<td>Да</td>
<td>-0,428 мм</td>
<td>7%</td>
</tr>
<tr class="odd">
<td>OptiStruct</td>
<td>Да</td>
<td>-0,459 мм</td>
<td>0,2%</td>
</tr>
<tr class="even">
<td>ЛОТОС</td>
<td>Да</td>
<td>-0,458 мм</td>
<td>0%</td>
</tr>
<tr class="odd">
<td>Код на Python с использованием функции из библиотеки NumPy</td>
<td>Ошибка без фиксации вращений</td>
<td>-0,459 мм</td>
<td>0,2%</td>
</tr>
<tr class="even">
<td>Код на Python с использованием PLU-разложения</td>
<td>Ошибка без фиксации вращений</td>
<td>-0,459 мм</td>
<td>0,2%</td>
</tr>
<tr class="odd">
<td>Код на Python с использованием метода Гаусса</td>
<td>Ошибка без фиксации вращений</td>
<td>-0,459 мм</td>
<td>0,2%</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<hr>
</section>
<section id="промежуточный-вывод" class="level3">
<h3 class="anchored" data-anchor-id="промежуточный-вывод">2.3 Промежуточный вывод</h3>
<hr>
<p>По результатам проведённого ресёрча можно сделать следующие выводы:</p>
<ol type="1">
<li><p>Для задачи в исходной постановке (без ограничений на углы поворота) матрица жёсткости после приложения граничных условий становится вырожденной. Это связанно с тем, что оставшиеся свободные вращательные (вокруг оси балки) степени свободы позволяют системе совершать бесконтрольное вращение, что физически означает отсутствие равновесия (при отсутствии дополнительных ограничений).</p></li>
<li><p>Такие программные продукты как ANSYS и NASTRAN, без использования дополнительных опций, используют классический подход с прямым обращением матрицы для линейных статических задач, т.е. пытаются решить систему уравнений <span class="math inline">\(K \cdot u=F\)</span> через разложение матрицы <span class="math inline">\(K\)</span>. В том случае, если матрица вырожденная и не было применено никаких «костылей» – решатель выдаёт сообщение об ошибке.</p></li>
<li><p>Такие программные продукты как COMSOL, ABAQUS и OptiStruct (ну и, судя по всему, упомянутый господином Ш. SolidWorks Simulation) используют в качестве опций по умолчанию какие-то «костыли», позволяющие обрабатывать «вырожденность» матрицы жёсткости и получать таким образом конечное решение.</p></li>
<li><p>Все рассмотренные программные продукты (кроме ABAQUS), а также реализованный на Python код позволили получить решение, которое удовлетворительно соотносится с аналитическим, несмотря на, мягко скажем, небольшое количество конечных элементов в модели.</p></li>
</ol>
<p>Что же, едем дальше.</p>
<hr>
</section>
<section id="немножко-про-матрицы-жёсткости" class="level3">
<h3 class="anchored" data-anchor-id="немножко-про-матрицы-жёсткости">2.4 Немножко про матрицы жёсткости</h3>
<hr>
<p>Не нашёл, куда бы это ещё приткнуть, пушто на первоначальный вопрос вида «почему у меня тут не считает, а вон там считает?» формируемые программными продуктами матрицы жёсткости не отвечают. Но я за каким-то хреном полез их смотреть – не пропадать же добру.</p>
<p>Запишем матрицу жёсткости всей модели, которую мы формируем ручками. Она будет выглядеть вот так:</p>
<div class="scroll-matrix">
<p><span class="math display">\[
K=
\begin{bmatrix}
5.236e+03  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -5.236e+03 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 4.355e+00  &amp; 0          &amp; 0          &amp; 0          &amp; 6.532e+02  &amp; 0          &amp; -4.355e+00 &amp; 0          &amp; 0          &amp; 0          &amp; 6.532e+02  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; 4.355e+00  &amp; 0          &amp; -6.532e+02 &amp; 0          &amp; 0          &amp; 0          &amp; -4.355e+00 &amp; 0          &amp; -6.532e+02 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 2.517e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -2.517e+04 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; -6.532e+02 &amp; 0          &amp; 1.307e+05  &amp; 0          &amp; 0          &amp; 0          &amp; 6.532e+02  &amp; 0          &amp; 6.526e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 6.532e+02  &amp; 0          &amp; 0          &amp; 0          &amp; 1.307e+05  &amp; 0          &amp; -6.532e+02 &amp; 0          &amp; 0          &amp; 0          &amp; 6.526e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
-5.236e+03 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 1.047e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -5.236e+03 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; -4.355e+00 &amp; 0          &amp; 0          &amp; 0          &amp; -6.532e+02 &amp; 0          &amp; 8.710e+00  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -4.355e+00 &amp; 0          &amp; 0          &amp; 0          &amp; 6.532e+02 \\
0          &amp; 0          &amp; -4.355e+00 &amp; 0          &amp; 6.532e+02  &amp; 0          &amp; 0          &amp; 0          &amp; 8.710e+00  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -4.355e+00 &amp; 0          &amp; -6.532e+02 &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; -2.517e+04 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 5.035e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -2.517e+04 &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; -6.532e+02 &amp; 0          &amp; 6.526e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 2.614e+05  &amp; 0          &amp; 0          &amp; 0          &amp; 6.532e+02  &amp; 0          &amp; 6.526e+04  &amp; 0 \\
0          &amp; 6.532e+02  &amp; 0          &amp; 0          &amp; 0          &amp; 6.526e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 2.614e+05  &amp; 0          &amp; -6.532e+02 &amp; 0          &amp; 0          &amp; 0          &amp; 6.526e+04 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -5.236e+03 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 5.236e+03  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -4.355e+00 &amp; 0          &amp; 0          &amp; 0          &amp; -6.532e+02 &amp; 0          &amp; 4.355e+00  &amp; 0          &amp; 0          &amp; 0          &amp; -6.532e+02 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -4.355e+00 &amp; 0          &amp; 6.532e+02  &amp; 0          &amp; 0          &amp; 0          &amp; 4.355e+00  &amp; 0          &amp; 6.532e+02  &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -2.517e+04 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 2.517e+04  &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -6.532e+02 &amp; 0          &amp; 6.526e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 6.532e+02  &amp; 0          &amp; 1.307e+05  &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 6.532e+02  &amp; 0          &amp; 0          &amp; 0          &amp; 6.526e+04  &amp; 0          &amp; -6.532e+02 &amp; 0          &amp; 0          &amp; 0          &amp; 1.307e+05
\end{bmatrix}
\]</span></p>
</div>
<p>Если дёрнуть матрицу жёсткости из <span class="math inline">\(NASTRAN\)</span>, то она будет выглядеть вот так:</p>
<div class="scroll-matrix">
<p><span class="math display">\[
K=
\begin{bmatrix}
5.236e+03  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -5.236e+03 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 4.353e+00  &amp; 0          &amp; 0          &amp; 0          &amp; 6.529e+02  &amp; 0          &amp; -4.353e+00 &amp; 0          &amp; 0          &amp; 0          &amp; 6.529e+02  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; 4.353e+00  &amp; 0          &amp; -6.529e+02 &amp; 0          &amp; 0          &amp; 0          &amp; -4.353e+00 &amp; 0          &amp; -6.529e+02 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 2.515e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -2.515e+04 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; -6.529e+02 &amp; 0          &amp; 1.307e+05  &amp; 0          &amp; 0          &amp; 0          &amp; 6.529e+02  &amp; 0          &amp; 6.521e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 6.529e+02  &amp; 0          &amp; 0          &amp; 0          &amp; 1.307e+05  &amp; 0          &amp; -6.529e+02 &amp; 0          &amp; 0          &amp; 0          &amp; 6.521e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
-5.236e+03 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 1.047e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -5.236e+03 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; -4.355e+00 &amp; 0          &amp; 0          &amp; 0          &amp; -6.529e+02 &amp; 0          &amp; 8.705e+00  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -4.353e+00 &amp; 0          &amp; 0          &amp; 0          &amp; 6.529e+02 \\
0          &amp; 0          &amp; -4.353e+00 &amp; 0          &amp; 6.529e+02  &amp; 0          &amp; 0          &amp; 0          &amp; 8.705e+00  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -4.353e+00 &amp; 0          &amp; -6.529e+02 &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; -2.515e+04 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 5.030e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -2.515e+04 &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; -6.529e+02 &amp; 0          &amp; 6.521e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 2.613e+05  &amp; 0          &amp; 0          &amp; 0          &amp; 6.529e+02  &amp; 0          &amp; 6.521e+04  &amp; 0 \\
0          &amp; 6.529e+02  &amp; 0          &amp; 0          &amp; 0          &amp; 6.521e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 2.613e+05  &amp; 0          &amp; -6.529e+02 &amp; 0          &amp; 0          &amp; 0          &amp; 6.521e+04 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -5.236e+03 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 5.236e+03  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -4.353e+00 &amp; 0          &amp; 0          &amp; 0          &amp; -6.529e+02 &amp; 0          &amp; 4.353e+00  &amp; 0          &amp; 0          &amp; 0          &amp; -6.529e+02 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -4.353e+00 &amp; 0          &amp; 6.529e+02  &amp; 0          &amp; 0          &amp; 0          &amp; 4.353e+00  &amp; 0          &amp; 6.529e+02  &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -2.515e+04 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 2.515e+04  &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -6.529e+02 &amp; 0          &amp; 6.521e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 6.529e+02  &amp; 0          &amp; 1.307e+05  &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 6.529e+02  &amp; 0          &amp; 0          &amp; 0          &amp; 6.521e+04  &amp; 0          &amp; -6.529e+02 &amp; 0          &amp; 0          &amp; 0          &amp; 1.307e+05
\end{bmatrix}
\]</span></p>
</div>
<p>Несложно заметить, что сформированная в <span class="math inline">\(NASTRAN\)</span> матрица жёсткости демонстрирует практически полное совпадение с матрицей жёсткости, которую формирует наш код на Python. Небольшая разница в числах объясняется отсутствием учёта сдвига для балок Эйлера, используемых в <span class="math inline">\(NASTRAN\)</span>.</p>
<p>Матрица жёсткости, сформированная в <span class="math inline">\(ANSYS\)</span>, выглядит вот так:</p>
<div class="scroll-matrix">
<p><span class="math display">\[
K=
\begin{bmatrix}
5.232e+03  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -5.232e+03 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 2.266e+01  &amp; 0          &amp; 0          &amp; 0          &amp; 3.399e+03  &amp; 0          &amp; -2.266e+01 &amp; 0          &amp; 0          &amp; 0          &amp; 3.399e+03  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; 2.266e+01  &amp; 0          &amp; -3.399e+03 &amp; 0          &amp; 0          &amp; 0          &amp; -2.266e+01 &amp; 0          &amp; -3.399e+03 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 2.512e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -2.512e+04 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; -3.399e+03 &amp; 0          &amp; 5.425e+05  &amp; 0          &amp; 0          &amp; 0          &amp; 3.399e+03  &amp; 0          &amp; 4.772e+05  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 3.399e+03  &amp; 0          &amp; 0          &amp; 0          &amp; 5.425e+05  &amp; 0          &amp; -3.399e+03 &amp; 0          &amp; 0          &amp; 0          &amp; 4.772e+05  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
-5.232e+03 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 1.046e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -5.232e+03 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; -2.266e+01 &amp; 0          &amp; 0          &amp; 0          &amp; -3.399e+03 &amp; 0          &amp; 4.532e+01  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -2.266e+01 &amp; 0          &amp; 0          &amp; 0          &amp; 3.399e+03 \\
0          &amp; 0          &amp; -2.266e+01 &amp; 0          &amp; 3.399e+03  &amp; 0          &amp; 0          &amp; 0          &amp; 4.532e+01  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -2.266e+01 &amp; 0          &amp; -3.399e+03 &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; -2.512e+04 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 5.024e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -2.512e+04 &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; -3.399e+03 &amp; 0          &amp; 4.772e+05  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 1.085e+06  &amp; 0          &amp; 0          &amp; 0          &amp; 3.399e+03  &amp; 0          &amp; 4.772e+05  &amp; 0 \\
0          &amp; 3.399e+03  &amp; 0          &amp; 0          &amp; 0          &amp; 4.772e+05  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 1.085e+06  &amp; 0          &amp; -3.399e+03 &amp; 0          &amp; 0          &amp; 0          &amp; 4.772e+05 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -5.232e+03 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 5.232e+03  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -2.266e+01 &amp; 0          &amp; 0          &amp; 0          &amp; -3.399e+03 &amp; 0          &amp; 2.266e+01  &amp; 0          &amp; 0          &amp; 0          &amp; -3.399e+03 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -2.266e+01 &amp; 0          &amp; 3.399e+03  &amp; 0          &amp; 0          &amp; 0          &amp; 2.266e+01  &amp; 0          &amp; 3.399e+03  &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -2.512e+04 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 2.512e+04  &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -3.399e+03 &amp; 0          &amp; 4.772e+05  &amp; 0          &amp; 0          &amp; 0          &amp; 3.399e+03  &amp; 0          &amp; 5.425e+05  &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 3.399e+03  &amp; 0          &amp; 0          &amp; 0          &amp; 4.772e+05  &amp; 0          &amp; -3.399e+03 &amp; 0          &amp; 0          &amp; 0          &amp; 5.425e+05
\end{bmatrix}
\]</span></p>
</div>
<p>Её структура аналогична двум предыдущим, но в числах всё поехало куда-то не туда. При этом, стоит отметить, что полученная матрица жёсткости соответствует модели, построенной в <span class="math inline">\(MAPDL\)</span> с нуля. Если же пробросить балку в <span class="math inline">\(MAPDL\)</span> из <span class="math inline">\(WB\)</span>, то в числах она будет совсем по-другому (структура сохраняется и на том спасибо).</p>
<p>Матрица жёсткости, которую формирует <span class="math inline">\(COMSOL\)</span>, имеет следующий вид:</p>
<div class="scroll-matrix">
<p><span class="math display">\[
K=
\begin{bmatrix}
2.517e+02  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -2.517e+02 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 1.309e+03  &amp; -3.826e-13 &amp; 0          &amp; 1.168e-12  &amp; 6.545e+03  &amp; 0          &amp; 6.545e+02  &amp; -1.830e-13 &amp; 0          &amp; -1.168e-12 &amp; -6.545e+03 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; -3.826e-13 &amp; 1.309e+03  &amp; 0          &amp; -6.545e+03 &amp; -1.168e-12 &amp; 0          &amp; -1.830e-13 &amp; 6.545e+02  &amp; 0          &amp; 6.545e+03  &amp; 1.168e-12  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 5.236e+07  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -5.236e+07 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 1.395e-12  &amp; -6.545e+03 &amp; 0          &amp; 4.363e+04  &amp; 1.182e-11  &amp; 0          &amp; 1.137e-12  &amp; -6.545e+03 &amp; 0          &amp; -4.363e+04 &amp; -1.182e-11 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 6.545e+03  &amp; -1.395e-12 &amp; 0          &amp; 1.182e-11  &amp; 4.363e+04  &amp; 0          &amp; 6.545e+03  &amp; -1.137e-12 &amp; 0          &amp; -1.182e-11 &amp; -4.363e+04 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
-2.517e+02 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 5.035e+02  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -2.517e+02 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 6.545e+02  &amp; -1.834e-13 &amp; 0          &amp; 1.023e-12  &amp; 6.545e+03  &amp; 0          &amp; 2.618e+03  &amp; -5.815e-13 &amp; 0          &amp; 2.842e-14  &amp; -1.819e-12 &amp; 0          &amp; 6.545e+02  &amp; -1.510e-13 &amp; 0          &amp; -1.052e-12 &amp; -6.545e+03 \\
0          &amp; -1.834e-13 &amp; 6.545e+02  &amp; 0          &amp; -6.545e+03 &amp; -1.023e-12 &amp; 0          &amp; -5.815e-13 &amp; 2.618e+03  &amp; 0          &amp; 1.819e-12  &amp; -2.842e-14 &amp; 0          &amp; -1.510e-13 &amp; 6.545e+02  &amp; 0          &amp; 6.545e+03  &amp; 1.052e-12 \\
0          &amp; 0          &amp; 0          &amp; -5.236e+07 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 1.047e+08  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -5.236e+07 &amp; 0          &amp; 0 \\
0          &amp; -1.395e-12 &amp; 6.545e+03  &amp; 0          &amp; -4.363e+04 &amp; -1.182e-11 &amp; 0          &amp; 1.412e-13  &amp; 2.729e-12  &amp; 0          &amp; 8.727e+04  &amp; 1.819e-11  &amp; 0          &amp; 6.821e-13  &amp; -6.545e+03 &amp; 0          &amp; -4.363e+04 &amp; -6.367e-12 \\
0          &amp; -6.545e+03 &amp; 1.395e-12  &amp; 0          &amp; -1.182e-11 &amp; -4.363e+04 &amp; 0          &amp; -2.729e-12 &amp; -1.412e-13 &amp; 0          &amp; 1.819e-11  &amp; 8.727e+04  &amp; 0          &amp; 6.545e+03  &amp; -6.821e-13 &amp; 0          &amp; -6.367e-12 &amp; -4.363e+04 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -2.517e+02 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 2.517e+02  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 6.545e+02  &amp; -1.519e-13 &amp; 0          &amp; 1.705e-12  &amp; 6.545e+03  &amp; 0          &amp; 1.309e+03  &amp; -1.990e-13 &amp; 0          &amp; -1.705e-12 &amp; -6.545e+03 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -1.519e-13 &amp; 6.545e+02  &amp; 0          &amp; -6.545e+03 &amp; -1.705e-12 &amp; 0          &amp; -1.990e-13 &amp; 1.309e+03  &amp; 0          &amp; 6.545e+03  &amp; 1.705e-12 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -5.236e+07 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 5.236e+07  &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -1.278e-12 &amp; 6.545e+03  &amp; 0          &amp; -4.363e+04 &amp; -6.367e-12 &amp; 0          &amp; -6.821e-13 &amp; 6.545e+03  &amp; 0          &amp; 4.363e+04  &amp; 6.367e-12 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -6.545e+03 &amp; 1.278e-12  &amp; 0          &amp; -6.367e-12 &amp; -4.363e+04 &amp; 0          &amp; -6.545e+03 &amp; 6.821e-13  &amp; 0          &amp; 6.367e-12  &amp; 4.363e+04
\end{bmatrix}
\]</span></p>
</div>
<p>Матрица, полученная в <span class="math inline">\(COMSOL\)</span> примечательна наличием очень маленьких, однако не нулевых элементов. При этом элементы, отличные от нуля, отличаются от своих собратьев из «ручной» и настрановской матриц.</p>
<p>Матрица жёсткости модели, которую собирает <span class="math inline">\(OptiStruct\)</span>, будет выглядеть вот так:</p>
<div class="scroll-matrix">
<p><span class="math display">\[
K=
\begin{bmatrix}
5.236e+03  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -5.236e+03 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 4.354e+00  &amp; 0          &amp; 0          &amp; 0          &amp; 6.531e+02  &amp; 0          &amp; -4.354e+00 &amp; 0          &amp; 0          &amp; 0          &amp; 6.531e+02  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; 4.354e+00  &amp; 0          &amp; -6.531e+02 &amp; 0          &amp; 0          &amp; 0          &amp; -4.354e+00 &amp; 0          &amp; -6.531e+02 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 2.517e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -2.517e+04 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; -6.531e+02 &amp; 0          &amp; 1.307e+05  &amp; 0          &amp; 0          &amp; 0          &amp; 6.531e+02  &amp; 0          &amp; 6.524e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 6.531e+02  &amp; 0          &amp; 0          &amp; 0          &amp; 1.307e+05  &amp; 0          &amp; -6.531e+02 &amp; 0          &amp; 0          &amp; 0          &amp; 6.526e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
-5.236e+03 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 1.047e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -5.236e+03 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; -4.354e+00 &amp; 0          &amp; 0          &amp; 0          &amp; -6.531e+02 &amp; 0          &amp; 8.708e+00  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -4.354e+00 &amp; 0          &amp; 0          &amp; 0          &amp; 6.531e+02 \\
0          &amp; 0          &amp; -4.354e+00 &amp; 0          &amp; 6.531e+02  &amp; 0          &amp; 0          &amp; 0          &amp; 8.708e+00  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -4.354e+00 &amp; 0          &amp; -6.531e+02 &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; -2.517e+04 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 5.035e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -2.517e+04 &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; -6.531e+02 &amp; 0          &amp; 6.524e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 2.614e+05  &amp; 0          &amp; 0          &amp; 0          &amp; 6.531e+02  &amp; 0          &amp; 6.524e+04  &amp; 0 \\
0          &amp; 6.531e+02  &amp; 0          &amp; 0          &amp; 0          &amp; 6.524e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 2.614e+05  &amp; 0          &amp; -6.531e+02 &amp; 0          &amp; 0          &amp; 0          &amp; 6.524e+04 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -5.236e+03 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 5.236e+03  &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -4.354e+00 &amp; 0          &amp; 0          &amp; 0          &amp; -6.531e+02 &amp; 0          &amp; 4.354e+00  &amp; 0          &amp; 0          &amp; 0          &amp; -6.531e+02 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -4.354e+00 &amp; 0          &amp; 6.531e+02  &amp; 0          &amp; 0          &amp; 0          &amp; 4.354e+00  &amp; 0          &amp; 6.531e+02  &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -2.517e+04 &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 2.517e+04  &amp; 0          &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; -6.531e+02 &amp; 0          &amp; 6.524e+04  &amp; 0          &amp; 0          &amp; 0          &amp; 6.531e+02  &amp; 0          &amp; 1.307e+05  &amp; 0 \\
0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 0          &amp; 6.531e+02  &amp; 0          &amp; 0          &amp; 0          &amp; 6.524e+04  &amp; 0          &amp; -6.531e+02 &amp; 0          &amp; 0          &amp; 0          &amp; 1.307e+05
\end{bmatrix}
\]</span></p>
</div>
<p><span class="math inline">\(OptiStruct\)</span> очень хорошо соотносится с «ручным» решением и результатом из <span class="math inline">\(NASTRAN\)</span> как качественно, так и количественно.</p>
<p>При попытках выдрать матрицу жёсткости из <span class="math inline">\(ABAQUS\)</span> у меня, к сожалению, сгорела жёппа, поэтому матрица жёсткости из него представлена не будет.</p>
<hr>
</section>
<section id="костыли" class="level3">
<h3 class="anchored" data-anchor-id="костыли">2.5 «Костыли»</h3>
<hr>
<p>Убедившись в отсутствии решения нашей задачи «классическими» методами, попробуем рассмотреть механизмы, позволяющие программным комплексам обойти проблему решения задачи с вырожденной матрицей жёсткости.</p>
<section id="методы-основанные-на-сингулярном-разложении" class="level4">
<h4 class="anchored" data-anchor-id="методы-основанные-на-сингулярном-разложении">2.5.1 Методы, основанные на сингулярном разложении</h4>
<p>Ежели вооружиться любой приличной книгой по Фортрану, то в каждой из них будет рассмотрен алгоритм SVD (Singular Value Decomposition), суть которого сводится к получению псевдообратной матрицы через разложение матрицы <span class="math inline">\(K\)</span> на три части таким образом, что <span class="math inline">\(K = U \cdot Σ \cdot V \cdot T\)</span>, где <span class="math inline">\(U\)</span> – ортогональная матрица, столбцы которой представляют собой левые сингулярные векторы, <span class="math inline">\(Σ\)</span> – диагональная матрица с сингулярными значениями (неотрицательными числами, показывающими «вес» каждого направления), <span class="math inline">\(V\)</span> – ортогональная матрица, столбцы которой – правые сингулярные векторы.</p>
<p>Рассмотрим уже знакомую нам систему с вырожденной матрицей</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
5 &amp; 7 &amp; 9
\end{bmatrix}
\cdot
x=
\begin{bmatrix}
1 \\ 2 \\ 3
\end{bmatrix}
\]</span></p>
<p>В результате разложения (можно в маткаде прикинуть) получим:</p>
<p><span class="math display">\[
U=
\begin{bmatrix}
-0,235 &amp; -0,782 &amp; -0,577 \\
-0,559 &amp; 0,595 &amp; -0,577 \\
-0,795 &amp; -0,187 &amp; 0,577
\end{bmatrix}
,~Σ=
\begin{bmatrix}
15,663 &amp; 0 &amp; 0 \\
0 &amp; 0,813 &amp; 0 \\
0 &amp; 0 &amp; 0
\end{bmatrix}
,~V=
\begin{bmatrix}
-0,412 &amp; 0,815 &amp; -0,408 \\
-0,564 &amp; 0,124 &amp; 0,816 \\
-0,716 &amp; -0,566 &amp; -0,408
\end{bmatrix}
\]</span></p>
<p>Псевдообратная (заменяем ненулевые элементы на диагонали на обратные) матрица для <span class="math inline">\(Σ\)</span> будет выглядеть как:</p>
<p><span class="math display">\[
Σ^{+}=
\begin{bmatrix}
1/15,663 &amp;0 &amp; 0 \\
0 &amp; 1/0,813 &amp; 0 \\
0 &amp; 0 &amp; 0
\end{bmatrix}
=
\begin{bmatrix}
0,064 &amp; 0 &amp; 0 \\
0 &amp; 1,231 &amp; 0 \\
0 &amp; 0 &amp; 0
\end{bmatrix}
\]</span></p>
<p>Найдём частное решение по соотношению <span class="math inline">\(x_{\text{част}} = V \cdot Σ^{+} \cdot U^{T} \cdot f\)</span>:</p>
<p><span class="math display">\[
U^{T} \cdot f =
\begin{bmatrix}
-0,235 &amp; -0,559 &amp; -0,795 \\
-0,782 &amp; 0,595 &amp; -0,187 \\
-0,577 &amp; -0,577 &amp; 0,577
\end{bmatrix}
\cdot
\begin{bmatrix}
1 \\ 2 \\ 3
\end{bmatrix}
=
\begin{bmatrix}
-3,739 \\ -0,153 \\ 0
\end{bmatrix}
\]</span></p>
<p><span class="math display">\[
Σ^{+} \cdot U^{T} \cdot f =
\begin{bmatrix}
0,064 &amp; 0 &amp; 0 \\
0 &amp; 1,231 &amp; 0 \\
0 &amp; 0 &amp; 0  
\end{bmatrix}
\cdot
\begin{bmatrix}
-3,739 \\ -0,153 \\ 0
\end{bmatrix}
=
\begin{bmatrix}
-0,239 \\ -0,189 \\ 0
\end{bmatrix}
\]</span></p>
<p><span class="math display">\[
x_{\text{част}} = K^{+} \cdot f = V \cdot Σ^{+} \cdot U^{T} \cdot f =
\begin{bmatrix}
-0,412 &amp; 0,815 &amp; -0,408 \\
-0,564 &amp; 0,124 &amp; 0,816 \\
-0,716 &amp; -0,566 &amp; -0,408
\end{bmatrix}
\cdot
\begin{bmatrix}
-0,239 \\ -0,189 \\ 0
\end{bmatrix}
=
\begin{bmatrix}
-0,056 \\ 0,111 \\ 0,278
\end{bmatrix}
\]</span></p>
<p>Находим базис ядра (ядро матрицы <span class="math inline">\(K\)</span> – это те векторы <span class="math inline">\(x\)</span>, для которых <span class="math inline">\(K \cdot x = 0\)</span>). В <span class="math inline">\(Σ\)</span> третье значение равно нулю, значит, третий столбец <span class="math inline">\(V\)</span> и есть базис ядра:</p>
<p><span class="math display">\[
k=
\begin{bmatrix}
-0,418 \\ 0,816 \\ -0,408
\end{bmatrix}
\]</span></p>
<p>Полное решение находится в виде <span class="math inline">\(x = x_{\text{част}} + \alpha \cdot k\)</span>, где <span class="math inline">\(\alpha\)</span> - произвольная константа:</p>
<p><span class="math display">\[
x=
\begin{bmatrix}
-0,056 \\ 0,111 \\ 0,278
\end{bmatrix}
+ \alpha \cdot
\begin{bmatrix}
-0,418 \\ 0,816 \\ -0,408
\end{bmatrix}
\]</span></p>
<p>Очевидно, что в силу произвольности константы <span class="math inline">\(\alpha\)</span> для системы с вырожденной матрицей можно получить сколько угодно «полных» решений. Полученное выше частное решение является минимальным по норме <span class="math inline">\((||x_{\text{част}}|| = \sqrt{x_{\text{част}}^{T} \cdot x_{\text{част}}})\)</span> среди всех возможных решений и ортогональным ядру (то есть <span class="math inline">\(x_{\text{част}}\)</span> перпендикулярен всем векторам ядра <span class="math inline">\(K\)</span>: <span class="math inline">\(x_{\text{част}}^{T} \cdot v_{i} = 0\)</span> для любого <span class="math inline">\(v_{i}\)</span> из ядра). Для задачи с шарнирно опёртой балкой найденное частное решение будет представлять собой перемещения с минимальной «энергией».</p>
<p>Алсо, если в решение в общем виде, которое мы получили равнее, подставить <span class="math inline">\(t = 0,278\)</span>, то получим:</p>
<p><span class="math display">\[
x=
\begin{bmatrix}
-0,333 + t \\ 0,667 - 2 \cdot t \\ t
\end{bmatrix}
=
\begin{bmatrix}
-0,333 + 0,278 \\ 0,667 - 2 \cdot 0,278 \\ 0,278
\end{bmatrix}
=
\begin{bmatrix}
-0,055 \\ 0,111 \\ 0,278
\end{bmatrix}
,
\]</span></p>
<p>что отлично соотносится с результатом, полученным через SVD-разложение.</p>
<p>Подстановка полученного частного решения в исходную систему даёт:</p>
<p><span class="math display">\[
K \cdot x_{\text{част}}=
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
5 &amp; 7 &amp; 9
\end{bmatrix}
\cdot
\begin{bmatrix}
-0,056 \\ 0,111 \\ 0,278
\end{bmatrix}
=
\begin{bmatrix}
1 \\ 2 \\ 3
\end{bmatrix}
\]</span></p>
<p>Реализуем рассмотренный подход в задаче о шарнирно опёртой балке. Нужная для этого функция будет выглядеть следующим образом:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> svd_solve(A: np.ndarray, b: np.ndarray, tol: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1e-10</span>) <span class="op">-&gt;</span> Tuple[np.ndarray, np.ndarray]:</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Решает вырожденную систему через SVD, возвращая частное решение и базис ядра.</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">        A (np.ndarray): Матрица (n x n).</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">        b (np.ndarray): Вектор правой части (n).</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co">        tol (float): Порог для обрезки сингулярных значений.</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">        Tuple[np.ndarray, np.ndarray]: Частное решение x_p и базис ядра (столбцы).</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    U, Sigma, Vt <span class="op">=</span> np.linalg.svd(A)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(b)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Частное решение</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    Sigma_plus <span class="op">=</span> np.zeros((n, n))</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    rank <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> Sigma[i] <span class="op">&gt;</span> tol:</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>            Sigma_plus[i, i] <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> Sigma[i]</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>            rank <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    x_p <span class="op">=</span> Vt.T <span class="op">@</span> Sigma_plus <span class="op">@</span> U.T <span class="op">@</span> b</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Базис ядра (столбцы Vt для нулевых Sigma)</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    kernel_basis <span class="op">=</span> Vt[rank:].T  <span class="co"># Транспонируем, чтобы столбцы были векторами</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x_p, kernel_basis</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Готовым аналогом этой функции из библиотеки NumPy служит функция np.linalg.pinv, решение с помощью которой будет выглядеть как:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>u_red_pinv <span class="op">=</span> np.linalg.pinv(k_red) <span class="op">@</span> f_red</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Результат выполнения кода с использованием этих функций применительно к задаче о шарнирно опёртой балке с неполным набором граничных условий будет выглядеть так:</p>
<pre><code>Перемещения (my_solve): не удалось вычислить из-за вырожденности
Перемещения (NumPy): не удалось вычислить из-за вырожденности
Перемещения (plu_solve): не удалось вычислить из-за вырожденности
Перемещения (псевдообратная): [-6.364e-18 -1.345e-15  2.292e-03 -1.129e-16  4.586e-01  2.772e-13
 -9.976e-18 -4.090e-17 -2.618e-17 -9.806e-18  1.411e-15 -2.292e-03]
Прогиб u_2y (псевдообратная): 0.4586 мм
Перемещения (SVD частное): [-6.364e-18 -1.345e-15  2.292e-03 -1.129e-16  4.586e-01  2.772e-13
 -9.976e-18 -4.090e-17 -2.618e-17 -9.806e-18  1.411e-15 -2.292e-03]
Прогиб u_2y (SVD): 0.4586 мм</code></pre>
<p>Определённая величина прогиба в центре балки совпадает как с аналитическим решением, так и с результатами из различных программных комплексов.</p>
</section>
<section id="методы-основанные-на-анализе-собственных-значений" class="level4">
<h4 class="anchored" data-anchor-id="методы-основанные-на-анализе-собственных-значений">2.5.2 Методы, основанные на анализе собственных значений</h4>
<p>Можно было бы отнести этот подход в группу к предыдущему, пушто процедура получения решения похожа, но посмотрим отдельно. Если матрица <span class="math inline">\(K\)</span> в системе <span class="math inline">\(K \cdot x = f\)</span> – симметричная, что соответствует нашей исходной задаче о шарнирно опёртой балке, то можно её диагонализировать <span class="math inline">\(K = V \cdot Λ \cdot V^{T}\)</span>, где <span class="math inline">\(V\)</span> – матрица собственных векторов, <span class="math inline">\(Λ\)</span> – диагональная матрица собственных значений (в случае вырожденной матрицы <span class="math inline">\(K\)</span> некоторые значения будут равны нулю). После такого преобразования перейдём к новой системе <span class="math inline">\(Λ \cdot y = g\)</span>, где <span class="math inline">\(g = V^{T} \cdot f\)</span> и <span class="math inline">\(y = V^{T} \cdot x\)</span>. Убирая из системы нулевые значения (в случае вырожденной матрицы <span class="math inline">\(K\)</span>) перейдём к «сокращённой системе» <span class="math inline">\(Λ_{red} \cdot y_{red} = g_{red}\)</span> и восстанавливаем результат как <span class="math inline">\(x = V_{red} \cdot y_{red}\)</span>. Посмотрим, как это будет выглядеть на примере:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
5 &amp; 7 &amp; 9
\end{bmatrix}
\cdot
x=
\begin{bmatrix}
1 \\ 2 \\ 3
\end{bmatrix}
\]</span></p>
<p>С прискорбием замечаем, что наша «тестовая» матрица далека от симметричной, поэтому будем искать решение не для системы <span class="math inline">\(K \cdot x = f\)</span>, а для системы <span class="math inline">\(K^{T} \cdot K \cdot x = K^{T} \cdot f\)</span>:</p>
<p><span class="math display">\[
K^{T} \cdot K=
\begin{bmatrix}
1 &amp; 4 &amp; 5 \\
2 &amp; 5 &amp; 7 \\
3 &amp; 6 &amp; 9
\end{bmatrix}
\cdot
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
5 &amp; 7 &amp; 9
\end{bmatrix}
=
\begin{bmatrix}
42 &amp; 57 &amp; 72 \\
57 &amp; 78 &amp; 99 \\
72 &amp; 99 &amp; 126
\end{bmatrix}
\]</span></p>
<p>Матрицы собственных значений и собственных векторов для <span class="math inline">\(K^{T} \cdot K\)</span> имеют вид:</p>
<p><span class="math display">\[
Λ=
\begin{bmatrix}
0 &amp; 0 &amp; 0 \\
0 &amp; 0,66 &amp; 0 \\
0 &amp; 0 &amp; 245,34
\end{bmatrix}
,~V=
\begin{bmatrix}
-0,408 &amp; -0,815 &amp; 0,412 \\
0,816 &amp; -0,124 &amp; 0,564 \\
-0,408 &amp; 0,566 &amp; 0,716
\end{bmatrix}
\]</span></p>
<p>Элемент (1,1) матрицы собственных значений – нулевой, поэтому редуцированные матрицы примут вид:</p>
<p><span class="math display">\[
Λ_{red}=
\begin{bmatrix}
0,66 &amp; 0 \\
0 &amp; 245,34
\end{bmatrix}
,~V_{red}=
\begin{bmatrix}
-0,815 &amp; 0,412 \\
-0,124 &amp; 0,564 \\
0,566 &amp; 0,716
\end{bmatrix}
\]</span></p>
<p>Редуцированный вектор сил примет вид:</p>
<p><span class="math display">\[
f_{red} = V_{red}^{T} \cdot K^{T} \cdot f =
\begin{bmatrix}
-0,815 &amp; -0,124 &amp; 0,566 \\
0,412 &amp; 0,564 &amp; 0,716
\end{bmatrix}
\cdot
\begin{bmatrix}
1 &amp; 4 &amp; 5 \\
2 &amp; 5 &amp; 7 \\
3 &amp; 6 &amp; 9
\end{bmatrix}
\cdot
\begin{bmatrix}
1 \\ 2 \\ 3
\end{bmatrix}
=
\begin{bmatrix}
0,125 \\ 58,558
\end{bmatrix}
\]</span></p>
<p>Решаем систему <span class="math inline">\(Λ_{red} \cdot x_{red} = f_{red}\)</span>:</p>
<p><span class="math display">\[
\begin{bmatrix}
0,66 &amp; 0 \\
0 &amp; 245,34
\end{bmatrix}
\cdot
x_{red}=
\begin{bmatrix}
0,125 \\ 58,558
\end{bmatrix}
\]</span></p>
<p>Получим:</p>
<p><span class="math display">\[
x_{red}=
\begin{bmatrix}
0,189 \\ 0,239
\end{bmatrix}
\]</span></p>
<p>Восстанавливаем полное решение как <span class="math inline">\(x = V_{red} \cdot x_{red}\)</span>:</p>
<p><span class="math display">\[
x=V_{red} \cdot x_{red}=
\begin{bmatrix}
-0,815 &amp; 0,412 \\
-0,124 &amp; 0,564 \\
0,566 &amp; 0,716
\end{bmatrix}
\cdot
\begin{bmatrix}
0,189 \\ 0,239
\end{bmatrix}
=
\begin{bmatrix}
-0,056 \\ 0,111 \\ 0,278
\end{bmatrix}
\]</span></p>
<p>Аналогичное решение уже было получено ранее с использованием SVD-разложения.</p>
<p>Реализуем рассмотренный подход в задаче о шарнирно опёртой балке. Нужная для этого функция будет выглядеть следующим образом:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> eigen_solve(K: np.ndarray, f: np.ndarray, tol: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1e-10</span>) <span class="op">-&gt;</span> NDArray:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Решает систему через анализ собственных значений, убирая нулевые моды.</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">        K (np.ndarray): Матрица жёсткости (n x n).</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">        f (np.ndarray): Вектор сил (n).</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co">        tol (float): Порог для нулевых собственных значений.</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="co">        NDArray: Решение x.</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Собственные значения и векторы</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    eigenvalues, eigenvectors <span class="op">=</span> np.linalg.eigh(K)</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Определяем "жёсткие" моды</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    active_modes <span class="op">=</span> eigenvalues <span class="op">&gt;</span> tol</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    Lambda_red <span class="op">=</span> np.diag(eigenvalues[active_modes])</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    V_red <span class="op">=</span> eigenvectors[:, active_modes]</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Решаем в сокращённом базисе: V_red * Lambda_red * V_red^T * x = f</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    f_red <span class="op">=</span> V_red.T <span class="op">@</span> f</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    x_red <span class="op">=</span> np.linalg.solve(Lambda_red, f_red)</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Восстанавливаем полное решение</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> V_red <span class="op">@</span> x_red</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Результат выполнения кода с использованием этих функций применительно к задаче о шарнирно опёртой балке с неполным набором граничных условий будет выглядеть так:</p>
<pre><code>Перемещения (Eigen): [ 1.129e-27  7.458e-16  2.292e-03 -1.762e-16  4.586e-01 -1.491e-13
 -1.179e-21  3.898e-17  2.222e-17 -1.280e-19 -7.605e-16 -2.292e-03]
Прогиб u_2y (Eigen): 0.4586 мм</code></pre>
<p>Очередной верный ответ.</p>
</section>
<section id="методы-основанные-на-регуляризации" class="level4">
<h4 class="anchored" data-anchor-id="методы-основанные-на-регуляризации">2.5.3 Методы, основанные на регуляризации</h4>
<p>Когда матрица <span class="math inline">\(K\)</span> вырождена и система <span class="math inline">\(K \cdot x = f\)</span> не имеет единственного решения, метод регуляризации Тихонова «исправляет» это, добавляя небольшую регуляризацию, чтобы сделать матрицу <span class="math inline">\(K\)</span> невырожденной. При этом вместо прямого решения уравнения <span class="math inline">\(K \cdot x = f\)</span> мы решаем модифицированную задачу, минимизируя функционал <span class="math inline">\(J(x)=||K \cdot x~–~f \cdot ||2+λ \cdot ||x||^2\)</span>, что приводит к системе <span class="math inline">\((K^{T} \cdot K + λ \cdot I) \cdot x = K^{T} \cdot f\)</span>. Рассмотрим пример:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
5 &amp; 7 &amp; 9
\end{bmatrix}
\cdot
x=
\begin{bmatrix}
1 \\ 2 \\ 3
\end{bmatrix}
\]</span></p>
<p>Считаем <span class="math inline">\(K^{T} \cdot K\)</span>:</p>
<p><span class="math display">\[
K^{T}=
\begin{bmatrix}
1 &amp; 4 &amp; 5 \\
2 &amp; 5 &amp; 7 \\
3 &amp; 6 &amp; 9
\end{bmatrix}
\]</span></p>
<p><span class="math display">\[
K^{T} \cdot K=
\begin{bmatrix}
1 &amp; 4 &amp; 5 \\
2 &amp; 5 &amp; 7 \\
3 &amp; 6 &amp; 9
\end{bmatrix}
\cdot
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
5 &amp; 7 &amp; 9
\end{bmatrix}
=
\begin{bmatrix}
42 &amp; 57 &amp; 72 \\
57 &amp; 78 &amp; 99 \\
72 &amp; 99 &amp; 126
\end{bmatrix}
\]</span></p>
<p>Добавляем <span class="math inline">\(λ \cdot I\)</span>, где <span class="math inline">\(λ\)</span> – некоторое малое значение (<span class="math inline">\(λ = 10-6\)</span>):</p>
<p><span class="math display">\[
I=
\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<p><span class="math display">\[
K^{T} \cdot K + \lambda \cdot I =
\begin{bmatrix}
42 &amp; 57 &amp; 72 \\
57 &amp; 78 &amp; 99 \\
72 &amp; 99 &amp; 126
\end{bmatrix}
+
\begin{bmatrix}
0,000001 &amp; 0 &amp; 0 \\
0 &amp; 0,000001 &amp; 0 \\
0 &amp; 0 &amp; 0,000001
\end{bmatrix}
=
\begin{bmatrix}
42,000001 &amp; 57 &amp; 72 \\
57 &amp; 78,000001 &amp; 99 \\
72 &amp; 99 &amp; 126,000001
\end{bmatrix}
\]</span></p>
<p>Отсюда, решая систему <span class="math inline">\((K^{T} \cdot K + \lambda \cdot I) \cdot x = K^{T} \cdot f\)</span>, получим:</p>
<p><span class="math display">\[
x=
\begin{bmatrix}
-0,056 \\ 0,111 \\ 0,278
\end{bmatrix}
\]</span></p>
<p>Аналогичный результат мы уже получали раньше при решении системы через SVD-разложение. Проверка результата подстановкой в <span class="math inline">\(K \cdot x\)</span> даёт:</p>
<p><span class="math display">\[
K \cdot x =
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
5 &amp; 7 &amp; 9
\end{bmatrix}
\cdot
\begin{bmatrix}
-0,056 \\ 0,111 \\ 0,278
\end{bmatrix}
=
\begin{bmatrix}
1 \\ 2 \\ 3
\end{bmatrix}
.
\]</span></p>
<p>Как несложно заметить, полученное решение с хорошей точностью удовлетворяет исходной системе.</p>
<p>Реализуем рассмотренный подход в задаче о шарнирно опёртой балке. Нужная для этого функция будет выглядеть следующим образом:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tikhonov_solve(A: np.ndarray, b: np.ndarray, lambda_: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1e-6</span>) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Решает вырожденную систему через регуляризацию Тихонова: (A^T A + λI) x = A^T b.</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co">        A (np.ndarray): Матрица (n x n).</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co">        b (np.ndarray): Вектор правой части (n).</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co">        lambda_ (float): Параметр регуляризации.</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co">        np.ndarray: Решение x.</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(b)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Решаем уравнение с добавленной регуляризацией</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.linalg.solve(A.T <span class="op">@</span> A <span class="op">+</span> lambda_ <span class="op">*</span> np.eye(n), A.T <span class="op">@</span> b)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Результат выполнения кода с использованием этой функции применительно к задаче о шарнирно опёртой балке с неполным набором граничных условий будет выглядеть так:</p>
<pre><code>Перемещения (Тихонов): [-0.     0.     0.002  0.     0.459  0.     0.    -0.    -0.     0.
  0.    -0.002]
Прогиб u_2y (Тихонов): 0.4586 мм</code></pre>
<p>Аналогом такого подхода является, сюрприз-сюрприз, использование «мягких пружин», опция использования которых имеется в ANSYS. Отличие «мягких пружин» заключается в том, что вместо добавления <span class="math inline">\(λ \cdot I\)</span> ко всей диагонали создаётся матрица <span class="math inline">\(K_{s}\)</span>, в которой малые величины <span class="math inline">\(k_{s}\)</span> добавляются только к определённым элементам исходной матрицы <span class="math inline">\(K\)</span>, а модифицированная система выглядит как <span class="math inline">\((K + K_{s}) \cdot x = f\)</span>. Это больше подходит к реальной физике: в балке стабилизируются только те узлы или направления, у которых нет жёстких граничных условий. Вернёмся к нашему примеру:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
5 &amp; 7 &amp; 9
\end{bmatrix}
\cdot
x=
\begin{bmatrix}
1 \\ 2 \\ 3
\end{bmatrix}
\]</span></p>
<p>Формируем <span class="math inline">\(K_{s}\)</span> таким образом, чтобы стабилизировать <span class="math inline">\(х_3\)</span>:</p>
<p><span class="math display">\[
K_{s}=
\begin{bmatrix}
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0,000001
\end{bmatrix}
\]</span></p>
<p>Тогда:</p>
<p><span class="math display">\[
K + K_{s} =
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
5 &amp; 7 &amp; 9
\end{bmatrix}
+
\begin{bmatrix}
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0,000001
\end{bmatrix}
=
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
5 &amp; 7 &amp; 9,000001
\end{bmatrix}
\]</span></p>
<p>Отсюда, решая систему <span class="math inline">\((K + K_{s}) \cdot x = f\)</span>, получим:</p>
<p><span class="math display">\[
x=
\begin{bmatrix}
-0,333 \\ 0,667 \\ 0
\end{bmatrix}
\]</span></p>
<p>Это частное решение можно получить из полученного ранее решения в общем виде подстановкой <span class="math inline">\(t = 0\)</span>:</p>
<p><span class="math display">\[
x=
\begin{bmatrix}
-0,333 + t \\ 0,667 - 2 \cdot t \\ t
\end{bmatrix}
=
\begin{bmatrix}
-0,333 + 0 \\ 0,667 - 2 \cdot 0 \\ 0
\end{bmatrix}
\begin{bmatrix}
-0,333 \\ 0,667 \\ 0
\end{bmatrix}
\]</span></p>
<p>Проверка результата подстановкой в <span class="math inline">\(K \cdot х\)</span> даёт:</p>
<p><span class="math display">\[
K \cdot x =
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
5 &amp; 7 &amp; 9
\end{bmatrix}
\cdot
\begin{bmatrix}
-0,333 \\ 0,667 \\ 0
\end{bmatrix}
=
\begin{bmatrix}
1 \\ 2 \\ 3
\end{bmatrix}
.
\]</span></p>
<p>Заметим, что вектора <span class="math inline">\(х\)</span>, полученные с использованием метода Тихонова и «мягких пружин», различаются, что связано с минимизацией нормы вектора <span class="math inline">\(х\)</span> в методе Тихонова. Несмотря на эту разницу, реализуем подход с «мягкими пружинами» в задаче про балку и посмотрим на результат. Нужная для этого функция будет выглядеть следующим образом:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BeamStructure:</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Решаем систему: K * u = F, где u - вектор перемещений</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Мягкие пружины</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    global_stab_indices <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">15</span>, <span class="dv">16</span>, <span class="dv">17</span>] <span class="co"># theta1x, theta1y, theta1z, theta3x, theta3y, theta3z в k_global</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    u_red_spring <span class="op">=</span> <span class="va">None</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        u_red_spring <span class="op">=</span> spring_solve(k_red, f_red, global_stab_indices, free_dofs)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u_red_spring <span class="kw">is</span> <span class="va">None</span>:  <span class="co"># Если сингулярна, выходим из цикла</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> np.linalg.LinAlgError(<span class="st">"Сингулярность осталась"</span>)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> np.linalg.LinAlgError:</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>        time_spring <span class="op">=</span> <span class="fl">0.0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> spring_solve(K: np.ndarray, f: np.ndarray, global_spring_indices: List[<span class="bu">int</span>], free_dofs: List[<span class="bu">int</span>],</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>                 epsilon_factor: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1e-6</span>) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Решает систему с "мягкими пружинами" на заданных глобальных индексах, учитывая свободные степени.</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="co">        K (np.ndarray): Ред. матрица жёсткости (n x n).</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="co">        f (np.ndarray): Ред. вектор сил (n).</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="co">        global_spring_indices (List[int]): Глобальные индексы для пружин (в K_global).</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="co">        free_dofs (List[int]): Свободные степени свободы (глобальные индексы).</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="co">        epsilon_factor (float): Фактор масштабирования жёсткости.</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="co">        NDArray | None: Решение x или None, если матрица сингулярна.</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    K_stab <span class="op">=</span> K.copy()</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(free_dofs)</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Базовая жёсткость из K_red</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    k_base <span class="op">=</span> K[<span class="dv">2</span>, <span class="dv">2</span>] <span class="cf">if</span> <span class="bu">abs</span>(K[<span class="dv">2</span>, <span class="dv">2</span>]) <span class="op">&gt;</span> <span class="fl">1e-10</span> <span class="cf">else</span> np.mean(np.diag(K))</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    epsilon <span class="op">=</span> epsilon_factor <span class="op">*</span> k_base</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Переводим глобальные индексы в локальные для K_red</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    stab_indices <span class="op">=</span> [free_dofs.index(idx) <span class="cf">for</span> idx <span class="kw">in</span> global_spring_indices <span class="cf">if</span> idx <span class="kw">in</span> free_dofs]</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Добавляем жёсткость только к активным индексам</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> idx <span class="kw">in</span> stab_indices:</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>        K_stab[idx, idx] <span class="op">+=</span> epsilon</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Пробуем решить с обработкой сингулярности</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.linalg.solve(K_stab, f)</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> np.linalg.LinAlgError:</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"spring_solve: матрица сингулярна, стабилизация не помогла (активные индексы: </span><span class="sc">{</span>stab_indices<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Результат выполнения кода с использованием этой функции применительно к задаче о шарнирно опёртой балке с неполным набором граничных условий будет выглядеть так:</p>
<pre><code>Перемещения (мягкие пружины): [ 0.000e+00  0.000e+00  2.292e-03  0.000e+00  4.586e-01 -0.000e+00
  0.000e+00  0.000e+00  1.699e-19  0.000e+00  0.000e+00 -2.292e-03]
Прогиб u_2y (мягкие пружины): 0.4586 мм</code></pre>
<p>По результатам выполнения двух вариантов кода получилась одинаковая величина прогиба в центре балки при, в целом, различных векторах перемещений. Разница проявляется в «свободных» степенях свободы, в то время как перемещение в точке приложения нагрузки мало зависит от конкретного частного решения, если «стабилизирующие параметры» достаточно малы.</p>
<p>Теперь самое время вспомнить первоначальный вопрос, заданный сообществу господином Ш., в котором упоминались «мягкие пружины», не оказавшие должного эффекта. Для начала взглянем на эти самые пружины – загрузим нашу балку в классический интерфейс ANSYS. На рисунке 9 представлен результат этого действия – видно, что к узлам, на которые наложены силовые и кинематические граничные условия добавилось три пружинки. На всякий случай, проверим, действительно ли задача не считается, ведь пружины мы видим и, теоретически, они должны способствовать решению. Результат приведён на рисунке 10 – не считается и предупреждает об отсутствии недостающего закрепления по углу поворота вокруг оси балки.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Pic_9.png" class="img-fluid figure-img"></p>
<figcaption>Рисунок 9 - Модель балки с «мягкими пружинами»</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Pic_10.png" class="img-fluid figure-img"></p>
<figcaption>Рисунок 10 - Результат попытки решить задачу о шарнирно опёртой балке с «мягкими пружинами» в ANSYS</figcaption>
</figure>
</div>
<p>Немного покопавшись в исходных данных, заметим, что «мягкие пружины» представляют собой элементы типа COMBIN14 (рисунок 11), которые, по умолчанию, работают только в продольном направлении на «растяжение-сжатие». Так как с линейными перемещениями у нас всё в порядке и дополнительные ограничения по их направлениям нам не нужны, поменяем принцип работы «мягких пружин» (рисунок 12) и проверим, запустится ли задача в таком случае.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Pic_11.png" class="img-fluid figure-img"></p>
<figcaption>Рисунок 11 - Объяснение неудачи при решении задачи о шарнирно опёртой балке с «мягкими пружинами» в ANSYS</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Pic_12.png" class="img-fluid figure-img"></p>
<figcaption>Рисунок 12 - Смена поведения «мягких пружин» в ANSYS</figcaption>
</figure>
</div>
<p>После смены «поведения» «мягких пружин» наша тестовая задача решилась без каких либо проблем, что представлено на рисунке 13. Максимальный прогиб в центре составил 0,459607 мм.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Pic_13.png" class="img-fluid figure-img"></p>
<figcaption>Рисунок 13 - Результат решения задачи о шарнирно опёртой балке с «мягкими пружинами» в ANSYS с учётом смены «поведения» пружин</figcaption>
</figure>
</div>
<blockquote class="blockquote">
<p>К этому моменту мы наконец-то можем сделать ещё один вывод: ANSYS при настройках по умолчанию пытается решить задачу через один из классических методов, связанных с разложением исходной матрицы <span class="math inline">\(K\)</span>. При включении опции «мягких пружин» ANSYS добавляет малые жёсткости к узлам, к которым приложены граничные условия (что соответствует выборочному добавлению малых величин к элементам матрицы жёсткости, как было рассмотрено выше). По умолчанию эти пружины соответствуют линейным перемещениям, но поскольку мы уже в явном виде ограничили перемещения в этих узлах, то они просто «вычёркиваются» из полной матрицы жёсткости и не оказывают влияния на «редуцированную» матрицу жёсткости. При смене «поведения» «мягких пружин» задача решается так же, как и в написанном ранее коде.</p>
</blockquote>
</section>
<section id="методы-редуцирующие-исходную-систему" class="level4">
<h4 class="anchored" data-anchor-id="методы-редуцирующие-исходную-систему">2.5.3 Методы, редуцирующие исходную систему</h4>
<p>Для простоты восприятия, к разобранным в этом разделе методам можно применить следующую аналогию: в конце бурной попойки вам надлежит последовательно раздать своим 12 (как степеней свободы в балочном элементе) друзьям 1 большой пирог. Вот они все 12 перед вами выстроились. Однако один из друзей, в серединке, уже в совершенно невменяемом состоянии и портит делёжку. Поэтому вы перемещаете этого неадеквата в конец очереди, все нормальные друзья получают свой кусочек пирога, а перебравшему обрыгану вы говорите: «Сиди тихо, тебе 0».</p>
<section id="qr-разложение" class="level5">
<h5 class="anchored" data-anchor-id="qr-разложение">2.5.3.1 QR-разложение</h5>
<p>Решение системы <span class="math inline">\(K \cdot x = f\)</span> ищется путём разложения матрицы <span class="math inline">\(K\)</span> на две части таким образом, что <span class="math inline">\(K = Q \cdot R\)</span>, где <span class="math inline">\(Q\)</span> – ортогональная, <span class="math inline">\(R\)</span> – верхнетреугольная. Зачем опять что-то раскладывать? А вот зачем: после разложения исходная система <span class="math inline">\(K \cdot x = f\)</span> преобразуется в систему <span class="math inline">\(Q \cdot R \cdot x = f\)</span>, а результат находится из решения системы <span class="math inline">\(R \cdot x = Q \cdot T \cdot f\)</span>, которая примет вид «лесенки» (так как <span class="math inline">\(R\)</span> – верхнетреугольная). Если исходная матрица <span class="math inline">\(K\)</span> – вырожденная, то «лишние» элементы просто откидываем и ищем решение для того, что осталось. Уже знакомая нам система имеет вид:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
5 &amp; 7 &amp; 9
\end{bmatrix}
\cdot
x=
\begin{bmatrix}
1 \\ 2 \\ 3
\end{bmatrix}
\]</span></p>
<p>В результате разложения (можно опять прикинуть в маткаде) получим:</p>
<p><span class="math display">\[
Q=
\begin{bmatrix}
-0,154 &amp; 0,802 &amp; -0,577 \\
-0,617 &amp; -0,535 &amp; -0,577 \\
-0,772 &amp; 0,267 &amp; 0,577
\end{bmatrix}
,~R=
\begin{bmatrix}
-6,481 &amp; -8,795 &amp; -11,11 \\
0 &amp; 0,802 &amp; 1,604 \\
0 &amp; 0 &amp; 0
\end{bmatrix}
\]</span></p>
<p>По числу ненулевых элементов на диагонали матрицы <span class="math inline">\(R\)</span> делаем несложный вывод о ранге матрицы, который равен двум. Вычисляем <span class="math inline">\(Q^{T} \cdot f\)</span>:</p>
<p><span class="math display">\[
Q^{T} \cdot f =
\begin{bmatrix}
-0,154 &amp; -0,617 &amp; -0,772 \\
0,802 &amp; -0,535 &amp; 0,267 \\
-0,577 &amp; -0,577 &amp; 0,577
\end{bmatrix}
\cdot
\begin{bmatrix}
1 \\ 2 \\ 3
\end{bmatrix}
=
\begin{bmatrix}
-3,704 \\ 0,533 \\ 0
\end{bmatrix}
.
\]</span></p>
<p>Так как ранг равен двум, то берём первые 2 строки и первые 2 столбца и решаем систему для усечённой части <span class="math inline">\(R_{red} \cdot x = (Q^{T} \cdot f)_{red}\)</span>:</p>
<p><span class="math display">\[
\begin{bmatrix}
-6,481 &amp; -8,795 \\
0 &amp; 0,802
\end{bmatrix}
\cdot
\begin{bmatrix}
x_{1} \\ x_{2}
\end{bmatrix}
=
\begin{bmatrix}
-3,704 \\ 0,533
\end{bmatrix}
\]</span></p>
<p>В результате получаем:</p>
<p><span class="math display">\[
x_{red}=
\begin{bmatrix}
-0,331 \\ 0,665
\end{bmatrix}
\]</span></p>
<p>Отбрасывание «лишних» элементов соответствует нулевому решению, и «полный» вектор <span class="math inline">\(х\)</span> будет выглядеть как:</p>
<p><span class="math display">\[
x=
\begin{bmatrix}
-0,331 \\ 0,665 \\ 0
\end{bmatrix}
\]</span></p>
<p>Полученное таким образом решение неплохо соотносится с решением, полученным с использованием «мягких пружин».</p>
<p>Применим рассмотренный подход к задаче с балкой. Нужная для этого функция будет выглядеть следующим образом:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> qr_solve(K: np.ndarray, f: np.ndarray, tol: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1e-10</span>) <span class="op">-&gt;</span> NDArray:</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Решает систему через QR-разложение с выбором ранга.</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co">        K (np.ndarray): Матрица жёсткости (n x n).</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="co">        f (np.ndarray): Вектор сил (n).</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="co">        tol (float): Порог для определения ранга.</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="co">        NDArray: Решение x.</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># QR-разложение с поворотами</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    Q, R, P <span class="op">=</span> linalg.qr(K, pivoting<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    rank <span class="op">=</span> <span class="bu">sum</span>(<span class="bu">abs</span>(np.diag(R)) <span class="op">&gt;</span> tol)  <span class="co"># Определяем ранг</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Решаем усечённую систему</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    Qb <span class="op">=</span> Q.T <span class="op">@</span> f</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    R_red <span class="op">=</span> R[:rank, :rank]</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    Qb_red <span class="op">=</span> Qb[:rank]</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Обратная подстановка для усечённой части</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    x_red <span class="op">=</span> np.linalg.solve(R_red, Qb_red)</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Восстанавливаем полный вектор x с учётом перестановок</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.zeros(<span class="bu">len</span>(f))</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    x[P[:rank]] <span class="op">=</span> x_red</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Результат выполнения кода с использованием этой функции применительно к задаче о шарнирно опёртой балке с неполным набором граничных условий будет выглядеть так:</p>
<pre><code>Перемещения (QR): [-2.370e-19  7.596e-17  2.292e-03 -1.315e-18  4.586e-01 -1.518e-14
 -7.884e-20 -3.475e-20 -1.514e-19  0.000e+00 -7.586e-17 -2.292e-03]
Прогиб u_2y (QR): 0.4586 мм</code></pre>
<p>Саксес!</p>
</section>
<section id="pardiso" class="level5">
<h5 class="anchored" data-anchor-id="pardiso">2.5.3.2 PARDISO</h5>
<p>PARDISO – это прямой решатель для разреженных систем вида <span class="math inline">\(K \cdot x = f\)</span>, запускаемый по умолчанию в ABAQUS, OptiStruct и ЛОГОС. PARDISO использует перестановки и для симметричных матриц – <span class="math inline">\(LDL^{T}\)</span>-разложение, для несимметричных матриц – <span class="math inline">\(LU\)</span>-разложение, приходя таким образом к виду:</p>
<p><span class="math display">\[
P_{L} \cdot K \cdot P_{R} = L \cdot U~{\text{(для случая с несимметричной матрицей)}},
\]</span></p>
<p>где <span class="math inline">\(P_L\)</span> – матрица перестановки строк, <span class="math inline">\(P_R\)</span> – матрица перестановки столбцов. После преобразований последовательно решаем несколько систем: сначала <span class="math inline">\(L \cdot y = P_L \cdot f\)</span>, потом <span class="math inline">\(U \cdot z = y\)</span> и окончательно <span class="math inline">\(x = P_R \cdot z\)</span>. Для вырожденной матрицы таким образом можно получить некоторое частное решение, например, приравняв «лишнюю» неизвестную к нулю, аналогично решению через <span class="math inline">\(QR\)</span>-разложение.</p>
<p>Поехали смотреть на нашу «тестовую» систему:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
5 &amp; 7 &amp; 9
\end{bmatrix}
\cdot
x=
\begin{bmatrix}
1 \\ 2 \\ 3
\end{bmatrix}
\]</span></p>
<p>Переставляем строки (меняем местами 1-ю и 3-ю строки, как уже делали ранее), а столбцы оставляем как есть (то есть $P_R = I). Получим:</p>
<p><span class="math display">\[
P_L =
\begin{bmatrix}
0 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 0
\end{bmatrix}
,~P_L \cdot K =
\begin{bmatrix}
0 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 0
\end{bmatrix}
\cdot
\begin{bmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
5 &amp; 7 &amp; 9
\end{bmatrix}
=
\begin{bmatrix}
5 &amp; 7 &amp; 9 \\
4 &amp; 5 &amp; 6 \\
1 &amp; 2 &amp; 3
\end{bmatrix}
.
\]</span></p>
<p>LU-разложение для матрицы даст уже знакомый результат:</p>
<p><span class="math display">\[
L =
\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0,8 &amp; 1 &amp; 0 \\
0,2 &amp; -1 &amp; 1
\end{bmatrix}
,~U =
\begin{bmatrix}
5 &amp; 7 &amp; 9 \\
0 &amp; -0,6 &amp; -1,2 \\
0 &amp; 0 &amp; 0
\end{bmatrix}
.
\]</span></p>
<p>А дальше просто топаем по алгоритму, находим <span class="math inline">\(P_L \cdot f\)</span>:</p>
<p><span class="math display">\[
P_L \cdot f =
\begin{bmatrix}
0 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 0
\end{bmatrix}
\cdot
\begin{bmatrix}
1 \\ 2 \\ 3
\end{bmatrix}
=
\begin{bmatrix}
3 \\ 2 \\ 1
\end{bmatrix}
\]</span></p>
<p>Решая систему <span class="math inline">\(L \cdot y = P_L \cdot f\)</span>:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0,8 &amp; 1 &amp; 0 \\
0,2 &amp; -1 &amp; 1
\end{bmatrix}
\cdot
\begin{bmatrix}
y_1 \\ y_2 \\ y_3
\end{bmatrix}
=
\begin{bmatrix}
3 \\ 2 \\ 1
\end{bmatrix}
\]</span></p>
<p>Получаем следующий результат:</p>
<p><span class="math display">\[
y =
\begin{bmatrix}
3 \\ -0,4 \\ 0
\end{bmatrix}
\]</span></p>
<p>А решая систему <span class="math inline">\(U \cdot z = y\)</span>:</p>
<p><span class="math display">\[
\begin{bmatrix}
5 &amp; 7 &amp; 9 \\
0 &amp; -0,6 &amp; -1,2 \\
0 &amp; 0 &amp; 0
\end{bmatrix}
\cdot
\begin{bmatrix}
z_1 \\ z_2 \\ z_3
\end{bmatrix}
=
\begin{bmatrix}
3 \\ -0,4 \\ 0
\end{bmatrix}
\]</span></p>
<p>Получаем следующий результат (приравнивая «лишнюю» неизвестную <span class="math inline">\(z_3\)</span> к нулю):</p>
<p><span class="math display">\[
z =
\begin{bmatrix}
-0,333 \\ 0,667 \\ 0
\end{bmatrix}
.
\]</span></p>
<p>Окончательно имеем:</p>
<p><span class="math display">\[
x = P_R \cdot z =
\begin{bmatrix}
-0,333 \\ 0,667 \\ 0
\end{bmatrix}
.
\]</span></p>
<p>Этот результат мы уже неоднократно получали ранее, он представляет собой одно из многочисленных частных решений.</p>
<p>Применим рассмотренный подход к задаче с балкой. Нужная для этого функция будет выглядеть следующим образом:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pardiso_solve(K: np.ndarray, f: np.ndarray) <span class="op">-&gt;</span> NDArray:</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Решает Kx = f через PARDISO для симметричных матриц.</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co">        K (np.ndarray): Симметричная матрица жёсткости (n x n).</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="co">        f (np.ndarray): Вектор сил (n).</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="co">        NDArray: Решение x.</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Преобразуем K в разреженный формат CSR</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    K_sparse <span class="op">=</span> csr_matrix(K)</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Решаем систему через PARDISO</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> spsolve(K_sparse, f)</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>        residual <span class="op">=</span> K <span class="op">@</span> x <span class="op">-</span> f</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Невязка PARDISO: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(residual)<span class="sc">:.2e}</span><span class="ss">"</span>)</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"PARDISO упал с ошибкой: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> np.full_like(f, np.nan)</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Результат выполнения кода с использованием этой функции применительно к задаче о шарнирно опёртой балке с неполным набором граничных условий будет выглядеть так:</p>
<pre><code>Перемещения (PARDISO): [ 0.000e+00  0.000e+00  2.292e-03  0.000e+00  4.586e-01  0.000e+00
  0.000e+00  0.000e+00  4.113e-23  0.000e+00  0.000e+00 -2.292e-03]
Прогиб u_2y (PARDISO): 0.4586 мм</code></pre>
<p>И опять получилась знакомая (и верная, что немаловажно) величина прогиба в 0,4586 мм.</p>
</section>
<section id="mumps" class="level5">
<h5 class="anchored" data-anchor-id="mumps">2.5.3.3 MUMPS</h5>
<p>Используемый по умолчанию в COMSOL решатель MUMPS (MUltifrontal Massively Parallel Sparse direct Solver) – прямой решатель, работающий с <span class="math inline">\(LU\)</span> или <span class="math inline">\(LDL^{T}\)</span> разложением для разреженных систем. Делает то же, что и PARDISO, но с акцентом на параллелизм и большие системы.</p>
<p>Вот тут то и случился у меня праздник сердца. После возни с доступными опциями оказалось, что MUMPS в зависимости от тонких настроек решателя позволяет для нашей тестовой матрицы получить неприлично большое количество частных решений (которые сведены в таблицу 2), показывающих слабую корреляцию к конкретным настройкам. Поскольку обычно эти настройки «лежат» в недосягаемом для пользователя «чёрном ящике» программного комплекса, то трудно сказать, чем должен руководствоваться пользователь при оценке адекватности полученного решения в случае с практически значимой задачей. Тейк в том, что лучше всё таки ставить полный набор граничных условий, не приводящий к «пляскам с бубном».</p>
<div id="tbl-table2" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-table2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;2: Таблица 2
</figcaption>
<div aria-describedby="tbl-table2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 8%">
<col style="width: 6%">
<col style="width: 17%">
<col style="width: 17%">
<col style="width: 17%">
<col style="width: 21%">
</colgroup>
<thead>
<tr class="header">
<th>ICNTL(6)</th>
<th>ICNTL(7)</th>
<th>ICNTL(8)</th>
<th>ICNTL(24)</th>
<th><span class="math inline">\(x_1\)</span></th>
<th><span class="math inline">\(x_2\)</span></th>
<th><span class="math inline">\(x_3\)</span></th>
<th>Residual</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0,333</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0,333</td>
<td>0</td>
</tr>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>7</td>
<td>0</td>
<td>-0,301</td>
<td>0,603</td>
<td>0,032</td>
<td>4,58E-16</td>
</tr>
<tr class="even">
<td>0</td>
<td>0</td>
<td>8</td>
<td>0</td>
<td>-0,203</td>
<td>0,406</td>
<td>0,130</td>
<td>5,44E-16</td>
</tr>
<tr class="odd">
<td>0</td>
<td>6</td>
<td>1</td>
<td>0</td>
<td>-0,112</td>
<td>0,224</td>
<td>0,222</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>6</td>
<td>3</td>
<td>0</td>
<td>0,286</td>
<td>-0,571</td>
<td>0,619</td>
<td>4,58E-16</td>
</tr>
<tr class="odd">
<td>0</td>
<td>6</td>
<td>4</td>
<td>0</td>
<td>-0,286</td>
<td>0,571</td>
<td>0,048</td>
<td>6,66E-16</td>
</tr>
<tr class="even">
<td>0</td>
<td>6</td>
<td>7</td>
<td>0</td>
<td>-0,524</td>
<td>1,047</td>
<td>-0,190</td>
<td>9,16E-16</td>
</tr>
<tr class="odd">
<td>0</td>
<td>6</td>
<td>7</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0,333</td>
<td>6,66E-16</td>
</tr>
<tr class="even">
<td>0</td>
<td>6</td>
<td>8</td>
<td>0</td>
<td>-0,156</td>
<td>0,313</td>
<td>0,177</td>
<td>4,44E-16</td>
</tr>
<tr class="odd">
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>-0,333</td>
<td>0,667</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>2</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>-0,622</td>
<td>1,244</td>
<td>-0,289</td>
<td>4,44E-16</td>
</tr>
<tr class="odd">
<td>2</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>-0,333</td>
<td>0,667</td>
<td>0</td>
<td>4,44E-16</td>
</tr>
<tr class="even">
<td>2</td>
<td>0</td>
<td>3</td>
<td>0</td>
<td>-0,067</td>
<td>0,133</td>
<td>0,267</td>
<td>0</td>
</tr>
<tr class="odd">
<td>2</td>
<td>0</td>
<td>4</td>
<td>0</td>
<td>-0,167</td>
<td>0,333</td>
<td>0,167</td>
<td>4,97E-16</td>
</tr>
<tr class="even">
<td>2</td>
<td>0</td>
<td>7</td>
<td>0</td>
<td>-0,300</td>
<td>0,599</td>
<td>0,034</td>
<td>9,42E-16</td>
</tr>
<tr class="odd">
<td>2</td>
<td>0</td>
<td>8</td>
<td>0</td>
<td>-0,183</td>
<td>0,366</td>
<td>0,150</td>
<td>5,44E-16</td>
</tr>
<tr class="even">
<td>4</td>
<td>0</td>
<td>7</td>
<td>0</td>
<td>-0,288</td>
<td>0,576</td>
<td>0,045</td>
<td>6,66E-16</td>
</tr>
<tr class="odd">
<td>4</td>
<td>0</td>
<td>7</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0,333</td>
<td>8,01E-16</td>
</tr>
<tr class="even">
<td>4</td>
<td>0</td>
<td>8</td>
<td>0</td>
<td>-0,213</td>
<td>0,425</td>
<td>0,121</td>
<td>2,48E-16</td>
</tr>
<tr class="odd">
<td>4</td>
<td>6</td>
<td>3</td>
<td>0</td>
<td>0,533</td>
<td>-1,067</td>
<td>0,867</td>
<td>1,12E-15</td>
</tr>
<tr class="even">
<td>4</td>
<td>6</td>
<td>4</td>
<td>0</td>
<td>-0,356</td>
<td>0,711</td>
<td>-0,022</td>
<td>8,95E-16</td>
</tr>
<tr class="odd">
<td>4</td>
<td>6</td>
<td>7</td>
<td>0</td>
<td>-0,053</td>
<td>0,107</td>
<td>0,280</td>
<td>0</td>
</tr>
<tr class="even">
<td>4</td>
<td>6</td>
<td>8</td>
<td>0</td>
<td>-0,780</td>
<td>1,560</td>
<td>-0,446</td>
<td>2,32E-15</td>
</tr>
<tr class="odd">
<td>5</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0,188</td>
<td>-0,375</td>
<td>0,521</td>
<td>4,58E-16</td>
</tr>
<tr class="even">
<td>5</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>-0,255</td>
<td>0,509</td>
<td>0,079</td>
<td>4,58E-16</td>
</tr>
<tr class="odd">
<td>5</td>
<td>0</td>
<td>3</td>
<td>0</td>
<td>0,302</td>
<td>-0,603</td>
<td>0,635</td>
<td>4,44E-16</td>
</tr>
<tr class="even">
<td>5</td>
<td>0</td>
<td>4</td>
<td>0</td>
<td>-0,133</td>
<td>0,267</td>
<td>0,200</td>
<td>2,22E-16</td>
</tr>
<tr class="odd">
<td>5</td>
<td>0</td>
<td>7</td>
<td>0</td>
<td>-0,507</td>
<td>1,014</td>
<td>-0,174</td>
<td>9,16E-16</td>
</tr>
<tr class="even">
<td>5</td>
<td>0</td>
<td>8</td>
<td>0</td>
<td>-0,352</td>
<td>0,704</td>
<td>-0,019</td>
<td>4,44E-16</td>
</tr>
<tr class="odd">
<td>5</td>
<td>0</td>
<td>77</td>
<td>0</td>
<td>-0,111</td>
<td>0,222</td>
<td>0,222</td>
<td>1,11E-16</td>
</tr>
<tr class="even">
<td>5</td>
<td>6</td>
<td>1</td>
<td>0</td>
<td>-0,189</td>
<td>0,378</td>
<td>0,144</td>
<td>4,97E-16</td>
</tr>
<tr class="odd">
<td>5</td>
<td>6</td>
<td>77</td>
<td>0</td>
<td>-0,250</td>
<td>0,500</td>
<td>0,083</td>
<td>9,99E-16</td>
</tr>
<tr class="even">
<td>6</td>
<td>0</td>
<td>77</td>
<td>0</td>
<td>-0,074</td>
<td>0,148</td>
<td>0,259</td>
<td>2,22E-16</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>Применим этот подход к задаче с балкой. Нужная функция будет выглядеть следующим образом:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mumps_solve(K: np.ndarray, f: np.ndarray) <span class="op">-&gt;</span> NDArray:</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Решает систему через MUMPS без стабилизации.</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="co">        K (np.ndarray): Матрица жёсткости (n x n).</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="co">        f (np.ndarray): Вектор сил (n).</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="co">        NDArray: Решение x.</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    K_sparse <span class="op">=</span> csr_matrix(K)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    solver <span class="op">=</span> DMumpsContext()</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Включаем вывод для диагностики</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    solver.set_icntl(<span class="dv">1</span>, <span class="dv">6</span>)     <span class="co"># Вывод ошибок</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    solver.set_icntl(<span class="dv">3</span>, <span class="dv">6</span>)     <span class="co"># Глобальная информация</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    solver.set_icntl(<span class="dv">4</span>, <span class="dv">1</span>)     <span class="co"># Уровень вывода (1 — только ошибки)</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>    solver.set_icntl(<span class="dv">7</span>, <span class="dv">5</span>)     <span class="co"># METIS для упорядочения</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>    solver.set_icntl(<span class="dv">14</span>, <span class="dv">100</span>)  <span class="co"># Максимум памяти</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>    solver.set_icntl(<span class="dv">24</span>, <span class="dv">1</span>)    <span class="co"># Обнаружение вырожденности</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>    solver.set_icntl(<span class="dv">25</span>, <span class="dv">0</span>)    <span class="co"># По умолчанию</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>    f_copy <span class="op">=</span> f.copy()   <span class="co"># копируем f, чтобы не портить оригинал, а то потом хер найдёшь ошибку</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>    solver.set_centralized_sparse(K_sparse)</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>    solver.set_rhs(f_copy)</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>        solver.run(job<span class="op">=</span><span class="dv">1</span>)  <span class="co"># Анализ</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Анализ прошёл"</span>)</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>        solver.run(job<span class="op">=</span><span class="dv">2</span>)  <span class="co"># Факторизация</span></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Факторизация прошла"</span>)</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>        solver.run(job<span class="op">=</span><span class="dv">3</span>)  <span class="co"># Решение</span></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Решение найдено"</span>)</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> f_copy    <span class="co"># f_copy теперь содержит решение</span></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>        residual <span class="op">=</span> K <span class="op">@</span> x <span class="op">-</span> f    <span class="co"># Считаем невязку с исходным f</span></span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Невязка MUMPS: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(residual)<span class="sc">:.2e}</span><span class="ss">"</span>)</span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">RuntimeError</span> <span class="im">as</span> e:</span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"MUMPS упал с ошибкой: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> np.full_like(f, np.nan)</span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">finally</span>:</span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a>        solver.destroy()</span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Или, если отвязаться от настроек MUMPS и выполнить часть операций вручную:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mumps_like_lu_solve(K: np.ndarray, f: np.ndarray) <span class="op">-&gt;</span> NDArray:</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Решает Kx = f через LU с RCM, как MUMPS для несимметричных матриц.</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="co">        K (np.ndarray): Матрица жёсткости (n x n).</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="co">        f (np.ndarray): Вектор сил (n).</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="co">        NDArray: Частное решение x, совместимое с f.</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Упорядочение RCM</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    K_sparse <span class="op">=</span> csr_matrix(K)</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    perm <span class="op">=</span> reverse_cuthill_mckee(K_sparse, symmetric_mode<span class="op">=</span><span class="va">True</span>)   <span class="co"># симметричная матрица</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Перестановка perm = </span><span class="sc">{</span>perm<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Перестановка k_red и f_red</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>    K_perm <span class="op">=</span> K[np.ix_(perm, perm)]</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>    f_perm <span class="op">=</span> f[perm]</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># LU-разложение</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>    P, L, U <span class="op">=</span> lu(K_perm)</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Прямая подстановка: L y = P F_perm</span></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>    PF_perm <span class="op">=</span> P <span class="op">@</span> f_perm</span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.linalg.solve(L, PF_perm)</span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Обратная подстановка U u_perm = y</span></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(U)</span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>    x_perm <span class="op">=</span> np.zeros(n)</span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>    tol <span class="op">=</span> <span class="fl">1e-10</span></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">abs</span>(U[i, i]) <span class="op">&lt;</span> tol:</span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">abs</span>(y[i]) <span class="op">&lt;</span> tol:</span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a>                x_perm[i] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Система несовместима на шаге </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a>            x_perm[i] <span class="op">=</span> (y[i] <span class="op">-</span> np.dot(U[i, i<span class="op">+</span><span class="dv">1</span>:], x_perm[i<span class="op">+</span><span class="dv">1</span>:])) <span class="op">/</span> U[i, i]</span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Обратная перестановка</span></span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a>    x_red <span class="op">=</span> np.zeros(n)</span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, p <span class="kw">in</span> <span class="bu">enumerate</span>(perm):</span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a>        x_red[p] <span class="op">=</span> x_perm[i]</span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x_red</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Результат выполнения кода с использованием этих функций применительно к задаче о шарнирно опёртой балке с неполным набором граничных условий будет выглядеть так:</p>
<pre><code>Перемещения (MUMPS): [ 0.000e+00  0.000e+00  2.292e-03  0.000e+00  4.586e-01  0.000e+00
  0.000e+00  0.000e+00  1.440e-19  0.000e+00  0.000e+00 -2.292e-03]
Прогиб u_2y (MUMPS): 0.4586 мм
Перемещения (LU): [ 0.000e+00 -0.000e+00  2.292e-03  0.000e+00  4.586e-01  0.000e+00
  0.000e+00  0.000e+00 -2.028e-20  0.000e+00  0.000e+00 -2.292e-03]
Прогиб u_2y (LU): 0.4586 мм
</code></pre>
<p>В обоих рассмотренных случаях получилась верная величина прогиба балки 0,4586 мм.</p>
<hr>
</section>
</section>
</section>
</section>
<section id="вывод" class="level2">
<h2 class="anchored" data-anchor-id="вывод">Вывод</h2>
<hr>
<p>Какие выводы мы можем сделать из проведённых расчётов несчастной балочки с использованием прямых методов:</p>
<ol type="1">
<li><p>ANSYS и NASTRAN с настройками по умолчанию требуют задания полного набора граничных условий, позволяющего получить однозначное «честное» решение.</p></li>
<li><p>Применение «мягких пружин», позволяет устранить вырожденность матрицы жёсткости при неполном наборе граничных условий и получить близкое к «честному» решение (если их жёсткость и в самом деле невелика), однако стоит ясно представлять себе, что за «пружины» вы используете (как в примере с ANSYS).</p></li>
<li><p>Такие программные комплексы как COMSOL, ABAQUS, OptiStruct и ЛОГОС позволяют получить решение при неполном наборе граничных условий, так как заложенные алгоритмы с помощью перестановок и разложений приводят к получению некоторого частного решения. В рассмотренном случае с балкой, полученные таким образом решения, оказались достаточно близки к точному. Тем не менее, для тестовой матрицы при использовании алгоритма MUMPS был получен целый набор частных решений, в зависимости от настроек решателя, которые пользователю не всегда доступны. Таким образом, применение полного набора граничных условий, независимо от используемого алгоритма, лишает нас неопределённости при интерпретации результатов.</p></li>
<li><p>Хвалёный ABAQUS выдал решение, отличающееся на 7% от эталонного. Но так как в повседневной жизни я его не использую и достаю из пыльного ящика только в случае каких-то тестов для кроссверификации, и с первоначальным вопросом это расхождение имеет мало общего, то и ковырять его дальше мне лениво.</p></li>
<li><p>Итоговый код, реализующий все рассмотренные подходы, представлен ниже:</p></li>
</ol>
<div class="sourceCode" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy.typing <span class="im">import</span> NDArray    <span class="co">## Тип для массивов NumPy</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Tuple, List      <span class="co">## Типы для подсказок, что возвращают функции</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> linalg</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="co">## импорт для MUMPS-like реализации</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.linalg <span class="im">import</span> lu</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.sparse <span class="im">import</span> csr_matrix</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.sparse.csgraph <span class="im">import</span> reverse_cuthill_mckee</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="co">## импорт для MUMPS (е**я кочергой)</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mumps <span class="im">import</span> DMumpsContext</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a><span class="co">## импорт для PARDISO</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pypardiso <span class="im">import</span> spsolve  <span class="co"># Основная функция для решения</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a><span class="co">## теперь можно и время померять</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> wraps</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> measure_time(func):</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Декоратор для замера времени выполнения функции."""</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    <span class="at">@wraps</span>(func)</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> wrapper(<span class="op">*</span>args, <span class="op">**</span>kwargs):</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>        start <span class="op">=</span> time.perf_counter()</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> func(<span class="op">*</span>args, <span class="op">**</span>kwargs)</span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>        elapsed <span class="op">=</span> time.perf_counter() <span class="op">-</span> start</span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"*************************************"</span>)</span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"*************************************"</span>)</span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>func<span class="sc">.</span><span class="va">__name__</span><span class="sc">}</span><span class="ss"> time: </span><span class="sc">{</span>elapsed<span class="sc">:.6f}</span><span class="ss"> с"</span>)</span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result</span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> wrapper</span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a><span class="at">@measure_time</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> my_solve(A: np.ndarray, b: np.ndarray) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a><span class="co">    Решение системы уравнений А * х = b методом Гаусса с частичным выбором ведущего элемента</span></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a><span class="co">         A(np.ndarray): Квадратная матрица (n x n)</span></span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a><span class="co">         b(np.ndarray): Вектор правой части (n)</span></span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a><span class="co">        np.ndarray: Вектор решения х (n)</span></span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a><span class="co">    Raises:</span></span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a><span class="co">        ValueError: Если матрица не квадратная или вырожденная (детерминант ≈ 0)</span></span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-43"><a href="#cb25-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Размер системы - число уравнений (и переменных)</span></span>
<span id="cb25-44"><a href="#cb25-44" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(b)</span>
<span id="cb25-45"><a href="#cb25-45" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Проверяем, что матрица квадратная и соответствует вектору b</span></span>
<span id="cb25-46"><a href="#cb25-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> A.shape <span class="op">!=</span> (n, n):</span>
<span id="cb25-47"><a href="#cb25-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Матрица А должна быть квадратной и соответствовать b!"</span>)</span>
<span id="cb25-48"><a href="#cb25-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Копируем А и b, чтобы не менять оригиналы (работаем с копиями)</span></span>
<span id="cb25-49"><a href="#cb25-49" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> A.copy()</span>
<span id="cb25-50"><a href="#cb25-50" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> b.copy()</span>
<span id="cb25-51"><a href="#cb25-51" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Прямой ход: превращаем А в верхнетреугольную матрицу (нули под диагональю)</span></span>
<span id="cb25-52"><a href="#cb25-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb25-53"><a href="#cb25-53" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Ищем ведущий элемент (pivot) - самый большой по модулю в столбце i...</span></span>
<span id="cb25-54"><a href="#cb25-54" aria-hidden="true" tabindex="-1"></a>        max_idx <span class="op">=</span> i <span class="co">## ...начинаем с текущей строки...</span></span>
<span id="cb25-55"><a href="#cb25-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>, n):     <span class="co">## ...и смотрим все строки ниже</span></span>
<span id="cb25-56"><a href="#cb25-56" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">abs</span>(A[k, i]) <span class="op">&gt;</span> <span class="bu">abs</span>(A[max_idx, i]):</span>
<span id="cb25-57"><a href="#cb25-57" aria-hidden="true" tabindex="-1"></a>                max_idx <span class="op">=</span> k     <span class="co">## Запоминаем строку с максимальным элементом</span></span>
<span id="cb25-58"><a href="#cb25-58" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Проверяем, не слишком ли маленький pivot (если ≈ 0, матрица вырожденная)</span></span>
<span id="cb25-59"><a href="#cb25-59" aria-hidden="true" tabindex="-1"></a>        pivot <span class="op">=</span> A[max_idx, i]</span>
<span id="cb25-60"><a href="#cb25-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">abs</span>(pivot) <span class="op">&lt;</span> <span class="fl">1e-10</span>:      <span class="co">## 1e-10 — порог для учёта ошибок округления</span></span>
<span id="cb25-61"><a href="#cb25-61" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Матрица вырожденна на шаге </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">!"</span>)</span>
<span id="cb25-62"><a href="#cb25-62" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Если нашли больший элемент ниже, меняем строки местами</span></span>
<span id="cb25-63"><a href="#cb25-63" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> max_idx <span class="op">!=</span> i:</span>
<span id="cb25-64"><a href="#cb25-64" aria-hidden="true" tabindex="-1"></a>            A[[i, max_idx]] <span class="op">=</span> A[[max_idx, i]]       <span class="co">## Меняем строки в матрице A</span></span>
<span id="cb25-65"><a href="#cb25-65" aria-hidden="true" tabindex="-1"></a>            b[i], b[max_idx] <span class="op">=</span> b[max_idx], b[i]     <span class="co">## Меняем элементы в векторе b</span></span>
<span id="cb25-66"><a href="#cb25-66" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Делаем ведущий элемент равным 1: делим строку i на pivot</span></span>
<span id="cb25-67"><a href="#cb25-67" aria-hidden="true" tabindex="-1"></a>        A[i, :] <span class="op">=</span> A[i, :] <span class="op">/</span> pivot</span>
<span id="cb25-68"><a href="#cb25-68" aria-hidden="true" tabindex="-1"></a>        b[i] <span class="op">=</span> b[i] <span class="op">/</span> pivot</span>
<span id="cb25-69"><a href="#cb25-69" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Убираем элементы под ведущим элементом (делаем нули в столбце i)</span></span>
<span id="cb25-70"><a href="#cb25-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, n):                   <span class="co">## Проходим по строкам ниже текущей</span></span>
<span id="cb25-71"><a href="#cb25-71" aria-hidden="true" tabindex="-1"></a>            factor <span class="op">=</span> A[j, i]                        <span class="co">## Коэффициент, на который умножаем строку i</span></span>
<span id="cb25-72"><a href="#cb25-72" aria-hidden="true" tabindex="-1"></a>            A[j, :] <span class="op">=</span> A[j, :] <span class="op">-</span> factor <span class="op">*</span> A[i, :]    <span class="co">## Вычитаем, чтобы обнулить A[j, i]</span></span>
<span id="cb25-73"><a href="#cb25-73" aria-hidden="true" tabindex="-1"></a>            b[j] <span class="op">=</span> b[j] <span class="op">-</span> factor <span class="op">*</span> b[i]             <span class="co">## То же для правой части</span></span>
<span id="cb25-74"><a href="#cb25-74" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Обратный ход: решаем систему снизу вверх, начиная с последнего уравнения</span></span>
<span id="cb25-75"><a href="#cb25-75" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.zeros(n)                         <span class="co">## Создаём вектор для хранения решения</span></span>
<span id="cb25-76"><a href="#cb25-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):            <span class="co">## Идём от последней строки к первой</span></span>
<span id="cb25-77"><a href="#cb25-77" aria-hidden="true" tabindex="-1"></a>        x[i] <span class="op">=</span> b[i]                         <span class="co">## Берём правую часть текущего уравнения</span></span>
<span id="cb25-78"><a href="#cb25-78" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Вычитаем все уже найденные переменные (x[j] для j &gt; i)</span></span>
<span id="cb25-79"><a href="#cb25-79" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>, n):</span>
<span id="cb25-80"><a href="#cb25-80" aria-hidden="true" tabindex="-1"></a>            x[i] <span class="op">=</span> x[i] <span class="op">-</span> A[i, j] <span class="op">*</span> x[j]    <span class="co">## Учитываем влияние верхних элементов</span></span>
<span id="cb25-81"><a href="#cb25-81" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span>
<span id="cb25-82"><a href="#cb25-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-83"><a href="#cb25-83" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plu_decomposition(A: np.ndarray) <span class="op">-&gt;</span> Tuple[np.ndarray, np.ndarray, np.ndarray]:</span>
<span id="cb25-84"><a href="#cb25-84" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb25-85"><a href="#cb25-85" aria-hidden="true" tabindex="-1"></a><span class="co">    Выполняет PLU-разложение матрицы A на P (перестановки), L (нижнетреугольная), U (верхнетреугольная).</span></span>
<span id="cb25-86"><a href="#cb25-86" aria-hidden="true" tabindex="-1"></a><span class="co">      Args:</span></span>
<span id="cb25-87"><a href="#cb25-87" aria-hidden="true" tabindex="-1"></a><span class="co">        A (np.ndarray): Квадратная матрица (n x n).</span></span>
<span id="cb25-88"><a href="#cb25-88" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb25-89"><a href="#cb25-89" aria-hidden="true" tabindex="-1"></a><span class="co">        Tuple[np.ndarray, np.ndarray, np.ndarray]: Матрицы P, L, U.</span></span>
<span id="cb25-90"><a href="#cb25-90" aria-hidden="true" tabindex="-1"></a><span class="co">    Raises:</span></span>
<span id="cb25-91"><a href="#cb25-91" aria-hidden="true" tabindex="-1"></a><span class="co">        ValueError: Если матрица не квадратная.</span></span>
<span id="cb25-92"><a href="#cb25-92" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb25-93"><a href="#cb25-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-94"><a href="#cb25-94" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> A.shape[<span class="dv">0</span>]</span>
<span id="cb25-95"><a href="#cb25-95" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> A.shape[<span class="dv">0</span>] <span class="op">!=</span> A.shape[<span class="dv">1</span>]:</span>
<span id="cb25-96"><a href="#cb25-96" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Матрица должна быть квадратной!"</span>)</span>
<span id="cb25-97"><a href="#cb25-97" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Копируем А</span></span>
<span id="cb25-98"><a href="#cb25-98" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> A.copy()</span>
<span id="cb25-99"><a href="#cb25-99" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Инициализируем P (единичная матрица), L и U</span></span>
<span id="cb25-100"><a href="#cb25-100" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> np.eye(n)  <span class="co">## Матрица перестановок начинается как единичная</span></span>
<span id="cb25-101"><a href="#cb25-101" aria-hidden="true" tabindex="-1"></a>    L <span class="op">=</span> np.zeros((n, n))</span>
<span id="cb25-102"><a href="#cb25-102" aria-hidden="true" tabindex="-1"></a>    U <span class="op">=</span> np.zeros((n, n))</span>
<span id="cb25-103"><a href="#cb25-103" aria-hidden="true" tabindex="-1"></a>    np.fill_diagonal(L, <span class="dv">1</span>)  <span class="co"># Единицы на диагонали L</span></span>
<span id="cb25-104"><a href="#cb25-104" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Разложение с перестановками</span></span>
<span id="cb25-105"><a href="#cb25-105" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb25-106"><a href="#cb25-106" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Ищем максимальный элемент в столбце i от i до конца</span></span>
<span id="cb25-107"><a href="#cb25-107" aria-hidden="true" tabindex="-1"></a>        max_idx <span class="op">=</span> i</span>
<span id="cb25-108"><a href="#cb25-108" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, n):</span>
<span id="cb25-109"><a href="#cb25-109" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">abs</span>(A[k, i]) <span class="op">&gt;</span> <span class="bu">abs</span>(A[max_idx, i]):</span>
<span id="cb25-110"><a href="#cb25-110" aria-hidden="true" tabindex="-1"></a>                max_idx <span class="op">=</span> k</span>
<span id="cb25-111"><a href="#cb25-111" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Если нужно, меняем строки в A и P</span></span>
<span id="cb25-112"><a href="#cb25-112" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> max_idx <span class="op">!=</span> i:</span>
<span id="cb25-113"><a href="#cb25-113" aria-hidden="true" tabindex="-1"></a>            A[[i, max_idx]] <span class="op">=</span> A[[max_idx, i]]</span>
<span id="cb25-114"><a href="#cb25-114" aria-hidden="true" tabindex="-1"></a>            P[[i, max_idx]] <span class="op">=</span> P[[max_idx, i]]</span>
<span id="cb25-115"><a href="#cb25-115" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Исправляем L: меняем строки до i (кроме диагонали)</span></span>
<span id="cb25-116"><a href="#cb25-116" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb25-117"><a href="#cb25-117" aria-hidden="true" tabindex="-1"></a>                L[[i, max_idx], :i] <span class="op">=</span> L[[max_idx, i], :i]</span>
<span id="cb25-118"><a href="#cb25-118" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Заполняем U: элементы на диагонали и выше</span></span>
<span id="cb25-119"><a href="#cb25-119" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i, n):</span>
<span id="cb25-120"><a href="#cb25-120" aria-hidden="true" tabindex="-1"></a>            U[i, j] <span class="op">=</span> A[i, j] <span class="op">-</span> <span class="bu">sum</span>(L[i, k] <span class="op">*</span> U[k, j] <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i))</span>
<span id="cb25-121"><a href="#cb25-121" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Заполняем L: элементы под диагональю</span></span>
<span id="cb25-122"><a href="#cb25-122" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, n):</span>
<span id="cb25-123"><a href="#cb25-123" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">abs</span>(U[i, i]) <span class="op">&lt;</span> <span class="fl">1e-10</span>:</span>
<span id="cb25-124"><a href="#cb25-124" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Деление на ноль на шаге </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">!"</span>)</span>
<span id="cb25-125"><a href="#cb25-125" aria-hidden="true" tabindex="-1"></a>            L[j, i] <span class="op">=</span> (A[j, i] <span class="op">-</span> <span class="bu">sum</span>(L[j, k] <span class="op">*</span> U[k, i] <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i))) <span class="op">/</span> U[i, i]</span>
<span id="cb25-126"><a href="#cb25-126" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> P, L, U</span>
<span id="cb25-127"><a href="#cb25-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-128"><a href="#cb25-128" aria-hidden="true" tabindex="-1"></a><span class="at">@measure_time</span></span>
<span id="cb25-129"><a href="#cb25-129" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plu_solve(A: np.ndarray, b: np.ndarray) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb25-130"><a href="#cb25-130" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb25-131"><a href="#cb25-131" aria-hidden="true" tabindex="-1"></a><span class="co">     Решает систему A * x = b с помощью PLU-разложения.</span></span>
<span id="cb25-132"><a href="#cb25-132" aria-hidden="true" tabindex="-1"></a><span class="co">     Args:</span></span>
<span id="cb25-133"><a href="#cb25-133" aria-hidden="true" tabindex="-1"></a><span class="co">         A (np.ndarray): Квадратная матрица (n x n).</span></span>
<span id="cb25-134"><a href="#cb25-134" aria-hidden="true" tabindex="-1"></a><span class="co">         b (np.ndarray): Вектор правой части (n).</span></span>
<span id="cb25-135"><a href="#cb25-135" aria-hidden="true" tabindex="-1"></a><span class="co">     Returns:</span></span>
<span id="cb25-136"><a href="#cb25-136" aria-hidden="true" tabindex="-1"></a><span class="co">         np.ndarray: Вектор решения x (n).</span></span>
<span id="cb25-137"><a href="#cb25-137" aria-hidden="true" tabindex="-1"></a><span class="co">     """</span></span>
<span id="cb25-138"><a href="#cb25-138" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Получаем P, L, U</span></span>
<span id="cb25-139"><a href="#cb25-139" aria-hidden="true" tabindex="-1"></a>    P, L, U <span class="op">=</span> plu_decomposition(A)</span>
<span id="cb25-140"><a href="#cb25-140" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(b)</span>
<span id="cb25-141"><a href="#cb25-141" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> b.copy()</span>
<span id="cb25-142"><a href="#cb25-142" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Применяем перестановки к b: Pb = P * b</span></span>
<span id="cb25-143"><a href="#cb25-143" aria-hidden="true" tabindex="-1"></a>    Pb <span class="op">=</span> P <span class="op">@</span> b</span>
<span id="cb25-144"><a href="#cb25-144" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Прямой ход: решаем L * y = Pb</span></span>
<span id="cb25-145"><a href="#cb25-145" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.zeros(n)</span>
<span id="cb25-146"><a href="#cb25-146" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb25-147"><a href="#cb25-147" aria-hidden="true" tabindex="-1"></a>        y[i] <span class="op">=</span> Pb[i] <span class="op">-</span> <span class="bu">sum</span>(L[i, j] <span class="op">*</span> y[j] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i))</span>
<span id="cb25-148"><a href="#cb25-148" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Обратный ход: решаем U * x = y</span></span>
<span id="cb25-149"><a href="#cb25-149" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.zeros(n)</span>
<span id="cb25-150"><a href="#cb25-150" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb25-151"><a href="#cb25-151" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">abs</span>(U[i, i]) <span class="op">&lt;</span> <span class="fl">1e-10</span>:</span>
<span id="cb25-152"><a href="#cb25-152" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Деление на ноль в U на шаге </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">!"</span>)</span>
<span id="cb25-153"><a href="#cb25-153" aria-hidden="true" tabindex="-1"></a>        x[i] <span class="op">=</span> (y[i] <span class="op">-</span> <span class="bu">sum</span>(U[i, j] <span class="op">*</span> x[j] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, n))) <span class="op">/</span> U[i, i]</span>
<span id="cb25-154"><a href="#cb25-154" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span>
<span id="cb25-155"><a href="#cb25-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-156"><a href="#cb25-156" aria-hidden="true" tabindex="-1"></a><span class="at">@measure_time</span></span>
<span id="cb25-157"><a href="#cb25-157" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> svd_solve(A: np.ndarray, b: np.ndarray, tol: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1e-10</span>) <span class="op">-&gt;</span> Tuple[np.ndarray, np.ndarray]:</span>
<span id="cb25-158"><a href="#cb25-158" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb25-159"><a href="#cb25-159" aria-hidden="true" tabindex="-1"></a><span class="co">    Решает вырожденную систему через SVD, возвращая частное решение и базис ядра.</span></span>
<span id="cb25-160"><a href="#cb25-160" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb25-161"><a href="#cb25-161" aria-hidden="true" tabindex="-1"></a><span class="co">        A (np.ndarray): Матрица (n x n).</span></span>
<span id="cb25-162"><a href="#cb25-162" aria-hidden="true" tabindex="-1"></a><span class="co">        b (np.ndarray): Вектор правой части (n).</span></span>
<span id="cb25-163"><a href="#cb25-163" aria-hidden="true" tabindex="-1"></a><span class="co">        tol (float): Порог для обрезки сингулярных значений.</span></span>
<span id="cb25-164"><a href="#cb25-164" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb25-165"><a href="#cb25-165" aria-hidden="true" tabindex="-1"></a><span class="co">        Tuple[np.ndarray, np.ndarray]: Частное решение x_p и базис ядра (столбцы).</span></span>
<span id="cb25-166"><a href="#cb25-166" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb25-167"><a href="#cb25-167" aria-hidden="true" tabindex="-1"></a>    U, Sigma, Vt <span class="op">=</span> np.linalg.svd(A)</span>
<span id="cb25-168"><a href="#cb25-168" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(b)</span>
<span id="cb25-169"><a href="#cb25-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-170"><a href="#cb25-170" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Частное решение</span></span>
<span id="cb25-171"><a href="#cb25-171" aria-hidden="true" tabindex="-1"></a>    Sigma_plus <span class="op">=</span> np.zeros((n, n))</span>
<span id="cb25-172"><a href="#cb25-172" aria-hidden="true" tabindex="-1"></a>    rank <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb25-173"><a href="#cb25-173" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb25-174"><a href="#cb25-174" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> Sigma[i] <span class="op">&gt;</span> tol:</span>
<span id="cb25-175"><a href="#cb25-175" aria-hidden="true" tabindex="-1"></a>            Sigma_plus[i, i] <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> Sigma[i]</span>
<span id="cb25-176"><a href="#cb25-176" aria-hidden="true" tabindex="-1"></a>            rank <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb25-177"><a href="#cb25-177" aria-hidden="true" tabindex="-1"></a>    x_p <span class="op">=</span> Vt.T <span class="op">@</span> Sigma_plus <span class="op">@</span> U.T <span class="op">@</span> b</span>
<span id="cb25-178"><a href="#cb25-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-179"><a href="#cb25-179" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Базис ядра (столбцы Vt для нулевых Sigma)</span></span>
<span id="cb25-180"><a href="#cb25-180" aria-hidden="true" tabindex="-1"></a>    kernel_basis <span class="op">=</span> Vt[rank:].T  <span class="co"># Транспонируем, чтобы столбцы были векторами</span></span>
<span id="cb25-181"><a href="#cb25-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-182"><a href="#cb25-182" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x_p, kernel_basis</span>
<span id="cb25-183"><a href="#cb25-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-184"><a href="#cb25-184" aria-hidden="true" tabindex="-1"></a><span class="at">@measure_time</span></span>
<span id="cb25-185"><a href="#cb25-185" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tikhonov_solve(A: np.ndarray, b: np.ndarray, lambda_: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1e-6</span>) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb25-186"><a href="#cb25-186" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb25-187"><a href="#cb25-187" aria-hidden="true" tabindex="-1"></a><span class="co">    Решает вырожденную систему через регуляризацию Тихонова: (A^T A + λI) x = A^T b.</span></span>
<span id="cb25-188"><a href="#cb25-188" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb25-189"><a href="#cb25-189" aria-hidden="true" tabindex="-1"></a><span class="co">        A (np.ndarray): Матрица (n x n).</span></span>
<span id="cb25-190"><a href="#cb25-190" aria-hidden="true" tabindex="-1"></a><span class="co">        b (np.ndarray): Вектор правой части (n).</span></span>
<span id="cb25-191"><a href="#cb25-191" aria-hidden="true" tabindex="-1"></a><span class="co">        lambda_ (float): Параметр регуляризации.</span></span>
<span id="cb25-192"><a href="#cb25-192" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb25-193"><a href="#cb25-193" aria-hidden="true" tabindex="-1"></a><span class="co">        np.ndarray: Решение x.</span></span>
<span id="cb25-194"><a href="#cb25-194" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb25-195"><a href="#cb25-195" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(b)</span>
<span id="cb25-196"><a href="#cb25-196" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Решаем уравнение с добавленной регуляризацией</span></span>
<span id="cb25-197"><a href="#cb25-197" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.linalg.solve(A.T <span class="op">@</span> A <span class="op">+</span> lambda_ <span class="op">*</span> np.eye(n), A.T <span class="op">@</span> b)</span>
<span id="cb25-198"><a href="#cb25-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-199"><a href="#cb25-199" aria-hidden="true" tabindex="-1"></a><span class="at">@measure_time</span></span>
<span id="cb25-200"><a href="#cb25-200" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> spring_solve(K: np.ndarray, f: np.ndarray, global_spring_indices: List[<span class="bu">int</span>], free_dofs: List[<span class="bu">int</span>],</span>
<span id="cb25-201"><a href="#cb25-201" aria-hidden="true" tabindex="-1"></a>                 epsilon_factor: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1e-6</span>) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb25-202"><a href="#cb25-202" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb25-203"><a href="#cb25-203" aria-hidden="true" tabindex="-1"></a><span class="co">    Решает систему с "мягкими пружинами" на заданных глобальных индексах, учитывая свободные степени.</span></span>
<span id="cb25-204"><a href="#cb25-204" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb25-205"><a href="#cb25-205" aria-hidden="true" tabindex="-1"></a><span class="co">        K (np.ndarray): Ред. матрица жёсткости (n x n).</span></span>
<span id="cb25-206"><a href="#cb25-206" aria-hidden="true" tabindex="-1"></a><span class="co">        f (np.ndarray): Ред. вектор сил (n).</span></span>
<span id="cb25-207"><a href="#cb25-207" aria-hidden="true" tabindex="-1"></a><span class="co">        global_spring_indices (List[int]): Глобальные индексы для пружин (в K_global).</span></span>
<span id="cb25-208"><a href="#cb25-208" aria-hidden="true" tabindex="-1"></a><span class="co">        free_dofs (List[int]): Свободные степени свободы (глобальные индексы).</span></span>
<span id="cb25-209"><a href="#cb25-209" aria-hidden="true" tabindex="-1"></a><span class="co">        epsilon_factor (float): Фактор масштабирования жёсткости.</span></span>
<span id="cb25-210"><a href="#cb25-210" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb25-211"><a href="#cb25-211" aria-hidden="true" tabindex="-1"></a><span class="co">        NDArray | None: Решение x или None, если матрица сингулярна.</span></span>
<span id="cb25-212"><a href="#cb25-212" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb25-213"><a href="#cb25-213" aria-hidden="true" tabindex="-1"></a>    K_stab <span class="op">=</span> K.copy()</span>
<span id="cb25-214"><a href="#cb25-214" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(free_dofs)</span>
<span id="cb25-215"><a href="#cb25-215" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Базовая жёсткость из K_red</span></span>
<span id="cb25-216"><a href="#cb25-216" aria-hidden="true" tabindex="-1"></a>    k_base <span class="op">=</span> K[<span class="dv">2</span>, <span class="dv">2</span>] <span class="cf">if</span> <span class="bu">abs</span>(K[<span class="dv">2</span>, <span class="dv">2</span>]) <span class="op">&gt;</span> <span class="fl">1e-10</span> <span class="cf">else</span> np.mean(np.diag(K))</span>
<span id="cb25-217"><a href="#cb25-217" aria-hidden="true" tabindex="-1"></a>    epsilon <span class="op">=</span> epsilon_factor <span class="op">*</span> k_base</span>
<span id="cb25-218"><a href="#cb25-218" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Переводим глобальные индексы в локальные для K_red</span></span>
<span id="cb25-219"><a href="#cb25-219" aria-hidden="true" tabindex="-1"></a>    stab_indices <span class="op">=</span> [free_dofs.index(idx) <span class="cf">for</span> idx <span class="kw">in</span> global_spring_indices <span class="cf">if</span> idx <span class="kw">in</span> free_dofs]</span>
<span id="cb25-220"><a href="#cb25-220" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Добавляем жёсткость только к активным индексам</span></span>
<span id="cb25-221"><a href="#cb25-221" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> idx <span class="kw">in</span> stab_indices:</span>
<span id="cb25-222"><a href="#cb25-222" aria-hidden="true" tabindex="-1"></a>        K_stab[idx, idx] <span class="op">+=</span> epsilon</span>
<span id="cb25-223"><a href="#cb25-223" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Пробуем решить с обработкой сингулярности</span></span>
<span id="cb25-224"><a href="#cb25-224" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb25-225"><a href="#cb25-225" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.linalg.solve(K_stab, f)</span>
<span id="cb25-226"><a href="#cb25-226" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> np.linalg.LinAlgError:</span>
<span id="cb25-227"><a href="#cb25-227" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"spring_solve: матрица сингулярна, стабилизация не помогла (активные индексы: </span><span class="sc">{</span>stab_indices<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb25-228"><a href="#cb25-228" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb25-229"><a href="#cb25-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-230"><a href="#cb25-230" aria-hidden="true" tabindex="-1"></a><span class="at">@measure_time</span></span>
<span id="cb25-231"><a href="#cb25-231" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> qr_solve(K: np.ndarray, f: np.ndarray, tol: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1e-10</span>) <span class="op">-&gt;</span> NDArray:</span>
<span id="cb25-232"><a href="#cb25-232" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb25-233"><a href="#cb25-233" aria-hidden="true" tabindex="-1"></a><span class="co">    Решает систему через QR-разложение с выбором ранга.</span></span>
<span id="cb25-234"><a href="#cb25-234" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb25-235"><a href="#cb25-235" aria-hidden="true" tabindex="-1"></a><span class="co">        K (np.ndarray): Матрица жёсткости (n x n).</span></span>
<span id="cb25-236"><a href="#cb25-236" aria-hidden="true" tabindex="-1"></a><span class="co">        f (np.ndarray): Вектор сил (n).</span></span>
<span id="cb25-237"><a href="#cb25-237" aria-hidden="true" tabindex="-1"></a><span class="co">        tol (float): Порог для определения ранга.</span></span>
<span id="cb25-238"><a href="#cb25-238" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb25-239"><a href="#cb25-239" aria-hidden="true" tabindex="-1"></a><span class="co">        NDArray: Решение x.</span></span>
<span id="cb25-240"><a href="#cb25-240" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb25-241"><a href="#cb25-241" aria-hidden="true" tabindex="-1"></a>    <span class="co"># QR-разложение с поворотами</span></span>
<span id="cb25-242"><a href="#cb25-242" aria-hidden="true" tabindex="-1"></a>    Q, R, P <span class="op">=</span> linalg.qr(K, pivoting<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb25-243"><a href="#cb25-243" aria-hidden="true" tabindex="-1"></a>    rank <span class="op">=</span> <span class="bu">sum</span>(<span class="bu">abs</span>(np.diag(R)) <span class="op">&gt;</span> tol)  <span class="co"># Определяем ранг</span></span>
<span id="cb25-244"><a href="#cb25-244" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Решаем усечённую систему</span></span>
<span id="cb25-245"><a href="#cb25-245" aria-hidden="true" tabindex="-1"></a>    Qb <span class="op">=</span> Q.T <span class="op">@</span> f</span>
<span id="cb25-246"><a href="#cb25-246" aria-hidden="true" tabindex="-1"></a>    R_red <span class="op">=</span> R[:rank, :rank]</span>
<span id="cb25-247"><a href="#cb25-247" aria-hidden="true" tabindex="-1"></a>    Qb_red <span class="op">=</span> Qb[:rank]</span>
<span id="cb25-248"><a href="#cb25-248" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Обратная подстановка для усечённой части</span></span>
<span id="cb25-249"><a href="#cb25-249" aria-hidden="true" tabindex="-1"></a>    x_red <span class="op">=</span> np.linalg.solve(R_red, Qb_red)</span>
<span id="cb25-250"><a href="#cb25-250" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Восстанавливаем полный вектор x с учётом перестановок</span></span>
<span id="cb25-251"><a href="#cb25-251" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.zeros(<span class="bu">len</span>(f))</span>
<span id="cb25-252"><a href="#cb25-252" aria-hidden="true" tabindex="-1"></a>    x[P[:rank]] <span class="op">=</span> x_red</span>
<span id="cb25-253"><a href="#cb25-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-254"><a href="#cb25-254" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span>
<span id="cb25-255"><a href="#cb25-255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-256"><a href="#cb25-256" aria-hidden="true" tabindex="-1"></a><span class="at">@measure_time</span></span>
<span id="cb25-257"><a href="#cb25-257" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> eigen_solve(K: np.ndarray, f: np.ndarray, tol: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1e-10</span>) <span class="op">-&gt;</span> NDArray:</span>
<span id="cb25-258"><a href="#cb25-258" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb25-259"><a href="#cb25-259" aria-hidden="true" tabindex="-1"></a><span class="co">    Решает систему через анализ собственных значений, убирая нулевые моды.</span></span>
<span id="cb25-260"><a href="#cb25-260" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb25-261"><a href="#cb25-261" aria-hidden="true" tabindex="-1"></a><span class="co">        K (np.ndarray): Матрица жёсткости (n x n).</span></span>
<span id="cb25-262"><a href="#cb25-262" aria-hidden="true" tabindex="-1"></a><span class="co">        f (np.ndarray): Вектор сил (n).</span></span>
<span id="cb25-263"><a href="#cb25-263" aria-hidden="true" tabindex="-1"></a><span class="co">        tol (float): Порог для нулевых собственных значений.</span></span>
<span id="cb25-264"><a href="#cb25-264" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb25-265"><a href="#cb25-265" aria-hidden="true" tabindex="-1"></a><span class="co">        NDArray: Решение x.</span></span>
<span id="cb25-266"><a href="#cb25-266" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb25-267"><a href="#cb25-267" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Собственные значения и векторы</span></span>
<span id="cb25-268"><a href="#cb25-268" aria-hidden="true" tabindex="-1"></a>    eigenvalues, eigenvectors <span class="op">=</span> np.linalg.eigh(K)</span>
<span id="cb25-269"><a href="#cb25-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-270"><a href="#cb25-270" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Определяем "жёсткие" моды</span></span>
<span id="cb25-271"><a href="#cb25-271" aria-hidden="true" tabindex="-1"></a>    active_modes <span class="op">=</span> eigenvalues <span class="op">&gt;</span> tol</span>
<span id="cb25-272"><a href="#cb25-272" aria-hidden="true" tabindex="-1"></a>    Lambda_red <span class="op">=</span> np.diag(eigenvalues[active_modes])</span>
<span id="cb25-273"><a href="#cb25-273" aria-hidden="true" tabindex="-1"></a>    V_red <span class="op">=</span> eigenvectors[:, active_modes]</span>
<span id="cb25-274"><a href="#cb25-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-275"><a href="#cb25-275" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Решаем в сокращённом базисе: V_red * Lambda_red * V_red^T * x = f</span></span>
<span id="cb25-276"><a href="#cb25-276" aria-hidden="true" tabindex="-1"></a>    f_red <span class="op">=</span> V_red.T <span class="op">@</span> f</span>
<span id="cb25-277"><a href="#cb25-277" aria-hidden="true" tabindex="-1"></a>    x_red <span class="op">=</span> np.linalg.solve(Lambda_red, f_red)</span>
<span id="cb25-278"><a href="#cb25-278" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-279"><a href="#cb25-279" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Восстанавливаем полное решение</span></span>
<span id="cb25-280"><a href="#cb25-280" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> V_red <span class="op">@</span> x_red</span>
<span id="cb25-281"><a href="#cb25-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-282"><a href="#cb25-282" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span>
<span id="cb25-283"><a href="#cb25-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-284"><a href="#cb25-284" aria-hidden="true" tabindex="-1"></a><span class="at">@measure_time</span></span>
<span id="cb25-285"><a href="#cb25-285" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mumps_solve(K: np.ndarray, f: np.ndarray) <span class="op">-&gt;</span> NDArray:</span>
<span id="cb25-286"><a href="#cb25-286" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb25-287"><a href="#cb25-287" aria-hidden="true" tabindex="-1"></a><span class="co">    Решает систему через MUMPS без стабилизации.</span></span>
<span id="cb25-288"><a href="#cb25-288" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb25-289"><a href="#cb25-289" aria-hidden="true" tabindex="-1"></a><span class="co">        K (np.ndarray): Матрица жёсткости (n x n).</span></span>
<span id="cb25-290"><a href="#cb25-290" aria-hidden="true" tabindex="-1"></a><span class="co">        f (np.ndarray): Вектор сил (n).</span></span>
<span id="cb25-291"><a href="#cb25-291" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb25-292"><a href="#cb25-292" aria-hidden="true" tabindex="-1"></a><span class="co">        NDArray: Решение x.</span></span>
<span id="cb25-293"><a href="#cb25-293" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb25-294"><a href="#cb25-294" aria-hidden="true" tabindex="-1"></a>    K_sparse <span class="op">=</span> csr_matrix(K)</span>
<span id="cb25-295"><a href="#cb25-295" aria-hidden="true" tabindex="-1"></a>    solver <span class="op">=</span> DMumpsContext()</span>
<span id="cb25-296"><a href="#cb25-296" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Включаем вывод для диагностики</span></span>
<span id="cb25-297"><a href="#cb25-297" aria-hidden="true" tabindex="-1"></a>    solver.set_icntl(<span class="dv">1</span>, <span class="dv">6</span>)     <span class="co"># Вывод ошибок</span></span>
<span id="cb25-298"><a href="#cb25-298" aria-hidden="true" tabindex="-1"></a>    solver.set_icntl(<span class="dv">3</span>, <span class="dv">6</span>)     <span class="co"># Глобальная информация</span></span>
<span id="cb25-299"><a href="#cb25-299" aria-hidden="true" tabindex="-1"></a>    solver.set_icntl(<span class="dv">4</span>, <span class="dv">1</span>)     <span class="co"># Уровень вывода (1 — только ошибки)</span></span>
<span id="cb25-300"><a href="#cb25-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-301"><a href="#cb25-301" aria-hidden="true" tabindex="-1"></a>    solver.set_icntl(<span class="dv">7</span>, <span class="dv">5</span>)     <span class="co"># METIS для упорядочения</span></span>
<span id="cb25-302"><a href="#cb25-302" aria-hidden="true" tabindex="-1"></a>    solver.set_icntl(<span class="dv">14</span>, <span class="dv">100</span>)  <span class="co"># Максимум памяти</span></span>
<span id="cb25-303"><a href="#cb25-303" aria-hidden="true" tabindex="-1"></a>    solver.set_icntl(<span class="dv">24</span>, <span class="dv">1</span>)    <span class="co"># Обнаружение вырожденности</span></span>
<span id="cb25-304"><a href="#cb25-304" aria-hidden="true" tabindex="-1"></a>    solver.set_icntl(<span class="dv">25</span>, <span class="dv">0</span>)    <span class="co"># По умолчанию</span></span>
<span id="cb25-305"><a href="#cb25-305" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-306"><a href="#cb25-306" aria-hidden="true" tabindex="-1"></a>    f_copy <span class="op">=</span> f.copy()   <span class="co"># копируем f, чтобы не портить оригинал, а то потом хер найдёшь ошибку</span></span>
<span id="cb25-307"><a href="#cb25-307" aria-hidden="true" tabindex="-1"></a>    solver.set_centralized_sparse(K_sparse)</span>
<span id="cb25-308"><a href="#cb25-308" aria-hidden="true" tabindex="-1"></a>    solver.set_rhs(f_copy)</span>
<span id="cb25-309"><a href="#cb25-309" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb25-310"><a href="#cb25-310" aria-hidden="true" tabindex="-1"></a>        solver.run(job<span class="op">=</span><span class="dv">1</span>)  <span class="co"># Анализ</span></span>
<span id="cb25-311"><a href="#cb25-311" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Анализ прошёл"</span>)</span>
<span id="cb25-312"><a href="#cb25-312" aria-hidden="true" tabindex="-1"></a>        solver.run(job<span class="op">=</span><span class="dv">2</span>)  <span class="co"># Факторизация</span></span>
<span id="cb25-313"><a href="#cb25-313" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Факторизация прошла"</span>)</span>
<span id="cb25-314"><a href="#cb25-314" aria-hidden="true" tabindex="-1"></a>        solver.run(job<span class="op">=</span><span class="dv">3</span>)  <span class="co"># Решение</span></span>
<span id="cb25-315"><a href="#cb25-315" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Решение найдено"</span>)</span>
<span id="cb25-316"><a href="#cb25-316" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> f_copy    <span class="co"># f_copy теперь содержит решение</span></span>
<span id="cb25-317"><a href="#cb25-317" aria-hidden="true" tabindex="-1"></a>        residual <span class="op">=</span> K <span class="op">@</span> x <span class="op">-</span> f    <span class="co"># Считаем невязку с исходным f</span></span>
<span id="cb25-318"><a href="#cb25-318" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Невязка MUMPS: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(residual)<span class="sc">:.2e}</span><span class="ss">"</span>)</span>
<span id="cb25-319"><a href="#cb25-319" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">RuntimeError</span> <span class="im">as</span> e:</span>
<span id="cb25-320"><a href="#cb25-320" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"MUMPS упал с ошибкой: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-321"><a href="#cb25-321" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> np.full_like(f, np.nan)</span>
<span id="cb25-322"><a href="#cb25-322" aria-hidden="true" tabindex="-1"></a>    <span class="cf">finally</span>:</span>
<span id="cb25-323"><a href="#cb25-323" aria-hidden="true" tabindex="-1"></a>        solver.destroy()</span>
<span id="cb25-324"><a href="#cb25-324" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span>
<span id="cb25-325"><a href="#cb25-325" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-326"><a href="#cb25-326" aria-hidden="true" tabindex="-1"></a><span class="at">@measure_time</span></span>
<span id="cb25-327"><a href="#cb25-327" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pardiso_solve(K: np.ndarray, f: np.ndarray) <span class="op">-&gt;</span> NDArray:</span>
<span id="cb25-328"><a href="#cb25-328" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb25-329"><a href="#cb25-329" aria-hidden="true" tabindex="-1"></a><span class="co">    Решает Kx = f через PARDISO для симметричных матриц.</span></span>
<span id="cb25-330"><a href="#cb25-330" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb25-331"><a href="#cb25-331" aria-hidden="true" tabindex="-1"></a><span class="co">        K (np.ndarray): Симметричная матрица жёсткости (n x n).</span></span>
<span id="cb25-332"><a href="#cb25-332" aria-hidden="true" tabindex="-1"></a><span class="co">        f (np.ndarray): Вектор сил (n).</span></span>
<span id="cb25-333"><a href="#cb25-333" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb25-334"><a href="#cb25-334" aria-hidden="true" tabindex="-1"></a><span class="co">        NDArray: Решение x.</span></span>
<span id="cb25-335"><a href="#cb25-335" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb25-336"><a href="#cb25-336" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Преобразуем K в разреженный формат CSR</span></span>
<span id="cb25-337"><a href="#cb25-337" aria-hidden="true" tabindex="-1"></a>    K_sparse <span class="op">=</span> csr_matrix(K)</span>
<span id="cb25-338"><a href="#cb25-338" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-339"><a href="#cb25-339" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Решаем систему через PARDISO</span></span>
<span id="cb25-340"><a href="#cb25-340" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb25-341"><a href="#cb25-341" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> spsolve(K_sparse, f)</span>
<span id="cb25-342"><a href="#cb25-342" aria-hidden="true" tabindex="-1"></a>        residual <span class="op">=</span> K <span class="op">@</span> x <span class="op">-</span> f</span>
<span id="cb25-343"><a href="#cb25-343" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Невязка PARDISO: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(residual)<span class="sc">:.2e}</span><span class="ss">"</span>)</span>
<span id="cb25-344"><a href="#cb25-344" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb25-345"><a href="#cb25-345" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"PARDISO упал с ошибкой: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-346"><a href="#cb25-346" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> np.full_like(f, np.nan)</span>
<span id="cb25-347"><a href="#cb25-347" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-348"><a href="#cb25-348" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span>
<span id="cb25-349"><a href="#cb25-349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-350"><a href="#cb25-350" aria-hidden="true" tabindex="-1"></a><span class="at">@measure_time</span></span>
<span id="cb25-351"><a href="#cb25-351" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mumps_like_lu_solve(K: np.ndarray, f: np.ndarray) <span class="op">-&gt;</span> NDArray:</span>
<span id="cb25-352"><a href="#cb25-352" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb25-353"><a href="#cb25-353" aria-hidden="true" tabindex="-1"></a><span class="co">    Решает Kx = f через LDLᵀ с RCM, как MUMPS для симметричных матриц.</span></span>
<span id="cb25-354"><a href="#cb25-354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-355"><a href="#cb25-355" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb25-356"><a href="#cb25-356" aria-hidden="true" tabindex="-1"></a><span class="co">        K (np.ndarray): Симметричная матрица жёсткости (n x n).</span></span>
<span id="cb25-357"><a href="#cb25-357" aria-hidden="true" tabindex="-1"></a><span class="co">        f (np.ndarray): Вектор сил (n).</span></span>
<span id="cb25-358"><a href="#cb25-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-359"><a href="#cb25-359" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb25-360"><a href="#cb25-360" aria-hidden="true" tabindex="-1"></a><span class="co">        NDArray: Частное решение x, совместимое с f.</span></span>
<span id="cb25-361"><a href="#cb25-361" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb25-362"><a href="#cb25-362" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Упорядочение RCM</span></span>
<span id="cb25-363"><a href="#cb25-363" aria-hidden="true" tabindex="-1"></a>    K_sparse <span class="op">=</span> csr_matrix(K)</span>
<span id="cb25-364"><a href="#cb25-364" aria-hidden="true" tabindex="-1"></a>    perm <span class="op">=</span> reverse_cuthill_mckee(K_sparse, symmetric_mode<span class="op">=</span><span class="va">True</span>)   <span class="co"># симметричная матрица</span></span>
<span id="cb25-365"><a href="#cb25-365" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Перестановка perm = </span><span class="sc">{</span>perm<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-366"><a href="#cb25-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-367"><a href="#cb25-367" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Перестановка k_red и f_red</span></span>
<span id="cb25-368"><a href="#cb25-368" aria-hidden="true" tabindex="-1"></a>    K_perm <span class="op">=</span> K[np.ix_(perm, perm)]</span>
<span id="cb25-369"><a href="#cb25-369" aria-hidden="true" tabindex="-1"></a>    f_perm <span class="op">=</span> f[perm]</span>
<span id="cb25-370"><a href="#cb25-370" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-371"><a href="#cb25-371" aria-hidden="true" tabindex="-1"></a>    <span class="co"># LU-разложение</span></span>
<span id="cb25-372"><a href="#cb25-372" aria-hidden="true" tabindex="-1"></a>    P, L, U <span class="op">=</span> lu(K_perm)</span>
<span id="cb25-373"><a href="#cb25-373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-374"><a href="#cb25-374" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Прямая подстановка: L y = P F_perm</span></span>
<span id="cb25-375"><a href="#cb25-375" aria-hidden="true" tabindex="-1"></a>    PF_perm <span class="op">=</span> P <span class="op">@</span> f_perm</span>
<span id="cb25-376"><a href="#cb25-376" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.linalg.solve(L, PF_perm)</span>
<span id="cb25-377"><a href="#cb25-377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-378"><a href="#cb25-378" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Обратная подстановка U u_perm = y</span></span>
<span id="cb25-379"><a href="#cb25-379" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(U)</span>
<span id="cb25-380"><a href="#cb25-380" aria-hidden="true" tabindex="-1"></a>    x_perm <span class="op">=</span> np.zeros(n)</span>
<span id="cb25-381"><a href="#cb25-381" aria-hidden="true" tabindex="-1"></a>    tol <span class="op">=</span> <span class="fl">1e-10</span></span>
<span id="cb25-382"><a href="#cb25-382" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb25-383"><a href="#cb25-383" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">abs</span>(U[i, i]) <span class="op">&lt;</span> tol:</span>
<span id="cb25-384"><a href="#cb25-384" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">abs</span>(y[i]) <span class="op">&lt;</span> tol:</span>
<span id="cb25-385"><a href="#cb25-385" aria-hidden="true" tabindex="-1"></a>                x_perm[i] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb25-386"><a href="#cb25-386" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb25-387"><a href="#cb25-387" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Система несовместима на шаге </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-388"><a href="#cb25-388" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb25-389"><a href="#cb25-389" aria-hidden="true" tabindex="-1"></a>            x_perm[i] <span class="op">=</span> (y[i] <span class="op">-</span> np.dot(U[i, i<span class="op">+</span><span class="dv">1</span>:], x_perm[i<span class="op">+</span><span class="dv">1</span>:])) <span class="op">/</span> U[i, i]</span>
<span id="cb25-390"><a href="#cb25-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-391"><a href="#cb25-391" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Обратная перестановка</span></span>
<span id="cb25-392"><a href="#cb25-392" aria-hidden="true" tabindex="-1"></a>    x_red <span class="op">=</span> np.zeros(n)</span>
<span id="cb25-393"><a href="#cb25-393" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, p <span class="kw">in</span> <span class="bu">enumerate</span>(perm):</span>
<span id="cb25-394"><a href="#cb25-394" aria-hidden="true" tabindex="-1"></a>        x_red[p] <span class="op">=</span> x_perm[i]</span>
<span id="cb25-395"><a href="#cb25-395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-396"><a href="#cb25-396" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x_red</span>
<span id="cb25-397"><a href="#cb25-397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-398"><a href="#cb25-398" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BeamStructure:</span>
<span id="cb25-399"><a href="#cb25-399" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb25-400"><a href="#cb25-400" aria-hidden="true" tabindex="-1"></a>        <span class="co">""" Исходные данные к задаче о шарнирно опёртой балке"""</span></span>
<span id="cb25-401"><a href="#cb25-401" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.L: <span class="bu">float</span> <span class="op">=</span> <span class="fl">600.0</span>           <span class="co">## Длина, мм</span></span>
<span id="cb25-402"><a href="#cb25-402" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.L_e: <span class="bu">float</span> <span class="op">=</span> <span class="va">self</span>.L <span class="op">/</span> <span class="dv">2</span>    <span class="co">## Длина элемента, мм</span></span>
<span id="cb25-403"><a href="#cb25-403" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.E: <span class="bu">float</span> <span class="op">=</span> <span class="fl">20000.0</span>         <span class="co">## Модуль упругости, кгс/мм^2</span></span>
<span id="cb25-404"><a href="#cb25-404" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.G: <span class="bu">float</span> <span class="op">=</span> <span class="fl">7692.31</span>         <span class="co">## Модуль сдвига, кгс/мм^2</span></span>
<span id="cb25-405"><a href="#cb25-405" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.A: <span class="bu">float</span> <span class="op">=</span> <span class="fl">78.54</span>           <span class="co">## Площадь поперечного сечения, мм^2</span></span>
<span id="cb25-406"><a href="#cb25-406" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.Iz: <span class="bu">float</span> <span class="op">=</span> <span class="fl">490.874</span>        <span class="co">## Момент инерции относительно оси z, мм^4</span></span>
<span id="cb25-407"><a href="#cb25-407" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.Iy: <span class="bu">float</span> <span class="op">=</span> <span class="fl">490.874</span>        <span class="co">## Момент инерции относительно оси y, мм^4</span></span>
<span id="cb25-408"><a href="#cb25-408" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.J: <span class="bu">float</span> <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> <span class="va">self</span>.Iz     <span class="co">## Полярный момент инерции, мм^4</span></span>
<span id="cb25-409"><a href="#cb25-409" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.k: <span class="bu">float</span> <span class="op">=</span> <span class="dv">10</span><span class="op">/</span><span class="dv">9</span>            <span class="co">## Коэффициент формы</span></span>
<span id="cb25-410"><a href="#cb25-410" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.F: <span class="bu">float</span> <span class="op">=</span> <span class="fl">1.0</span>             <span class="co">## Сила, кгс</span></span>
<span id="cb25-411"><a href="#cb25-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-412"><a href="#cb25-412" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> calculate_phi(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb25-413"><a href="#cb25-413" aria-hidden="true" tabindex="-1"></a>        <span class="co">""" Расчёт коэффициента Phi с учётом сдвиговой деформации"""</span></span>
<span id="cb25-414"><a href="#cb25-414" aria-hidden="true" tabindex="-1"></a>        phi <span class="op">=</span> <span class="dv">12</span> <span class="op">*</span> <span class="va">self</span>.E <span class="op">*</span> <span class="va">self</span>.Iz <span class="op">/</span> (<span class="va">self</span>.G <span class="op">*</span> <span class="va">self</span>.A <span class="op">*</span> <span class="va">self</span>.k <span class="op">*</span> <span class="va">self</span>.L_e <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb25-415"><a href="#cb25-415" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> phi</span>
<span id="cb25-416"><a href="#cb25-416" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-417"><a href="#cb25-417" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> calculate_stiffness_coefficients(<span class="va">self</span>, phi: <span class="bu">float</span>) <span class="op">-&gt;</span> Tuple[<span class="bu">float</span>, ...]:</span>
<span id="cb25-418"><a href="#cb25-418" aria-hidden="true" tabindex="-1"></a>        <span class="co">""" Расчёт коэффициентов жёсткости """</span></span>
<span id="cb25-419"><a href="#cb25-419" aria-hidden="true" tabindex="-1"></a>        k_ea <span class="op">=</span> <span class="va">self</span>.E <span class="op">*</span> <span class="va">self</span>.A <span class="op">/</span> <span class="va">self</span>.L_e                               <span class="co">## Жёсткость при растяжении вдоль балки</span></span>
<span id="cb25-420"><a href="#cb25-420" aria-hidden="true" tabindex="-1"></a>        k_gj <span class="op">=</span> <span class="va">self</span>.G <span class="op">*</span> <span class="va">self</span>.J <span class="op">/</span> <span class="va">self</span>.L_e                               <span class="co">## Жёсткость при кручении</span></span>
<span id="cb25-421"><a href="#cb25-421" aria-hidden="true" tabindex="-1"></a>        k11 <span class="op">=</span> <span class="dv">12</span> <span class="op">*</span> <span class="va">self</span>.E <span class="op">*</span> <span class="va">self</span>.Iz <span class="op">/</span> (<span class="va">self</span>.L_e<span class="op">**</span><span class="dv">3</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">+</span> phi))         <span class="co">## Жёсткость при изгибе (перемещение)</span></span>
<span id="cb25-422"><a href="#cb25-422" aria-hidden="true" tabindex="-1"></a>        k12 <span class="op">=</span> <span class="dv">6</span> <span class="op">*</span> <span class="va">self</span>.E <span class="op">*</span> <span class="va">self</span>.Iz <span class="op">/</span> (<span class="va">self</span>.L_e<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> (<span class="dv">1</span><span class="op">+</span>phi))            <span class="co">## Жёсткость при изгибе (перемещение и поворот)</span></span>
<span id="cb25-423"><a href="#cb25-423" aria-hidden="true" tabindex="-1"></a>        k22 <span class="op">=</span> (<span class="dv">4</span> <span class="op">+</span> phi) <span class="op">*</span> <span class="va">self</span>.E <span class="op">*</span> <span class="va">self</span>.Iz <span class="op">/</span> (<span class="va">self</span>.L_e <span class="op">*</span> (<span class="dv">1</span> <span class="op">+</span> phi))     <span class="co">## Жёскость при повороте на одном конце</span></span>
<span id="cb25-424"><a href="#cb25-424" aria-hidden="true" tabindex="-1"></a>        k24 <span class="op">=</span> (<span class="dv">2</span> <span class="op">-</span> phi) <span class="op">*</span> <span class="va">self</span>.E <span class="op">*</span> <span class="va">self</span>.Iz <span class="op">/</span> (<span class="va">self</span>.L_e <span class="op">*</span> (<span class="dv">1</span> <span class="op">+</span> phi))     <span class="co">## Жёсткость между поворотами на концах</span></span>
<span id="cb25-425"><a href="#cb25-425" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> k_ea, k_gj, k11, k12, k22, k24</span>
<span id="cb25-426"><a href="#cb25-426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-427"><a href="#cb25-427" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> build_local_stiffness_matrix(<span class="va">self</span>, k_ea: <span class="bu">float</span>, k_gj: <span class="bu">float</span>, k11: <span class="bu">float</span>,</span>
<span id="cb25-428"><a href="#cb25-428" aria-hidden="true" tabindex="-1"></a>                                     k12: <span class="bu">float</span>, k22: <span class="bu">float</span>, k24: <span class="bu">float</span>) <span class="op">-&gt;</span> NDArray:</span>
<span id="cb25-429"><a href="#cb25-429" aria-hidden="true" tabindex="-1"></a>        <span class="co">""" Построение локальной матрицы жёсткости 12х12 """</span></span>
<span id="cb25-430"><a href="#cb25-430" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Создание пустой матрицы 12х12 (12 степеней свободы, 6 на каждом конце)</span></span>
<span id="cb25-431"><a href="#cb25-431" aria-hidden="true" tabindex="-1"></a>        ke <span class="op">=</span> np.zeros((<span class="dv">12</span>,<span class="dv">12</span>))</span>
<span id="cb25-432"><a href="#cb25-432" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Заполнение ненулевых элементов</span></span>
<span id="cb25-433"><a href="#cb25-433" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Растяжение вдоль оси балки (вдоль оси х)</span></span>
<span id="cb25-434"><a href="#cb25-434" aria-hidden="true" tabindex="-1"></a>        ke[<span class="dv">0</span>, <span class="dv">0</span>] <span class="op">=</span> k_ea<span class="op">;</span>  ke[<span class="dv">0</span>, <span class="dv">6</span>] <span class="op">=</span> <span class="op">-</span>k_ea<span class="op">;</span>  ke[<span class="dv">6</span>, <span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span>k_ea<span class="op">;</span>  ke[<span class="dv">6</span>, <span class="dv">6</span>] <span class="op">=</span> k_ea</span>
<span id="cb25-435"><a href="#cb25-435" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Изгиб в плоскости y (перемещения и повороты)</span></span>
<span id="cb25-436"><a href="#cb25-436" aria-hidden="true" tabindex="-1"></a>        ke[<span class="dv">1</span>, <span class="dv">1</span>] <span class="op">=</span> k11<span class="op">;</span>   ke[<span class="dv">1</span>, <span class="dv">5</span>] <span class="op">=</span> k12<span class="op">;</span>   ke[<span class="dv">1</span>, <span class="dv">7</span>] <span class="op">=</span> <span class="op">-</span>k11<span class="op">;</span>  ke[<span class="dv">1</span>, <span class="dv">11</span>] <span class="op">=</span> k12</span>
<span id="cb25-437"><a href="#cb25-437" aria-hidden="true" tabindex="-1"></a>        ke[<span class="dv">5</span>, <span class="dv">1</span>] <span class="op">=</span> k12<span class="op">;</span>   ke[<span class="dv">5</span>, <span class="dv">5</span>] <span class="op">=</span> k22<span class="op">;</span>   ke[<span class="dv">5</span>, <span class="dv">7</span>] <span class="op">=</span> <span class="op">-</span>k12<span class="op">;</span>  ke[<span class="dv">5</span>, <span class="dv">11</span>] <span class="op">=</span> k24</span>
<span id="cb25-438"><a href="#cb25-438" aria-hidden="true" tabindex="-1"></a>        ke[<span class="dv">7</span>, <span class="dv">1</span>] <span class="op">=</span> <span class="op">-</span>k11<span class="op">;</span>  ke[<span class="dv">7</span>, <span class="dv">5</span>] <span class="op">=</span> <span class="op">-</span>k12<span class="op">;</span>  ke[<span class="dv">7</span>, <span class="dv">7</span>] <span class="op">=</span> k11<span class="op">;</span>   ke[<span class="dv">7</span>, <span class="dv">11</span>] <span class="op">=</span> <span class="op">-</span>k12</span>
<span id="cb25-439"><a href="#cb25-439" aria-hidden="true" tabindex="-1"></a>        ke[<span class="dv">11</span>, <span class="dv">1</span>] <span class="op">=</span> k12<span class="op">;</span>  ke[<span class="dv">11</span>, <span class="dv">5</span>] <span class="op">=</span> k24<span class="op">;</span>  ke[<span class="dv">11</span>, <span class="dv">7</span>] <span class="op">=</span> <span class="op">-</span>k12<span class="op">;</span> ke[<span class="dv">11</span>, <span class="dv">11</span>] <span class="op">=</span> k22</span>
<span id="cb25-440"><a href="#cb25-440" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Изгиб в плоскости z (перемещения и повороты)</span></span>
<span id="cb25-441"><a href="#cb25-441" aria-hidden="true" tabindex="-1"></a>        ke[<span class="dv">2</span>, <span class="dv">2</span>] <span class="op">=</span> k11<span class="op">;</span>   ke[<span class="dv">2</span>, <span class="dv">4</span>] <span class="op">=</span> <span class="op">-</span>k12<span class="op">;</span>  ke[<span class="dv">2</span>, <span class="dv">8</span>] <span class="op">=</span> <span class="op">-</span>k11<span class="op">;</span>  ke[<span class="dv">2</span>, <span class="dv">10</span>] <span class="op">=</span> <span class="op">-</span>k12</span>
<span id="cb25-442"><a href="#cb25-442" aria-hidden="true" tabindex="-1"></a>        ke[<span class="dv">4</span>, <span class="dv">2</span>] <span class="op">=</span> <span class="op">-</span>k12<span class="op">;</span>  ke[<span class="dv">4</span>, <span class="dv">4</span>] <span class="op">=</span> k22<span class="op">;</span>   ke[<span class="dv">4</span>, <span class="dv">8</span>] <span class="op">=</span> k12<span class="op">;</span>   ke[<span class="dv">4</span>, <span class="dv">10</span>] <span class="op">=</span> k24</span>
<span id="cb25-443"><a href="#cb25-443" aria-hidden="true" tabindex="-1"></a>        ke[<span class="dv">8</span>, <span class="dv">2</span>] <span class="op">=</span> <span class="op">-</span>k11<span class="op">;</span>  ke[<span class="dv">8</span>, <span class="dv">4</span>] <span class="op">=</span> k12<span class="op">;</span>   ke[<span class="dv">8</span>, <span class="dv">8</span>] <span class="op">=</span> k11<span class="op">;</span>   ke[<span class="dv">8</span>, <span class="dv">10</span>] <span class="op">=</span> k12</span>
<span id="cb25-444"><a href="#cb25-444" aria-hidden="true" tabindex="-1"></a>        ke[<span class="dv">10</span>, <span class="dv">2</span>] <span class="op">=</span> <span class="op">-</span>k12<span class="op">;</span> ke[<span class="dv">10</span>, <span class="dv">4</span>] <span class="op">=</span> k24<span class="op">;</span>  ke[<span class="dv">10</span>, <span class="dv">8</span>] <span class="op">=</span> k12<span class="op">;</span>  ke[<span class="dv">10</span>, <span class="dv">10</span>] <span class="op">=</span> k22</span>
<span id="cb25-445"><a href="#cb25-445" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Кручение балки вокруг оси х</span></span>
<span id="cb25-446"><a href="#cb25-446" aria-hidden="true" tabindex="-1"></a>        ke[<span class="dv">3</span>, <span class="dv">3</span>] <span class="op">=</span> k_gj<span class="op">;</span>  ke[<span class="dv">3</span>, <span class="dv">9</span>] <span class="op">=</span> <span class="op">-</span>k_gj<span class="op">;</span> ke[<span class="dv">9</span>, <span class="dv">3</span>] <span class="op">=</span> <span class="op">-</span>k_gj<span class="op">;</span> ke[<span class="dv">9</span>, <span class="dv">9</span>] <span class="op">=</span> k_gj</span>
<span id="cb25-447"><a href="#cb25-447" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ke</span>
<span id="cb25-448"><a href="#cb25-448" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-449"><a href="#cb25-449" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> assemble_global_matrix(<span class="va">self</span>, ke: NDArray) <span class="op">-&gt;</span> NDArray:</span>
<span id="cb25-450"><a href="#cb25-450" aria-hidden="true" tabindex="-1"></a>        <span class="co">""" Сборка глобальной матрицы жёсткости 18х18 """</span></span>
<span id="cb25-451"><a href="#cb25-451" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Создание пустой матрицы 18х18 (18 степеней свободы, 6 в каждом узле)</span></span>
<span id="cb25-452"><a href="#cb25-452" aria-hidden="true" tabindex="-1"></a>        k_global <span class="op">=</span> np.zeros((<span class="dv">18</span>, <span class="dv">18</span>))</span>
<span id="cb25-453"><a href="#cb25-453" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Добавление первого элемента (первые 12 строк и столбцов)</span></span>
<span id="cb25-454"><a href="#cb25-454" aria-hidden="true" tabindex="-1"></a>        k_global[<span class="dv">0</span>:<span class="dv">12</span>, <span class="dv">0</span>:<span class="dv">12</span>] <span class="op">+=</span> ke</span>
<span id="cb25-455"><a href="#cb25-455" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Добавление второго элемента (последние 12 строк и столбцов)</span></span>
<span id="cb25-456"><a href="#cb25-456" aria-hidden="true" tabindex="-1"></a>        k_global[<span class="dv">6</span>:<span class="dv">18</span>, <span class="dv">6</span>:<span class="dv">18</span>] <span class="op">+=</span> ke</span>
<span id="cb25-457"><a href="#cb25-457" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> k_global</span>
<span id="cb25-458"><a href="#cb25-458" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-459"><a href="#cb25-459" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> apply_boundary_conditions(<span class="va">self</span>) <span class="op">-&gt;</span> Tuple[List[<span class="bu">int</span>], NDArray]:</span>
<span id="cb25-460"><a href="#cb25-460" aria-hidden="true" tabindex="-1"></a>        <span class="co">""" Применение граничных условий и определение свободных dofs """</span></span>
<span id="cb25-461"><a href="#cb25-461" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Шарнирные опоры в 1 и 3 узлах</span></span>
<span id="cb25-462"><a href="#cb25-462" aria-hidden="true" tabindex="-1"></a>        <span class="co">## (0 - u1x, 1 - u1y, 2 - u1z, 3 - theta1x, 12 - u3x, 13 - u3y, 14 - u3z, 15 - theta3z)</span></span>
<span id="cb25-463"><a href="#cb25-463" aria-hidden="true" tabindex="-1"></a>        <span class="co">##fixed_dofs = [0, 1, 2, 3, 12, 13, 14, 15]</span></span>
<span id="cb25-464"><a href="#cb25-464" aria-hidden="true" tabindex="-1"></a>        fixed_dofs <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">12</span>, <span class="dv">13</span>, <span class="dv">14</span>]</span>
<span id="cb25-465"><a href="#cb25-465" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Свободные степени свободы (всё, что не закреплено)</span></span>
<span id="cb25-466"><a href="#cb25-466" aria-hidden="true" tabindex="-1"></a>        free_dofs <span class="op">=</span> [i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">18</span>) <span class="cf">if</span> i <span class="kw">not</span> <span class="kw">in</span> fixed_dofs]</span>
<span id="cb25-467"><a href="#cb25-467" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Вектор нагрузок (18 нулей, сила только по индексу 7 - u2y)</span></span>
<span id="cb25-468"><a href="#cb25-468" aria-hidden="true" tabindex="-1"></a>        f_full <span class="op">=</span> np.zeros(<span class="dv">18</span>)</span>
<span id="cb25-469"><a href="#cb25-469" aria-hidden="true" tabindex="-1"></a>        f_full[<span class="dv">7</span>] <span class="op">=</span> <span class="va">self</span>.F <span class="co">## Приложенная сила F2y</span></span>
<span id="cb25-470"><a href="#cb25-470" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> free_dofs, f_full</span>
<span id="cb25-471"><a href="#cb25-471" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-472"><a href="#cb25-472" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> solve_system(<span class="va">self</span>, k_global: NDArray, free_dofs: List[<span class="bu">int</span>],</span>
<span id="cb25-473"><a href="#cb25-473" aria-hidden="true" tabindex="-1"></a>                     f_full: NDArray) <span class="op">-&gt;</span> Tuple[NDArray, <span class="bu">float</span>, NDArray, <span class="bu">float</span>]:</span>
<span id="cb25-474"><a href="#cb25-474" aria-hidden="true" tabindex="-1"></a>        <span class="co">""" Решение системы уравнений для перемещенеий """</span></span>
<span id="cb25-475"><a href="#cb25-475" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Оставляем только "свободные части" матрицы жёсткости и вектора нагрузок</span></span>
<span id="cb25-476"><a href="#cb25-476" aria-hidden="true" tabindex="-1"></a>        k_red <span class="op">=</span> k_global[np.ix_(free_dofs, free_dofs)]</span>
<span id="cb25-477"><a href="#cb25-477" aria-hidden="true" tabindex="-1"></a>        f_red <span class="op">=</span> f_full[free_dofs]</span>
<span id="cb25-478"><a href="#cb25-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-479"><a href="#cb25-479" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Решаем систему: K * u = F, где u - вектор перемещений</span></span>
<span id="cb25-480"><a href="#cb25-480" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Используем собственную функцию, реализующую метод Гаусса</span></span>
<span id="cb25-481"><a href="#cb25-481" aria-hidden="true" tabindex="-1"></a>        u_red_my <span class="op">=</span> <span class="va">None</span></span>
<span id="cb25-482"><a href="#cb25-482" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb25-483"><a href="#cb25-483" aria-hidden="true" tabindex="-1"></a>            u_red_my <span class="op">=</span> my_solve(k_red, f_red)</span>
<span id="cb25-484"><a href="#cb25-484" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">ValueError</span> <span class="im">as</span> e:</span>
<span id="cb25-485"><a href="#cb25-485" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"my_solve: система вырожденная - </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-486"><a href="#cb25-486" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-487"><a href="#cb25-487" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Решаем систему: K * u = F, где u - вектор перемещений</span></span>
<span id="cb25-488"><a href="#cb25-488" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Используем функцию из билиотеки NumPy (PLU азложение с оптимизацией)</span></span>
<span id="cb25-489"><a href="#cb25-489" aria-hidden="true" tabindex="-1"></a>        u_red_np <span class="op">=</span> <span class="va">None</span></span>
<span id="cb25-490"><a href="#cb25-490" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb25-491"><a href="#cb25-491" aria-hidden="true" tabindex="-1"></a>            u_red_np <span class="op">=</span> np.linalg.solve(k_red, f_red)</span>
<span id="cb25-492"><a href="#cb25-492" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">ValueError</span> <span class="im">as</span> e:</span>
<span id="cb25-493"><a href="#cb25-493" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"np.linalg.solve: система вырожденная - </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-494"><a href="#cb25-494" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-495"><a href="#cb25-495" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Решаем систему: K * u = F, где u - вектор перемещений</span></span>
<span id="cb25-496"><a href="#cb25-496" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Используем собственную функцию plu_solve (PLU разложение)</span></span>
<span id="cb25-497"><a href="#cb25-497" aria-hidden="true" tabindex="-1"></a>        u_red_plu <span class="op">=</span> <span class="va">None</span></span>
<span id="cb25-498"><a href="#cb25-498" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb25-499"><a href="#cb25-499" aria-hidden="true" tabindex="-1"></a>            u_red_plu <span class="op">=</span> plu_solve(k_red, f_red)</span>
<span id="cb25-500"><a href="#cb25-500" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">ValueError</span> <span class="im">as</span> e:</span>
<span id="cb25-501"><a href="#cb25-501" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"plu_solve: система вырожденная - </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-502"><a href="#cb25-502" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-503"><a href="#cb25-503" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Решаем систему: K * u = F, где u - вектор перемещений</span></span>
<span id="cb25-504"><a href="#cb25-504" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Используем псевдообратную матрицу через сингулярное разложение SVD</span></span>
<span id="cb25-505"><a href="#cb25-505" aria-hidden="true" tabindex="-1"></a>        u_red_pinv <span class="op">=</span> np.linalg.pinv(k_red) <span class="op">@</span> f_red</span>
<span id="cb25-506"><a href="#cb25-506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-507"><a href="#cb25-507" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Решаем систему: K * u = F, где u - вектор перемещений</span></span>
<span id="cb25-508"><a href="#cb25-508" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Находим базис ядра и частное решение через сингулярное разложение SVD</span></span>
<span id="cb25-509"><a href="#cb25-509" aria-hidden="true" tabindex="-1"></a>        u_red_svd, kernel <span class="op">=</span> svd_solve(k_red, f_red)</span>
<span id="cb25-510"><a href="#cb25-510" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-511"><a href="#cb25-511" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Решаем систему: K * u = F, где u - вектор перемещений</span></span>
<span id="cb25-512"><a href="#cb25-512" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Регуляризация Тихонова</span></span>
<span id="cb25-513"><a href="#cb25-513" aria-hidden="true" tabindex="-1"></a>        u_red_tikh <span class="op">=</span> tikhonov_solve(k_red, f_red)</span>
<span id="cb25-514"><a href="#cb25-514" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-515"><a href="#cb25-515" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Решаем систему: K * u = F, где u - вектор перемещений</span></span>
<span id="cb25-516"><a href="#cb25-516" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Мягкие пружины</span></span>
<span id="cb25-517"><a href="#cb25-517" aria-hidden="true" tabindex="-1"></a>        <span class="co">##global_stab_indices = [0, 1, 2, 12, 13, 14]  # u1x, u1y, u1z, u3x, u3y, u3z в K_global</span></span>
<span id="cb25-518"><a href="#cb25-518" aria-hidden="true" tabindex="-1"></a>        global_stab_indices <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">15</span>, <span class="dv">16</span>, <span class="dv">17</span>] <span class="co"># theta1x, theta1y, theta1z, theta3x, theta3y, theta3z в k_global</span></span>
<span id="cb25-519"><a href="#cb25-519" aria-hidden="true" tabindex="-1"></a>        u_red_spring <span class="op">=</span> <span class="va">None</span></span>
<span id="cb25-520"><a href="#cb25-520" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb25-521"><a href="#cb25-521" aria-hidden="true" tabindex="-1"></a>            u_red_spring <span class="op">=</span> spring_solve(k_red, f_red, global_stab_indices, free_dofs)</span>
<span id="cb25-522"><a href="#cb25-522" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> u_red_spring <span class="kw">is</span> <span class="va">None</span>:  <span class="co"># Если сингулярна, выходим из цикла</span></span>
<span id="cb25-523"><a href="#cb25-523" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> np.linalg.LinAlgError(<span class="st">"Сингулярность осталась"</span>)</span>
<span id="cb25-524"><a href="#cb25-524" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> np.linalg.LinAlgError:</span>
<span id="cb25-525"><a href="#cb25-525" aria-hidden="true" tabindex="-1"></a>            time_spring <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb25-526"><a href="#cb25-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-527"><a href="#cb25-527" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Решаем систему: K * u = F, где u - вектор перемещений</span></span>
<span id="cb25-528"><a href="#cb25-528" aria-hidden="true" tabindex="-1"></a>        <span class="co">## QR-разложение</span></span>
<span id="cb25-529"><a href="#cb25-529" aria-hidden="true" tabindex="-1"></a>        u_red_qr <span class="op">=</span> qr_solve(k_red, f_red)</span>
<span id="cb25-530"><a href="#cb25-530" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-531"><a href="#cb25-531" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Решаем систему: K * u = F, где u - вектор перемещений</span></span>
<span id="cb25-532"><a href="#cb25-532" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Анализ собственных значений</span></span>
<span id="cb25-533"><a href="#cb25-533" aria-hidden="true" tabindex="-1"></a>        u_red_eigen <span class="op">=</span> eigen_solve(k_red, f_red)</span>
<span id="cb25-534"><a href="#cb25-534" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-535"><a href="#cb25-535" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Решаем систему: K * u = F, где u - вектор перемещений</span></span>
<span id="cb25-536"><a href="#cb25-536" aria-hidden="true" tabindex="-1"></a>        <span class="co">## MUMPS</span></span>
<span id="cb25-537"><a href="#cb25-537" aria-hidden="true" tabindex="-1"></a>        u_red_mumps <span class="op">=</span> mumps_solve(k_red, f_red)</span>
<span id="cb25-538"><a href="#cb25-538" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-539"><a href="#cb25-539" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Решаем систему: K * u = F, где u - вектор перемещений</span></span>
<span id="cb25-540"><a href="#cb25-540" aria-hidden="true" tabindex="-1"></a>        <span class="co">## MUMPS-like</span></span>
<span id="cb25-541"><a href="#cb25-541" aria-hidden="true" tabindex="-1"></a>        u_red_lu <span class="op">=</span> mumps_like_lu_solve(k_red, f_red)</span>
<span id="cb25-542"><a href="#cb25-542" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-543"><a href="#cb25-543" aria-hidden="true" tabindex="-1"></a>        <span class="co"># PARDISO</span></span>
<span id="cb25-544"><a href="#cb25-544" aria-hidden="true" tabindex="-1"></a>        u_red_pardiso <span class="op">=</span> pardiso_solve(k_red, f_red)</span>
<span id="cb25-545"><a href="#cb25-545" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-546"><a href="#cb25-546" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> u_red_my, u_red_np, u_red_plu, u_red_pinv, u_red_svd, kernel, u_red_tikh, u_red_spring, u_red_qr, <span class="op">\</span></span>
<span id="cb25-547"><a href="#cb25-547" aria-hidden="true" tabindex="-1"></a>            u_red_eigen, u_red_mumps, u_red_lu, u_red_pardiso</span>
<span id="cb25-548"><a href="#cb25-548" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-549"><a href="#cb25-549" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> main() <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb25-550"><a href="#cb25-550" aria-hidden="true" tabindex="-1"></a>    <span class="co">""" Основная функция """</span></span>
<span id="cb25-551"><a href="#cb25-551" aria-hidden="true" tabindex="-1"></a>    beam <span class="op">=</span> BeamStructure()</span>
<span id="cb25-552"><a href="#cb25-552" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-553"><a href="#cb25-553" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Вывод исходный данных</span></span>
<span id="cb25-554"><a href="#cb25-554" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"E = </span><span class="sc">{</span>beam<span class="sc">.</span>E<span class="sc">:.2e}</span><span class="ss"> кгс/мм^2, G = </span><span class="sc">{</span>beam<span class="sc">.</span>G<span class="sc">:.2e}</span><span class="ss"> кгс/мм^2, "</span></span>
<span id="cb25-555"><a href="#cb25-555" aria-hidden="true" tabindex="-1"></a>          <span class="ss">f"A = </span><span class="sc">{</span>beam<span class="sc">.</span>A<span class="sc">:.2e}</span><span class="ss"> мм^2, Iz = </span><span class="sc">{</span>beam<span class="sc">.</span>Iz<span class="sc">:.2e}</span><span class="ss"> мм^4, "</span></span>
<span id="cb25-556"><a href="#cb25-556" aria-hidden="true" tabindex="-1"></a>          <span class="ss">f"J = </span><span class="sc">{</span>beam<span class="sc">.</span>J<span class="sc">:.2e}</span><span class="ss"> мм^4, L_e = </span><span class="sc">{</span>beam<span class="sc">.</span>L_e<span class="sc">:.2e}</span><span class="ss"> мм"</span>)</span>
<span id="cb25-557"><a href="#cb25-557" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-558"><a href="#cb25-558" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Расчёт промежуточных величин</span></span>
<span id="cb25-559"><a href="#cb25-559" aria-hidden="true" tabindex="-1"></a>    phi <span class="op">=</span> beam.calculate_phi()</span>
<span id="cb25-560"><a href="#cb25-560" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Phi = </span><span class="sc">{</span>phi<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-561"><a href="#cb25-561" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-562"><a href="#cb25-562" aria-hidden="true" tabindex="-1"></a>    k_ea, k_gj, k11, k12, k22, k24 <span class="op">=</span> beam.calculate_stiffness_coefficients(phi)</span>
<span id="cb25-563"><a href="#cb25-563" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"k11 = </span><span class="sc">{</span>k11<span class="sc">:.2e}</span><span class="ss">, k12 = </span><span class="sc">{</span>k12<span class="sc">:.2e}</span><span class="ss">, k22 = </span><span class="sc">{</span>k22<span class="sc">:.2e}</span><span class="ss">, "</span></span>
<span id="cb25-564"><a href="#cb25-564" aria-hidden="true" tabindex="-1"></a>          <span class="ss">f"k24 = </span><span class="sc">{</span>k24<span class="sc">:.2e}</span><span class="ss">"</span>)</span>
<span id="cb25-565"><a href="#cb25-565" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"k_ea = </span><span class="sc">{</span>k_ea<span class="sc">:.2e}</span><span class="ss">, k_gj = </span><span class="sc">{</span>k_gj<span class="sc">:.2e}</span><span class="ss">"</span>)</span>
<span id="cb25-566"><a href="#cb25-566" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-567"><a href="#cb25-567" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Построение матриц</span></span>
<span id="cb25-568"><a href="#cb25-568" aria-hidden="true" tabindex="-1"></a>    ke <span class="op">=</span> beam.build_local_stiffness_matrix(k_ea, k_gj, k11, k12, k22, k24)</span>
<span id="cb25-569"><a href="#cb25-569" aria-hidden="true" tabindex="-1"></a>    k_global <span class="op">=</span> beam.assemble_global_matrix(ke)</span>
<span id="cb25-570"><a href="#cb25-570" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-571"><a href="#cb25-571" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Вывод матрицы</span></span>
<span id="cb25-572"><a href="#cb25-572" aria-hidden="true" tabindex="-1"></a>    np.set_printoptions(precision<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb25-573"><a href="#cb25-573" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Полная матрица жесткости:"</span>)</span>
<span id="cb25-574"><a href="#cb25-574" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(k_global)</span>
<span id="cb25-575"><a href="#cb25-575" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-576"><a href="#cb25-576" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Граничные условия и решение</span></span>
<span id="cb25-577"><a href="#cb25-577" aria-hidden="true" tabindex="-1"></a>    free_dofs, f_full <span class="op">=</span> beam.apply_boundary_conditions()</span>
<span id="cb25-578"><a href="#cb25-578" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Свободные степени свободы: </span><span class="sc">{</span>free_dofs<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-579"><a href="#cb25-579" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Вектор сил: </span><span class="sc">{</span>f_full<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-580"><a href="#cb25-580" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-581"><a href="#cb25-581" aria-hidden="true" tabindex="-1"></a>    k_red <span class="op">=</span> k_global[np.ix_(free_dofs, free_dofs)]</span>
<span id="cb25-582"><a href="#cb25-582" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Детерминант K_red = </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>det(k_red)<span class="sc">:.2e}</span><span class="ss">"</span>)</span>
<span id="cb25-583"><a href="#cb25-583" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-584"><a href="#cb25-584" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Решаем с замерами времени ## u_red_gmres,</span></span>
<span id="cb25-585"><a href="#cb25-585" aria-hidden="true" tabindex="-1"></a>    u_red_my, u_red_np, u_red_plu, u_red_pinv, u_red_svd, kernel, u_red_tikh, u_red_spring, u_red_qr, <span class="op">\</span></span>
<span id="cb25-586"><a href="#cb25-586" aria-hidden="true" tabindex="-1"></a>        u_red_eigen, u_red_mumps, u_red_lu, u_red_pardiso <span class="op">=</span> <span class="op">\</span></span>
<span id="cb25-587"><a href="#cb25-587" aria-hidden="true" tabindex="-1"></a>        beam.solve_system(k_global, free_dofs, f_full)</span>
<span id="cb25-588"><a href="#cb25-588" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-589"><a href="#cb25-589" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Вывод с проверкой на None</span></span>
<span id="cb25-590"><a href="#cb25-590" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> u_red_my <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb25-591"><a href="#cb25-591" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Перемещения (my_solve): </span><span class="sc">{</span>u_red_my<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-592"><a href="#cb25-592" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Прогиб u_2y (my_solve): </span><span class="sc">{</span>u_red_my[free_dofs.index(<span class="dv">7</span>)]<span class="sc">:.4f}</span><span class="ss"> мм"</span>)</span>
<span id="cb25-593"><a href="#cb25-593" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb25-594"><a href="#cb25-594" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Перемещения (my_solve): не удалось вычислить из-за вырожденности"</span>)</span>
<span id="cb25-595"><a href="#cb25-595" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-596"><a href="#cb25-596" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> u_red_np <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb25-597"><a href="#cb25-597" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Перемещения (NumPy): </span><span class="sc">{</span>u_red_np<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-598"><a href="#cb25-598" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Прогиб u_2y (NumPy): </span><span class="sc">{</span>u_red_np[free_dofs.index(<span class="dv">7</span>)]<span class="sc">:.4f}</span><span class="ss"> мм"</span>)</span>
<span id="cb25-599"><a href="#cb25-599" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb25-600"><a href="#cb25-600" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Перемещения (NumPy): не удалось вычислить из-за вырожденности"</span>)</span>
<span id="cb25-601"><a href="#cb25-601" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-602"><a href="#cb25-602" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> u_red_plu <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb25-603"><a href="#cb25-603" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Перемещения (plu_solve): </span><span class="sc">{</span>u_red_plu<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-604"><a href="#cb25-604" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Прогиб u_2y (plu_solve): </span><span class="sc">{</span>u_red_plu[free_dofs.index(<span class="dv">7</span>)]<span class="sc">:.4f}</span><span class="ss"> мм"</span>)</span>
<span id="cb25-605"><a href="#cb25-605" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb25-606"><a href="#cb25-606" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Перемещения (plu_solve): не удалось вычислить из-за вырожденности"</span>)</span>
<span id="cb25-607"><a href="#cb25-607" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-608"><a href="#cb25-608" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Перемещения (псевдообратная): </span><span class="sc">{</span>u_red_pinv<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-609"><a href="#cb25-609" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Прогиб u_2y (псевдообратная): </span><span class="sc">{</span>u_red_pinv[free_dofs.index(<span class="dv">7</span>)]<span class="sc">:.4f}</span><span class="ss"> мм"</span>)</span>
<span id="cb25-610"><a href="#cb25-610" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-611"><a href="#cb25-611" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Перемещения (SVD частное): </span><span class="sc">{</span>u_red_svd<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-612"><a href="#cb25-612" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Прогиб u_2y (SVD): </span><span class="sc">{</span>u_red_svd[free_dofs.index(<span class="dv">7</span>)]<span class="sc">:.4f}</span><span class="ss"> мм"</span>)</span>
<span id="cb25-613"><a href="#cb25-613" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-614"><a href="#cb25-614" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Перемещения (Тихонов): </span><span class="sc">{</span>u_red_tikh<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-615"><a href="#cb25-615" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Прогиб u_2y (Тихонов): </span><span class="sc">{</span>u_red_tikh[free_dofs.index(<span class="dv">7</span>)]<span class="sc">:.4f}</span><span class="ss"> мм"</span>)</span>
<span id="cb25-616"><a href="#cb25-616" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-617"><a href="#cb25-617" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> u_red_spring <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb25-618"><a href="#cb25-618" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Перемещения (мягкие пружины): </span><span class="sc">{</span>u_red_spring<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-619"><a href="#cb25-619" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Прогиб u_2y (мягкие пружины): </span><span class="sc">{</span>u_red_spring[free_dofs.index(<span class="dv">7</span>)]<span class="sc">:.4f}</span><span class="ss"> мм"</span>)</span>
<span id="cb25-620"><a href="#cb25-620" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb25-621"><a href="#cb25-621" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Перемещения (spring_solve) не удалось вычислить из-за вырожденности"</span>)</span>
<span id="cb25-622"><a href="#cb25-622" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-623"><a href="#cb25-623" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Перемещения (QR): </span><span class="sc">{</span>u_red_qr<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-624"><a href="#cb25-624" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Прогиб u_2y (QR): </span><span class="sc">{</span>u_red_qr[free_dofs.index(<span class="dv">7</span>)]<span class="sc">:.4f}</span><span class="ss"> мм"</span>)</span>
<span id="cb25-625"><a href="#cb25-625" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-626"><a href="#cb25-626" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Перемещения (Eigen): </span><span class="sc">{</span>u_red_eigen<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-627"><a href="#cb25-627" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Прогиб u_2y (Eigen): </span><span class="sc">{</span>u_red_eigen[free_dofs.index(<span class="dv">7</span>)]<span class="sc">:.4f}</span><span class="ss"> мм"</span>)</span>
<span id="cb25-628"><a href="#cb25-628" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-629"><a href="#cb25-629" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Перемещения (MUMPS): </span><span class="sc">{</span>u_red_mumps<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-630"><a href="#cb25-630" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Прогиб u_2y (MUMPS): </span><span class="sc">{</span>u_red_mumps[free_dofs.index(<span class="dv">7</span>)]<span class="sc">:.4f}</span><span class="ss"> мм"</span>)</span>
<span id="cb25-631"><a href="#cb25-631" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-632"><a href="#cb25-632" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Перемещения (LU): </span><span class="sc">{</span>u_red_lu<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-633"><a href="#cb25-633" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Прогиб u_2y (LU): </span><span class="sc">{</span>u_red_lu[free_dofs.index(<span class="dv">7</span>)]<span class="sc">:.4f}</span><span class="ss"> мм"</span>)</span>
<span id="cb25-634"><a href="#cb25-634" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-635"><a href="#cb25-635" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Перемещения (PARDISO): </span><span class="sc">{</span>u_red_pardiso<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-636"><a href="#cb25-636" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Прогиб u_2y (PARDISO): </span><span class="sc">{</span>u_red_pardiso[free_dofs.index(<span class="dv">7</span>)]<span class="sc">:.4f}</span><span class="ss"> мм"</span>)</span>
<span id="cb25-637"><a href="#cb25-637" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-638"><a href="#cb25-638" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="cb25-639"><a href="#cb25-639" aria-hidden="true" tabindex="-1"></a>    main()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>